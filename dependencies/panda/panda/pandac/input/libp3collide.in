1609527851
3 3
12 libp3collide 4 dlaq 12 panda3d.core 
254
267 20 get_collision_origin 0 6 521 36 CollisionSolid::get_collision_origin 0 1 1 0
69
virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0;

268 12 set_tangible 0 4 521 28 CollisionSolid::set_tangible 0 1 2 295
/**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */
56
inline void CollisionSolid::set_tangible(bool tangible);

269 11 is_tangible 0 4 521 27 CollisionSolid::is_tangible 0 1 3 266
/**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */
52
inline bool CollisionSolid::is_tangible(void) const;

270 20 set_effective_normal 0 4 521 36 CollisionSolid::set_effective_normal 0 1 4 388
/**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */
83
inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal);

271 22 clear_effective_normal 0 4 521 38 CollisionSolid::clear_effective_normal 0 1 5 71
/**
 * Removes the normal previously set by set_effective_normal().
 */
57
inline void CollisionSolid::clear_effective_normal(void);

272 20 has_effective_normal 0 4 521 36 CollisionSolid::has_effective_normal 0 1 6 98
/**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */
61
inline bool CollisionSolid::has_effective_normal(void) const;

273 20 get_effective_normal 0 4 521 36 CollisionSolid::get_effective_normal 0 1 7 145
/**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */
72
inline LVector3 const &CollisionSolid::get_effective_normal(void) const;

274 28 set_respect_effective_normal 0 4 521 44 CollisionSolid::set_respect_effective_normal 0 1 8 296
/**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */
88
inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal);

275 28 get_respect_effective_normal 0 4 521 44 CollisionSolid::get_respect_effective_normal 0 1 9 46
/**
 * See set_respect_effective_normal().
 */
69
inline bool CollisionSolid::get_respect_effective_normal(void) const;

276 10 get_bounds 0 4 521 26 CollisionSolid::get_bounds 0 1 10 47
/**
 * Returns the solid's bounding volume.
 */
72
ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const;

277 10 set_bounds 0 4 521 26 CollisionSolid::set_bounds 0 1 11 47
/**
 * Returns the solid's bounding volume.
 */
71
void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume);

278 6 output 0 6 521 22 CollisionSolid::output 0 1 12 10
/**
 *
 */
61
virtual void CollisionSolid::output(std::ostream &out) const;

279 5 write 0 6 521 21 CollisionSolid::write 0 1 13 10
/**
 *
 */
82
virtual void CollisionSolid::write(std::ostream &out, int indent_level = 0) const;

280 14 get_class_type 0 4 521 30 CollisionSolid::get_class_type 0 1 14 0
55
static TypeHandle CollisionSolid::get_class_type(void);

281 12 CollisionBox 0 4 527 26 CollisionBox::CollisionBox 0 2 15 16 256
/**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */

/**
 * Create the Box by Specifying the Diagonal Points
 */

/**
 * Creates an invalid Box.  Only used when reading from a bam file.
 */

/**
 *
 */
195
inline explicit CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline explicit CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max);

282 14 get_num_points 0 4 527 28 CollisionBox::get_num_points 0 1 17 68
/**
 * Returns 8: the number of vertices of a rectangular solid.
 */
52
inline int CollisionBox::get_num_points(void) const;

283 14 get_point_aabb 0 4 527 28 CollisionBox::get_point_aabb 0 1 18 67
/**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */
57
inline LPoint3 CollisionBox::get_point_aabb(int n) const;

284 9 get_point 0 4 527 23 CollisionBox::get_point 0 1 19 45
/**
 * Returns the nth vertex of the OBB.
 */
52
inline LPoint3 CollisionBox::get_point(int n) const;

285 14 get_num_planes 0 4 527 28 CollisionBox::get_num_planes 0 1 20 65
/**
 * Returns 6: the number of faces of a rectangular solid.
 */
52
inline int CollisionBox::get_num_planes(void) const;

286 9 set_plane 0 4 527 23 CollisionBox::set_plane 0 1 21 57
/**
 * Creates the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::set_plane(int n) const;

287 9 get_plane 0 4 527 23 CollisionBox::get_plane 0 1 22 57
/**
 * Returns the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::get_plane(int n) const;

288 10 set_center 0 4 527 24 CollisionBox::set_center 0 2 23 24 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionBox::set_center(LPoint3 const &center);
inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

289 10 get_center 0 4 527 24 CollisionBox::get_center 0 1 25 10
/**
 *
 */
59
inline LPoint3 const &CollisionBox::get_center(void) const;

290 7 get_min 0 4 527 21 CollisionBox::get_min 0 1 26 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_min(void) const;

291 7 get_max 0 4 527 21 CollisionBox::get_max 0 1 27 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_max(void) const;

292 14 get_dimensions 0 4 527 28 CollisionBox::get_dimensions 0 1 28 10
/**
 *
 */
57
inline LVector3 CollisionBox::get_dimensions(void) const;

293 14 get_class_type 0 4 527 28 CollisionBox::get_class_type 0 1 29 0
53
static TypeHandle CollisionBox::get_class_type(void);

294 13 ~CollisionBox 0 4 527 27 CollisionBox::~CollisionBox 0 0 0
34
CollisionBox::~CollisionBox(void);

295 16 CollisionCapsule 0 4 531 34 CollisionCapsule::CollisionCapsule 0 2 30 31 115
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid capsule.  Only used when reading from a bam file.
 */

/**
 *
 */
276
inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius);
inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius);

296 11 set_point_a 0 4 531 29 CollisionCapsule::set_point_a 0 2 32 33 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_a(LPoint3 const &a);
inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

297 11 get_point_a 0 4 531 29 CollisionCapsule::get_point_a 0 1 34 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_a(void) const;

298 11 set_point_b 0 4 531 29 CollisionCapsule::set_point_b 0 2 35 36 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_b(LPoint3 const &b);
inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

299 11 get_point_b 0 4 531 29 CollisionCapsule::get_point_b 0 1 37 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_b(void) const;

300 10 set_radius 0 4 531 28 CollisionCapsule::set_radius 0 1 38 10
/**
 *
 */
61
inline void CollisionCapsule::set_radius(PN_stdfloat radius);

301 10 get_radius 0 4 531 28 CollisionCapsule::get_radius 0 1 39 10
/**
 *
 */
60
inline PN_stdfloat CollisionCapsule::get_radius(void) const;

302 14 get_class_type 0 4 531 32 CollisionCapsule::get_class_type 0 1 40 0
57
static TypeHandle CollisionCapsule::get_class_type(void);

303 17 ~CollisionCapsule 0 4 531 35 CollisionCapsule::~CollisionCapsule 0 0 0
42
CollisionCapsule::~CollisionCapsule(void);

304 14 get_class_type 0 4 534 32 CollisionHandler::get_class_type 0 1 42 0
57
static TypeHandle CollisionHandler::get_class_type(void);

305 16 CollisionHandler 0 4 534 34 CollisionHandler::CollisionHandler 0 1 41 10
/**
 *
 */
78
inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default;

306 17 ~CollisionHandler 0 4 534 35 CollisionHandler::~CollisionHandler 0 0 0
42
CollisionHandler::~CollisionHandler(void);

307 13 CollisionNode 0 4 536 28 CollisionNode::CollisionNode 0 1 43 22
/**
 *
 */

/**
 *
 */
63
explicit CollisionNode::CollisionNode(std::string const &name);

308 16 set_collide_mask 0 4 536 31 CollisionNode::set_collide_mask 0 1 44 98
/**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */
62
inline void CollisionNode::set_collide_mask(CollideMask mask);

309 21 set_from_collide_mask 0 4 536 36 CollisionNode::set_from_collide_mask 0 1 45 222
/**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */
60
void CollisionNode::set_from_collide_mask(CollideMask mask);

310 21 set_into_collide_mask 0 4 536 36 CollisionNode::set_into_collide_mask 0 1 46 222
/**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */
67
inline void CollisionNode::set_into_collide_mask(CollideMask mask);

311 21 get_from_collide_mask 0 4 536 36 CollisionNode::get_from_collide_mask 0 1 47 233
/**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_from_collide_mask(void) const;

312 21 get_into_collide_mask 0 4 536 36 CollisionNode::get_into_collide_mask 0 1 48 233
/**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_into_collide_mask(void) const;

313 12 clear_solids 0 4 536 27 CollisionNode::clear_solids 0 1 49 44
/**
 * Removes all solids from the node.
 */
46
inline void CollisionNode::clear_solids(void);

314 14 get_num_solids 0 4 536 29 CollisionNode::get_num_solids 0 1 50 10
/**
 *
 */
61
inline std::size_t CollisionNode::get_num_solids(void) const;

315 9 get_solid 0 4 536 24 CollisionNode::get_solid 0 1 51 10
/**
 *
 */
86
inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const;

316 12 modify_solid 0 4 536 27 CollisionNode::modify_solid 0 1 52 10
/**
 *
 */
78
inline PointerTo< CollisionSolid > CollisionNode::modify_solid(std::size_t n);

317 9 set_solid 0 4 536 24 CollisionNode::set_solid 0 1 53 55
/**
 * Replaces the solid with the indicated index.
 */
75
inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid);

318 12 insert_solid 0 4 536 27 CollisionNode::insert_solid 0 1 54 77
/**
 * Inserts the indicated solid to the node at the indicated position.
 */
84
inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid);

319 12 remove_solid 0 4 536 27 CollisionNode::remove_solid 0 1 55 110
/**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */
55
inline void CollisionNode::remove_solid(std::size_t n);

320 9 add_solid 0 4 536 24 CollisionNode::add_solid 0 1 56 121
/**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */
73
inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid);

321 17 get_collider_sort 0 4 536 32 CollisionNode::get_collider_sort 0 1 57 114
/**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */
56
inline int CollisionNode::get_collider_sort(void) const;

322 17 set_collider_sort 0 4 536 32 CollisionNode::set_collider_sort 0 1 58 594
/**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */
55
inline void CollisionNode::set_collider_sort(int sort);

323 24 get_default_collide_mask 0 4 536 39 CollisionNode::get_default_collide_mask 0 1 59 80
/**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */
72
static inline CollideMask CollisionNode::get_default_collide_mask(void);

324 14 get_class_type 0 4 536 29 CollisionNode::get_class_type 0 1 60 0
54
static TypeHandle CollisionNode::get_class_type(void);

325 18 CollisionTraverser 0 4 543 38 CollisionTraverser::CollisionTraverser 0 2 61 62 10
/**
 *
 */
168
explicit CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav");
inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default;

326 19 ~CollisionTraverser 0 4 543 39 CollisionTraverser::~CollisionTraverser 0 0 10
/**
 *
 */
46
CollisionTraverser::~CollisionTraverser(void);

327 26 set_respect_prev_transform 0 4 543 46 CollisionTraverser::set_respect_prev_transform 0 1 63 370
/**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */
70
inline void CollisionTraverser::set_respect_prev_transform(bool flag);

328 26 get_respect_prev_transform 0 4 543 46 CollisionTraverser::get_respect_prev_transform 0 1 64 162
/**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */
71
inline bool CollisionTraverser::get_respect_prev_transform(void) const;

329 12 add_collider 0 4 543 32 CollisionTraverser::add_collider 0 1 65 437
/**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */
91
void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler);

330 15 remove_collider 0 4 543 35 CollisionTraverser::remove_collider 0 1 66 263
/**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */
67
bool CollisionTraverser::remove_collider(NodePath const &collider);

331 12 has_collider 0 4 543 32 CollisionTraverser::has_collider 0 1 67 145
/**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */
70
bool CollisionTraverser::has_collider(NodePath const &collider) const;

332 17 get_num_colliders 0 4 543 37 CollisionTraverser::get_num_colliders 0 1 68 108
/**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */
54
int CollisionTraverser::get_num_colliders(void) const;

333 12 get_collider 0 4 543 32 CollisionTraverser::get_collider 0 1 69 100
/**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */
55
NodePath CollisionTraverser::get_collider(int n) const;

334 11 get_handler 0 4 543 31 CollisionTraverser::get_handler 0 1 70 169
/**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */
82
CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const;

335 15 clear_colliders 0 4 543 35 CollisionTraverser::clear_colliders 0 1 71 90
/**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */
47
void CollisionTraverser::clear_colliders(void);

336 8 traverse 0 4 543 28 CollisionTraverser::traverse 0 1 72 247
/**
 * Perform the traversal. Begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */
56
void CollisionTraverser::traverse(NodePath const &root);

337 12 set_recorder 0 4 543 32 CollisionTraverser::set_recorder 0 1 73 777
/**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */
67
void CollisionTraverser::set_recorder(CollisionRecorder *recorder);

338 12 has_recorder 0 4 543 32 CollisionTraverser::has_recorder 0 1 74 120
/**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */
57
inline bool CollisionTraverser::has_recorder(void) const;

339 12 get_recorder 0 4 543 32 CollisionTraverser::get_recorder 0 1 75 99
/**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */
71
inline CollisionRecorder *CollisionTraverser::get_recorder(void) const;

340 14 clear_recorder 0 4 543 34 CollisionTraverser::clear_recorder 0 1 76 107
/**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */
53
inline void CollisionTraverser::clear_recorder(void);

341 6 output 0 4 547 25 CollisionRecorder::output 0 1 82 10
/**
 *
 */
56
void CollisionRecorder::output(std::ostream &out) const;

342 14 get_class_type 0 4 547 33 CollisionRecorder::get_class_type 0 1 83 0
58
static TypeHandle CollisionRecorder::get_class_type(void);

343 15 show_collisions 0 4 543 35 CollisionTraverser::show_collisions 0 1 77 300
/**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */
69
PandaNode *CollisionTraverser::show_collisions(NodePath const &root);

344 15 hide_collisions 0 4 543 35 CollisionTraverser::hide_collisions 0 1 78 69
/**
 * Undoes the effect of a previous call to show_collisions().
 */
47
void CollisionTraverser::hide_collisions(void);

345 6 output 0 4 543 26 CollisionTraverser::output 0 1 79 10
/**
 *
 */
57
void CollisionTraverser::output(std::ostream &out) const;

346 5 write 0 4 543 25 CollisionTraverser::write 0 1 80 10
/**
 *
 */
74
void CollisionTraverser::write(std::ostream &out, int indent_level) const;

347 14 get_class_type 0 4 543 34 CollisionTraverser::get_class_type 0 1 81 0
59
static TypeHandle CollisionTraverser::get_class_type(void);

348 8 get_from 0 4 549 24 CollisionEntry::get_from 0 1 84 104
/**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */
66
inline CollisionSolid const *CollisionEntry::get_from(void) const;

349 8 has_into 0 4 549 24 CollisionEntry::has_into 0 1 85 288
/**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */
49
inline bool CollisionEntry::has_into(void) const;

350 8 get_into 0 4 549 24 CollisionEntry::get_into 0 1 86 243
/**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */
66
inline CollisionSolid const *CollisionEntry::get_into(void) const;

351 13 get_from_node 0 4 549 29 CollisionEntry::get_from_node 0 1 87 182
/**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */
64
inline CollisionNode *CollisionEntry::get_from_node(void) const;

352 13 get_into_node 0 4 549 29 CollisionEntry::get_into_node 0 1 88 254
/**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */
60
inline PandaNode *CollisionEntry::get_into_node(void) const;

353 18 get_from_node_path 0 4 549 34 CollisionEntry::get_from_node_path 0 1 89 224
/**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */
63
inline NodePath CollisionEntry::get_from_node_path(void) const;

354 18 get_into_node_path 0 4 549 34 CollisionEntry::get_into_node_path 0 1 90 338
/**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */
63
inline NodePath CollisionEntry::get_into_node_path(void) const;

355 5 set_t 0 4 549 21 CollisionEntry::set_t 0 1 91 82
/**
 * Sets a time value for this collision relative to other CollisionEntries
 */
49
inline void CollisionEntry::set_t(PN_stdfloat t);

356 5 get_t 0 4 549 21 CollisionEntry::get_t 0 1 92 83
/**
 * returns time value for this collision relative to other CollisionEntries
 */
53
inline PN_stdfloat CollisionEntry::get_t(void) const;

357 8 collided 0 4 549 24 CollisionEntry::collided 0 1 93 188
/**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */
49
inline bool CollisionEntry::collided(void) const;

358 14 reset_collided 0 4 549 30 CollisionEntry::reset_collided 0 1 94 45
/**
 * prepare for another collision test
 */
49
inline void CollisionEntry::reset_collided(void);

359 26 get_respect_prev_transform 0 4 549 42 CollisionEntry::get_respect_prev_transform 0 1 95 203
/**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */
67
inline bool CollisionEntry::get_respect_prev_transform(void) const;

360 17 set_surface_point 0 4 549 33 CollisionEntry::set_surface_point 0 1 96 178
/**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */
68
inline void CollisionEntry::set_surface_point(LPoint3 const &point);

361 18 set_surface_normal 0 4 549 34 CollisionEntry::set_surface_normal 0 1 97 171
/**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_surface_normal(LVector3 const &normal);

362 18 set_interior_point 0 4 549 34 CollisionEntry::set_interior_point 0 1 98 352
/**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */
69
inline void CollisionEntry::set_interior_point(LPoint3 const &point);

363 17 has_surface_point 0 4 549 33 CollisionEntry::has_surface_point 0 1 99 174
/**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */
58
inline bool CollisionEntry::has_surface_point(void) const;

364 18 has_surface_normal 0 4 549 34 CollisionEntry::has_surface_normal 0 1 100 176
/**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */
59
inline bool CollisionEntry::has_surface_normal(void) const;

365 18 has_interior_point 0 4 549 34 CollisionEntry::has_interior_point 0 1 101 176
/**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */
59
inline bool CollisionEntry::has_interior_point(void) const;

366 15 set_contact_pos 0 4 549 31 CollisionEntry::set_contact_pos 0 1 102 190
/**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */
64
inline void CollisionEntry::set_contact_pos(LPoint3 const &pos);

367 18 set_contact_normal 0 4 549 34 CollisionEntry::set_contact_normal 0 1 103 154
/**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_contact_normal(LVector3 const &normal);

368 15 has_contact_pos 0 4 549 31 CollisionEntry::has_contact_pos 0 1 104 172
/**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */
56
inline bool CollisionEntry::has_contact_pos(void) const;

369 18 has_contact_normal 0 4 549 34 CollisionEntry::has_contact_normal 0 1 105 176
/**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */
59
inline bool CollisionEntry::has_contact_normal(void) const;

370 17 get_surface_point 0 4 549 33 CollisionEntry::get_surface_point 0 1 106 330
/**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
71
LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const;

371 18 get_surface_normal 0 4 549 34 CollisionEntry::get_surface_normal 0 1 107 200
/**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const;

372 18 get_interior_point 0 4 549 34 CollisionEntry::get_interior_point 0 1 108 431
/**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
72
LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const;

373 7 get_all 0 4 549 23 CollisionEntry::get_all 0 1 109 244
/**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
133
bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const;

374 15 get_contact_pos 0 4 549 31 CollisionEntry::get_contact_pos 0 1 110 200
/**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */
69
LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const;

375 18 get_contact_normal 0 4 549 34 CollisionEntry::get_contact_normal 0 1 111 175
/**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const;

376 20 get_all_contact_info 0 4 549 36 CollisionEntry::get_all_contact_info 0 1 112 230
/**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
119
bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const;

377 6 output 0 4 549 22 CollisionEntry::output 0 1 113 10
/**
 *
 */
53
void CollisionEntry::output(std::ostream &out) const;

378 5 write 0 4 549 21 CollisionEntry::write 0 1 114 10
/**
 *
 */
74
void CollisionEntry::write(std::ostream &out, int indent_level = 0) const;

379 14 get_class_type 0 4 549 30 CollisionEntry::get_class_type 0 1 115 0
55
static TypeHandle CollisionEntry::get_class_type(void);

380 15 ~CollisionEntry 0 4 549 31 CollisionEntry::~CollisionEntry 0 0 0
38
CollisionEntry::~CollisionEntry(void);

381 14 CollisionPlane 0 4 555 30 CollisionPlane::CollisionPlane 0 2 116 117 168
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */

/**
 *
 */
126
inline CollisionPlane::CollisionPlane(LPlane const &plane);
inline CollisionPlane::CollisionPlane(CollisionPlane const &copy);

382 10 get_normal 0 4 555 26 CollisionPlane::get_normal 0 1 118 10
/**
 *
 */
55
inline LVector3 CollisionPlane::get_normal(void) const;

383 13 dist_to_plane 0 4 555 29 CollisionPlane::dist_to_plane 0 1 119 10
/**
 *
 */
77
inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const;

384 9 set_plane 0 4 555 25 CollisionPlane::set_plane 0 1 120 10
/**
 *
 */
59
inline void CollisionPlane::set_plane(LPlane const &plane);

385 9 get_plane 0 4 555 25 CollisionPlane::get_plane 0 1 121 10
/**
 *
 */
59
inline LPlane const &CollisionPlane::get_plane(void) const;

386 4 flip 0 4 555 20 CollisionPlane::flip 0 1 122 57
/**
 * Convenience method to flip the plane in-place.
 */
39
inline void CollisionPlane::flip(void);

387 14 get_class_type 0 4 555 30 CollisionPlane::get_class_type 0 1 123 0
55
static TypeHandle CollisionPlane::get_class_type(void);

388 15 ~CollisionPlane 0 4 555 31 CollisionPlane::~CollisionPlane 0 0 0
38
CollisionPlane::~CollisionPlane(void);

389 18 CollisionFloorMesh 0 4 559 38 CollisionFloorMesh::CollisionFloorMesh 0 1 124 156
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */
52
inline CollisionFloorMesh::CollisionFloorMesh(void);

390 10 add_vertex 0 4 559 30 CollisionFloorMesh::add_vertex 0 1 125 47
/**
 * store away a vertex to index against
 */
64
inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert);

391 12 add_triangle 0 4 559 32 CollisionFloorMesh::add_triangle 0 1 126 42
/**
 * store a triangle for processing
 */
101
void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC);

392 16 get_num_vertices 0 4 559 36 CollisionFloorMesh::get_num_vertices 0 1 127 0
69
inline unsigned int CollisionFloorMesh::get_num_vertices(void) const;

393 10 get_vertex 0 4 559 30 CollisionFloorMesh::get_vertex 0 1 128 0
79
inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const;

394 17 get_num_triangles 0 4 559 37 CollisionFloorMesh::get_num_triangles 0 1 129 0
70
inline unsigned int CollisionFloorMesh::get_num_triangles(void) const;

395 12 get_triangle 0 4 559 32 CollisionFloorMesh::get_triangle 0 1 130 0
75
inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const;

396 14 get_class_type 0 4 559 34 CollisionFloorMesh::get_class_type 0 1 131 0
59
static TypeHandle CollisionFloorMesh::get_class_type(void);

397 19 ~CollisionFloorMesh 0 4 559 39 CollisionFloorMesh::~CollisionFloorMesh 0 0 0
46
CollisionFloorMesh::~CollisionFloorMesh(void);

398 16 CollisionPolygon 0 4 561 34 CollisionPolygon::CollisionPolygon 0 2 132 133 127
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid polygon.  Only used when reading from a bam file.
 */

/**
 *
 */
225
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c);
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d);

399 14 get_num_points 0 4 561 32 CollisionPolygon::get_num_points 0 1 134 66
/**
 * Returns the number of vertices of the CollisionPolygon.
 */
64
inline std::size_t CollisionPolygon::get_num_points(void) const;

400 9 get_point 0 4 561 27 CollisionPolygon::get_point 0 1 135 82
/**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */
64
inline LPoint3 CollisionPolygon::get_point(std::size_t n) const;

401 13 verify_points 0 4 561 31 CollisionPolygon::verify_points 0 3 136 137 138 676
/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 *
 * This does not check that the polygon defined is convex; that check is made
 * later, once we have projected the points to 2-d space where the decision is
 * easier.
 */
285
static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d);
static bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c);
static bool CollisionPolygon::verify_points(PyObject *points);

402 8 is_valid 0 4 561 26 CollisionPolygon::is_valid 0 1 139 122
/**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */
44
bool CollisionPolygon::is_valid(void) const;

403 10 is_concave 0 4 561 28 CollisionPolygon::is_concave 0 1 140 106
/**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */
46
bool CollisionPolygon::is_concave(void) const;

404 12 setup_points 0 4 561 30 CollisionPolygon::setup_points 0 1 141 10
/**
 *
 */
54
void CollisionPolygon::setup_points(PyObject *points);

405 14 get_class_type 0 4 561 32 CollisionPolygon::get_class_type 0 1 142 0
57
static TypeHandle CollisionPolygon::get_class_type(void);

406 17 ~CollisionPolygon 0 4 561 35 CollisionPolygon::~CollisionPolygon 0 0 0
42
CollisionPolygon::~CollisionPolygon(void);

407 21 CollisionHandlerEvent 0 4 562 44 CollisionHandlerEvent::CollisionHandlerEvent 0 2 143 144 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
145
CollisionHandlerEvent::CollisionHandlerEvent(void);
inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default;

408 17 clear_in_patterns 0 4 562 40 CollisionHandlerEvent::clear_in_patterns 0 1 145 80
/**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */
59
inline void CollisionHandlerEvent::clear_in_patterns(void);

409 14 add_in_pattern 0 4 562 37 CollisionHandlerEvent::add_in_pattern 0 1 146 1586
/**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
81
inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern);

410 14 set_in_pattern 0 4 562 37 CollisionHandlerEvent::set_in_pattern 0 1 147 189
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */
81
inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern);

411 19 get_num_in_patterns 0 4 562 42 CollisionHandlerEvent::get_num_in_patterns 0 1 148 73
/**
 * Returns the number of in pattern strings that have been added.
 */
66
inline int CollisionHandlerEvent::get_num_in_patterns(void) const;

412 14 get_in_pattern 0 4 562 37 CollisionHandlerEvent::get_in_pattern 0 1 149 145
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */
70
inline std::string CollisionHandlerEvent::get_in_pattern(int n) const;

413 20 clear_again_patterns 0 4 562 43 CollisionHandlerEvent::clear_again_patterns 0 1 150 83
/**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */
62
inline void CollisionHandlerEvent::clear_again_patterns(void);

414 17 add_again_pattern 0 4 562 40 CollisionHandlerEvent::add_again_pattern 0 1 151 649
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
87
inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern);

415 17 set_again_pattern 0 4 562 40 CollisionHandlerEvent::set_again_pattern 0 1 152 192
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */
87
inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern);

416 22 get_num_again_patterns 0 4 562 45 CollisionHandlerEvent::get_num_again_patterns 0 1 153 73
/**
 * Returns the number of in pattern strings that have been added.
 */
69
inline int CollisionHandlerEvent::get_num_again_patterns(void) const;

417 17 get_again_pattern 0 4 562 40 CollisionHandlerEvent::get_again_pattern 0 1 154 148
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */
73
inline std::string CollisionHandlerEvent::get_again_pattern(int n) const;

418 18 clear_out_patterns 0 4 562 41 CollisionHandlerEvent::clear_out_patterns 0 1 155 81
/**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */
60
inline void CollisionHandlerEvent::clear_out_patterns(void);

419 15 add_out_pattern 0 4 562 38 CollisionHandlerEvent::add_out_pattern 0 1 156 518
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
83
inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern);

420 15 set_out_pattern 0 4 562 38 CollisionHandlerEvent::set_out_pattern 0 1 157 190
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */
83
inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern);

421 20 get_num_out_patterns 0 4 562 43 CollisionHandlerEvent::get_num_out_patterns 0 1 158 73
/**
 * Returns the number of in pattern strings that have been added.
 */
67
inline int CollisionHandlerEvent::get_num_out_patterns(void) const;

422 15 get_out_pattern 0 4 562 38 CollisionHandlerEvent::get_out_pattern 0 1 159 146
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */
71
inline std::string CollisionHandlerEvent::get_out_pattern(int n) const;

423 5 clear 0 4 562 28 CollisionHandlerEvent::clear 0 1 160 541
/**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */
40
void CollisionHandlerEvent::clear(void);

424 5 flush 0 4 562 28 CollisionHandlerEvent::flush 0 1 161 58
/**
 * Same as clear() except "out" events are thrown.
 */
40
void CollisionHandlerEvent::flush(void);

425 14 get_class_type 0 4 562 37 CollisionHandlerEvent::get_class_type 0 1 162 0
62
static TypeHandle CollisionHandlerEvent::get_class_type(void);

426 22 ~CollisionHandlerEvent 0 4 562 45 CollisionHandlerEvent::~CollisionHandlerEvent 0 0 0
52
CollisionHandlerEvent::~CollisionHandlerEvent(void);

427 12 add_collider 0 4 565 38 CollisionHandlerPhysical::add_collider 0 2 163 164 556
/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */

/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */
222
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target);
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface);

428 15 remove_collider 0 4 565 41 CollisionHandlerPhysical::remove_collider 0 1 165 92
/**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */
73
bool CollisionHandlerPhysical::remove_collider(NodePath const &collider);

429 12 has_collider 0 4 565 38 CollisionHandlerPhysical::has_collider 0 1 166 94
/**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */
76
bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const;

430 15 clear_colliders 0 4 565 41 CollisionHandlerPhysical::clear_colliders 0 1 167 77
/**
 * Completely empties the list of colliders this handler knows about.
 */
53
void CollisionHandlerPhysical::clear_colliders(void);

431 10 set_center 0 4 565 36 CollisionHandlerPhysical::set_center 0 1 168 269
/**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */
73
inline void CollisionHandlerPhysical::set_center(NodePath const &center);

432 12 clear_center 0 4 565 38 CollisionHandlerPhysical::clear_center 0 1 169 64
/**
 * Clears the center NodePath specified with set_center.
 */
57
inline void CollisionHandlerPhysical::clear_center(void);

433 10 get_center 0 4 565 36 CollisionHandlerPhysical::get_center 0 1 170 114
/**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */
72
inline NodePath const &CollisionHandlerPhysical::get_center(void) const;

434 10 has_center 0 4 565 36 CollisionHandlerPhysical::has_center 0 1 171 95
/**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */
61
inline bool CollisionHandlerPhysical::has_center(void) const;

435 11 has_contact 0 4 565 37 CollisionHandlerPhysical::has_contact 0 1 172 255
/**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */
62
inline bool CollisionHandlerPhysical::has_contact(void) const;

436 14 get_class_type 0 4 565 40 CollisionHandlerPhysical::get_class_type 0 1 173 0
65
static TypeHandle CollisionHandlerPhysical::get_class_type(void);

437 21 CollisionHandlerFloor 0 4 567 44 CollisionHandlerFloor::CollisionHandlerFloor 0 1 174 10
/**
 *
 */
51
CollisionHandlerFloor::CollisionHandlerFloor(void);

438 10 set_offset 0 4 567 33 CollisionHandlerFloor::set_offset 0 1 175 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
66
inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset);

439 10 get_offset 0 4 567 33 CollisionHandlerFloor::get_offset 0 1 176 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
65
inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const;

440 9 set_reach 0 4 567 32 CollisionHandlerFloor::set_reach 0 1 177 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
64
inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach);

441 9 get_reach 0 4 567 32 CollisionHandlerFloor::get_reach 0 1 178 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
64
inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const;

442 16 set_max_velocity 0 4 567 39 CollisionHandlerFloor::set_max_velocity 0 1 179 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
73
inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel);

443 16 get_max_velocity 0 4 567 39 CollisionHandlerFloor::get_max_velocity 0 1 180 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
71
inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const;

444 14 get_class_type 0 4 567 37 CollisionHandlerFloor::get_class_type 0 1 181 0
62
static TypeHandle CollisionHandlerFloor::get_class_type(void);

445 22 CollisionHandlerPusher 0 4 568 46 CollisionHandlerPusher::CollisionHandlerPusher 0 1 182 10
/**
 *
 */
53
CollisionHandlerPusher::CollisionHandlerPusher(void);

446 14 set_horizontal 0 4 568 38 CollisionHandlerPusher::set_horizontal 0 1 183 10
/**
 *
 */
62
inline void CollisionHandlerPusher::set_horizontal(bool flag);

447 14 get_horizontal 0 4 568 38 CollisionHandlerPusher::get_horizontal 0 1 184 10
/**
 *
 */
63
inline bool CollisionHandlerPusher::get_horizontal(void) const;

448 14 get_class_type 0 4 568 38 CollisionHandlerPusher::get_class_type 0 1 185 0
63
static TypeHandle CollisionHandlerPusher::get_class_type(void);

449 27 CollisionHandlerFluidPusher 0 4 569 56 CollisionHandlerFluidPusher::CollisionHandlerFluidPusher 0 1 186 10
/**
 *
 */
63
CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void);

450 14 get_class_type 0 4 569 43 CollisionHandlerFluidPusher::get_class_type 0 1 187 0
68
static TypeHandle CollisionHandlerFluidPusher::get_class_type(void);

451 28 ~CollisionHandlerFluidPusher 0 4 569 57 CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher 0 0 0
64
CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher(void);

452 23 CollisionHandlerGravity 0 4 570 48 CollisionHandlerGravity::CollisionHandlerGravity 0 1 188 10
/**
 *
 */
55
CollisionHandlerGravity::CollisionHandlerGravity(void);

453 10 set_offset 0 4 570 35 CollisionHandlerGravity::set_offset 0 1 189 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
68
inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset);

454 10 get_offset 0 4 570 35 CollisionHandlerGravity::get_offset 0 1 190 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
67
inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const;

455 9 set_reach 0 4 570 34 CollisionHandlerGravity::set_reach 0 1 191 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
66
inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach);

456 9 get_reach 0 4 570 34 CollisionHandlerGravity::get_reach 0 1 192 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
66
inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const;

457 19 get_airborne_height 0 4 570 44 CollisionHandlerGravity::get_airborne_height 0 1 193 238
/**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const;

458 12 is_on_ground 0 4 570 37 CollisionHandlerGravity::is_on_ground 0 1 194 33
/**
 * Is the object at rest?
 */
62
inline bool CollisionHandlerGravity::is_on_ground(void) const;

459 19 get_impact_velocity 0 4 570 44 CollisionHandlerGravity::get_impact_velocity 0 1 195 282
/**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const;

460 18 get_contact_normal 0 4 570 43 CollisionHandlerGravity::get_contact_normal 0 1 196 10
/**
 *
 */
79
inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const;

461 12 add_velocity 0 4 570 37 CollisionHandlerGravity::add_velocity 0 1 197 184
/**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */
72
inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity);

462 12 set_velocity 0 4 570 37 CollisionHandlerGravity::set_velocity 0 1 198 46
/**
 * Sets the current vertical velocity.
 */
72
inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity);

463 12 get_velocity 0 4 570 37 CollisionHandlerGravity::get_velocity 0 1 199 354
/**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */
69
inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const;

464 11 set_gravity 0 4 570 36 CollisionHandlerGravity::set_gravity 0 1 200 56
/**
 * Sets the linear gravity force (always plumb).
 */
70
inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity);

465 11 get_gravity 0 4 570 36 CollisionHandlerGravity::get_gravity 0 1 201 56
/**
 * Gets the linear gravity force (always plumb).
 */
68
inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const;

466 16 set_max_velocity 0 4 570 41 CollisionHandlerGravity::set_max_velocity 0 1 202 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
75
inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel);

467 16 get_max_velocity 0 4 570 41 CollisionHandlerGravity::get_max_velocity 0 1 203 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
73
inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const;

468 15 set_legacy_mode 0 4 570 40 CollisionHandlerGravity::set_legacy_mode 0 1 204 229
/**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */
71
inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode);

469 15 get_legacy_mode 0 4 570 40 CollisionHandlerGravity::get_legacy_mode 0 1 205 49
/**
 * returns true if legacy mode is enabled
 */
65
inline bool CollisionHandlerGravity::get_legacy_mode(void) const;

470 14 get_class_type 0 4 570 39 CollisionHandlerGravity::get_class_type 0 1 206 0
64
static TypeHandle CollisionHandlerGravity::get_class_type(void);

471 28 CollisionHandlerHighestEvent 0 4 572 58 CollisionHandlerHighestEvent::CollisionHandlerHighestEvent 0 2 207 208 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
180
CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void);
inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default;

472 14 get_class_type 0 4 572 44 CollisionHandlerHighestEvent::get_class_type 0 1 209 0
69
static TypeHandle CollisionHandlerHighestEvent::get_class_type(void);

473 29 ~CollisionHandlerHighestEvent 0 4 572 59 CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent 0 0 0
66
CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent(void);

474 21 CollisionHandlerQueue 0 4 573 44 CollisionHandlerQueue::CollisionHandlerQueue 0 2 210 211 10
/**
 *
 */
145
CollisionHandlerQueue::CollisionHandlerQueue(void);
inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default;

475 12 sort_entries 0 4 573 35 CollisionHandlerQueue::sort_entries 0 1 212 257
/**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */
47
void CollisionHandlerQueue::sort_entries(void);

476 13 clear_entries 0 4 573 36 CollisionHandlerQueue::clear_entries 0 1 213 50
/**
 * Removes all the entries from the queue.
 */
48
void CollisionHandlerQueue::clear_entries(void);

477 15 get_num_entries 0 4 573 38 CollisionHandlerQueue::get_num_entries 0 1 214 69
/**
 * Returns the number of CollisionEntries detected last pass.
 */
55
int CollisionHandlerQueue::get_num_entries(void) const;

478 9 get_entry 0 4 573 32 CollisionHandlerQueue::get_entry 0 1 215 61
/**
 * Returns the nth CollisionEntry detected last pass.
 */
62
CollisionEntry *CollisionHandlerQueue::get_entry(int n) const;

479 6 output 0 4 573 29 CollisionHandlerQueue::output 0 1 216 10
/**
 *
 */
60
void CollisionHandlerQueue::output(std::ostream &out) const;

480 5 write 0 4 573 28 CollisionHandlerQueue::write 0 1 217 10
/**
 *
 */
81
void CollisionHandlerQueue::write(std::ostream &out, int indent_level = 0) const;

481 14 get_class_type 0 4 573 37 CollisionHandlerQueue::get_class_type 0 1 218 0
62
static TypeHandle CollisionHandlerQueue::get_class_type(void);

482 22 ~CollisionHandlerQueue 0 4 573 45 CollisionHandlerQueue::~CollisionHandlerQueue 0 0 0
52
CollisionHandlerQueue::~CollisionHandlerQueue(void);

483 15 CollisionSphere 0 4 575 32 CollisionSphere::CollisionSphere 0 2 219 220 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
210
inline explicit CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

484 10 set_center 0 4 575 27 CollisionSphere::set_center 0 2 221 222 22
/**
 *
 */

/**
 *
 */
149
inline void CollisionSphere::set_center(LPoint3 const &center);
inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

485 10 get_center 0 4 575 27 CollisionSphere::get_center 0 1 223 10
/**
 *
 */
62
inline LPoint3 const &CollisionSphere::get_center(void) const;

486 10 set_radius 0 4 575 27 CollisionSphere::set_radius 0 1 224 10
/**
 *
 */
60
inline void CollisionSphere::set_radius(PN_stdfloat radius);

487 10 get_radius 0 4 575 27 CollisionSphere::get_radius 0 1 225 10
/**
 *
 */
59
inline PN_stdfloat CollisionSphere::get_radius(void) const;

488 14 get_class_type 0 4 575 31 CollisionSphere::get_class_type 0 1 226 0
56
static TypeHandle CollisionSphere::get_class_type(void);

489 16 ~CollisionSphere 0 4 575 33 CollisionSphere::~CollisionSphere 0 0 0
40
CollisionSphere::~CollisionSphere(void);

490 18 CollisionInvSphere 0 4 576 38 CollisionInvSphere::CollisionInvSphere 0 2 227 228 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
222
inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

491 14 get_class_type 0 4 576 34 CollisionInvSphere::get_class_type 0 1 229 0
59
static TypeHandle CollisionInvSphere::get_class_type(void);

492 19 ~CollisionInvSphere 0 4 576 39 CollisionInvSphere::~CollisionInvSphere 0 0 0
46
CollisionInvSphere::~CollisionInvSphere(void);

493 12 CollisionRay 0 4 577 26 CollisionRay::CollisionRay 0 3 230 231 232 219
/**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
274
inline CollisionRay::CollisionRay(void);
inline explicit CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

494 10 set_origin 0 4 577 24 CollisionRay::set_origin 0 2 233 234 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionRay::set_origin(LPoint3 const &origin);
inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

495 10 get_origin 0 4 577 24 CollisionRay::get_origin 0 1 235 10
/**
 *
 */
59
inline LPoint3 const &CollisionRay::get_origin(void) const;

496 13 set_direction 0 4 577 27 CollisionRay::set_direction 0 2 236 237 22
/**
 *
 */

/**
 *
 */
153
inline void CollisionRay::set_direction(LVector3 const &direction);
inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

497 13 get_direction 0 4 577 27 CollisionRay::get_direction 0 1 238 10
/**
 *
 */
63
inline LVector3 const &CollisionRay::get_direction(void) const;

498 13 set_from_lens 0 4 577 27 CollisionRay::set_from_lens 0 2 239 240 591
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
164
bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

499 14 get_class_type 0 4 577 28 CollisionRay::get_class_type 0 1 241 0
53
static TypeHandle CollisionRay::get_class_type(void);

500 13 ~CollisionRay 0 4 577 27 CollisionRay::~CollisionRay 0 0 0
34
CollisionRay::~CollisionRay(void);

501 13 CollisionLine 0 4 578 28 CollisionLine::CollisionLine 0 3 242 243 244 221
/**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
280
inline CollisionLine::CollisionLine(void);
inline explicit CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

502 14 get_class_type 0 4 578 29 CollisionLine::get_class_type 0 1 245 0
54
static TypeHandle CollisionLine::get_class_type(void);

503 14 ~CollisionLine 0 4 578 29 CollisionLine::~CollisionLine 0 0 0
36
CollisionLine::~CollisionLine(void);

504 17 CollisionParabola 0 4 579 36 CollisionParabola::CollisionParabola 0 2 246 247 163
/**
 * Creates an invalid parabola.
 */

/**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */

/**
 *
 */
163
inline CollisionParabola::CollisionParabola(void);
inline explicit CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2);

505 12 set_parabola 0 4 579 31 CollisionParabola::set_parabola 0 1 248 57
/**
 * Replaces the parabola specified by this solid.
 */
71
inline void CollisionParabola::set_parabola(LParabola const &parabola);

506 12 get_parabola 0 4 579 31 CollisionParabola::get_parabola 0 1 249 56
/**
 * Returns the parabola specified by this solid.
 */
68
inline LParabola const &CollisionParabola::get_parabola(void) const;

507 6 set_t1 0 4 579 25 CollisionParabola::set_t1 0 1 250 54
/**
 * Changes the starting point on the parabola.
 */
54
inline void CollisionParabola::set_t1(PN_stdfloat t1);

508 6 get_t1 0 4 579 25 CollisionParabola::get_t1 0 1 251 54
/**
 * Returns the starting point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t1(void) const;

509 6 set_t2 0 4 579 25 CollisionParabola::set_t2 0 1 252 52
/**
 * Changes the ending point on the parabola.
 */
54
inline void CollisionParabola::set_t2(PN_stdfloat t2);

510 6 get_t2 0 4 579 25 CollisionParabola::get_t2 0 1 253 52
/**
 * Returns the ending point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t2(void) const;

511 14 get_class_type 0 4 579 33 CollisionParabola::get_class_type 0 1 254 0
58
static TypeHandle CollisionParabola::get_class_type(void);

512 18 ~CollisionParabola 0 4 579 37 CollisionParabola::~CollisionParabola 0 0 0
44
CollisionParabola::~CollisionParabola(void);

513 16 CollisionSegment 0 4 583 34 CollisionSegment::CollisionSegment 0 3 255 256 257 227
/**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
285
inline CollisionSegment::CollisionSegment(void);
inline explicit CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db);
inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz);

514 11 set_point_a 0 4 583 29 CollisionSegment::set_point_a 0 2 258 259 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_a(LPoint3 const &a);
inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

515 11 get_point_a 0 4 583 29 CollisionSegment::get_point_a 0 1 260 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_a(void) const;

516 11 set_point_b 0 4 583 29 CollisionSegment::set_point_b 0 2 261 262 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_b(LPoint3 const &b);
inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

517 11 get_point_b 0 4 583 29 CollisionSegment::get_point_b 0 1 263 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_b(void) const;

518 13 set_from_lens 0 4 583 31 CollisionSegment::set_from_lens 0 2 264 265 609
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
172
bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

519 14 get_class_type 0 4 583 32 CollisionSegment::get_class_type 0 1 266 0
57
static TypeHandle CollisionSegment::get_class_type(void);

520 17 ~CollisionSegment 0 4 583 35 CollisionSegment::~CollisionSegment 0 0 0
42
CollisionSegment::~CollisionSegment(void);

266
1 0 0 7 3 585 0 0 0 1 4 this 3 551  
2 0 0 4 7 587 0 0 295 /**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */ 2 4 this 3 586  8 tangible 1 525  
3 0 0 6 8 525 0 0 266 /**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */ 1 4 this 3 551  
4 0 0 4 11 587 0 0 388 /**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */ 2 4 this 3 586  16 effective_normal 1 588  
5 0 0 4 12 587 0 0 71 /**
 * Removes the normal previously set by set_effective_normal().
 */ 1 4 this 3 586  
6 0 0 6 13 525 0 0 98 /**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */ 1 4 this 3 551  
7 0 0 6 14 588 0 0 145 /**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */ 1 4 this 3 551  
8 0 0 4 15 587 0 0 296 /**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */ 2 4 this 3 586  24 respect_effective_normal 1 525  
9 0 0 6 16 525 0 0 46 /**
 * See set_respect_effective_normal().
 */ 1 4 this 3 551  
10 0 0 7 18 591 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 1 4 this 3 551  
11 0 0 4 19 587 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 2 4 this 3 586  15 bounding_volume 1 591  
12 0 0 4 22 587 0 0 10 /**
 *
 */ 2 4 this 3 551  3 out 1 592  
13 0 0 4 23 587 0 0 10 /**
 *
 */ 3 4 this 3 551  3 out 1 592  12 indent_level 1 542  
14 0 0 7 24 595 0 0 0 0 
15 0 0 7 26 597 294 0 59 /**
 * Create the Box by Specifying the Diagonal Points
 */ 2 3 min 1 596  3 max 1 596  
16 0 0 7 26 597 294 0 106 /**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */ 4 6 center 1 596  1 x 1 532  1 y 1 532  1 z 1 532  
17 0 0 6 27 542 0 0 68 /**
 * Returns 8: the number of vertices of a rectangular solid.
 */ 1 4 this 3 598  
18 0 0 7 28 585 0 0 67 /**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */ 2 4 this 3 598  1 n 1 542  
19 0 0 7 29 585 0 0 45 /**
 * Returns the nth vertex of the OBB.
 */ 2 4 this 3 598  1 n 1 542  
20 0 0 6 30 542 0 0 65 /**
 * Returns 6: the number of faces of a rectangular solid.
 */ 1 4 this 3 598  
21 0 0 7 31 600 0 0 57 /**
 * Creates the nth face of the rectangular solid.
 */ 2 4 this 3 598  1 n 1 542  
22 0 0 7 32 600 0 0 57 /**
 * Returns the nth face of the rectangular solid.
 */ 2 4 this 3 598  1 n 1 542  
23 0 0 4 33 587 0 0 10 /**
 *
 */ 2 4 this 3 597  6 center 1 596  
24 0 0 4 33 587 0 0 10 /**
 *
 */ 4 4 this 3 597  1 x 1 532  1 y 1 532  1 z 1 532  
25 0 0 6 34 596 0 0 10 /**
 *
 */ 1 4 this 3 598  
26 0 0 6 35 596 0 0 10 /**
 *
 */ 1 4 this 3 598  
27 0 0 6 36 596 0 0 10 /**
 *
 */ 1 4 this 3 598  
28 0 0 7 37 601 0 0 10 /**
 *
 */ 1 4 this 3 598  
29 0 0 7 45 595 0 0 0 0 
30 0 0 7 48 602 303 0 10 /**
 *
 */ 3 1 a 1 596  2 db 1 596  6 radius 1 532  
31 0 0 7 48 602 303 0 10 /**
 *
 */ 7 2 ax 1 532  2 ay 1 532  2 az 1 532  2 bx 1 532  2 by 1 532  2 bz 1 532  6 radius 1 532  
32 0 0 4 49 587 0 0 10 /**
 *
 */ 2 4 this 3 602  1 a 1 596  
33 0 0 4 49 587 0 0 10 /**
 *
 */ 4 4 this 3 602  1 x 1 532  1 y 1 532  1 z 1 532  
34 0 0 6 50 596 0 0 10 /**
 *
 */ 1 4 this 3 603  
35 0 0 4 51 587 0 0 10 /**
 *
 */ 2 4 this 3 602  1 b 1 596  
36 0 0 4 51 587 0 0 10 /**
 *
 */ 4 4 this 3 602  1 x 1 532  1 y 1 532  1 z 1 532  
37 0 0 6 52 596 0 0 10 /**
 *
 */ 1 4 this 3 603  
38 0 0 4 53 587 0 0 10 /**
 *
 */ 2 4 this 3 602  6 radius 1 532  
39 0 0 6 54 532 0 0 10 /**
 *
 */ 1 4 this 3 603  
40 0 0 7 60 595 0 0 0 0 
41 0 0 7 65 607 306 0 0 1 6 param0 0 605  
42 0 0 7 64 595 0 0 0 0 
43 0 0 7 69 553 0 0 10 /**
 *
 */ 1 4 name 1 608  
44 0 0 4 70 587 0 0 98 /**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */ 2 4 this 3 553  4 mask 1 609  
45 0 0 4 71 587 0 0 222 /**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */ 2 4 this 3 553  4 mask 1 609  
46 0 0 4 72 587 0 0 222 /**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */ 2 4 this 3 553  4 mask 1 609  
47 0 0 7 73 609 0 0 233 /**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */ 1 4 this 3 610  
48 0 0 7 74 609 0 0 233 /**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */ 1 4 this 3 610  
49 0 0 4 80 587 0 0 44 /**
 * Removes all solids from the node.
 */ 1 4 this 3 553  
50 0 0 6 81 612 0 0 10 /**
 *
 */ 1 4 this 3 610  
51 0 0 7 82 551 0 0 10 /**
 *
 */ 2 4 this 3 610  1 n 1 612  
52 0 0 7 84 586 0 0 10 /**
 *
 */ 2 4 this 3 553  1 n 1 612  
53 0 0 4 85 587 0 0 55 /**
 * Replaces the solid with the indicated index.
 */ 3 4 this 3 553  1 n 1 612  5 solid 1 586  
54 0 0 4 86 587 0 0 77 /**
 * Inserts the indicated solid to the node at the indicated position.
 */ 3 4 this 3 553  1 n 1 612  5 solid 1 551  
55 0 0 4 87 587 0 0 110 /**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */ 2 4 this 3 553  1 n 1 612  
56 0 0 6 88 612 0 0 121 /**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */ 2 4 this 3 553  5 solid 1 551  
57 0 0 6 91 542 0 0 114 /**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */ 1 4 this 3 610  
58 0 0 4 92 587 0 0 594 /**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */ 2 4 this 3 553  4 sort 1 542  
59 0 0 7 95 609 0 0 80 /**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */ 0 
60 0 0 7 97 595 0 0 0 0 
61 0 0 7 100 616 326 0 0 1 6 param0 0 614  
62 0 0 7 100 616 326 0 10 /**
 *
 */ 1 4 name 1 608  
63 0 0 4 102 587 0 0 370 /**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */ 2 4 this 3 616  4 flag 1 525  
64 0 0 6 103 525 0 0 162 /**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */ 1 4 this 3 614  
65 0 0 4 105 587 0 0 437 /**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */ 3 4 this 3 616  8 collider 1 617  7 handler 1 607  
66 0 0 6 106 525 0 0 263 /**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */ 2 4 this 3 616  8 collider 1 617  
67 0 0 6 107 525 0 0 145 /**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */ 2 4 this 3 614  8 collider 1 617  
68 0 0 6 108 542 0 0 108 /**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */ 1 4 this 3 614  
69 0 0 7 109 618 0 0 100 /**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */ 2 4 this 3 614  1 n 1 542  
70 0 0 7 111 607 306 0 169 /**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */ 2 4 this 3 614  8 collider 1 617  
71 0 0 4 112 587 0 0 90 /**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */ 1 4 this 3 616  
72 0 0 4 115 587 0 0 247 /**
 * Perform the traversal. Begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */ 2 4 this 3 616  4 root 1 617  
73 0 0 4 116 587 0 0 777 /**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */ 2 4 this 3 616  8 recorder 1 546  
74 0 0 6 117 525 0 0 120 /**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */ 1 4 this 3 614  
75 0 0 6 118 546 0 0 99 /**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */ 1 4 this 3 614  
76 0 0 4 119 587 0 0 107 /**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */ 1 4 this 3 616  
77 0 0 7 126 554 0 0 300 /**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */ 2 4 this 3 616  4 root 1 617  
78 0 0 4 127 587 0 0 69 /**
 * Undoes the effect of a previous call to show_collisions().
 */ 1 4 this 3 616  
79 0 0 4 128 587 0 0 10 /**
 *
 */ 2 4 this 3 614  3 out 1 592  
80 0 0 4 129 587 0 0 10 /**
 *
 */ 3 4 this 3 614  3 out 1 592  12 indent_level 1 542  
81 0 0 7 130 595 0 0 0 0 
82 0 0 4 124 587 0 0 10 /**
 *
 */ 2 4 this 3 619  3 out 1 592  
83 0 0 7 125 595 0 0 0 0 
84 0 0 7 133 551 0 0 104 /**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */ 1 4 this 3 621  
85 0 0 6 134 525 0 0 288 /**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */ 1 4 this 3 621  
86 0 0 7 135 551 0 0 243 /**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */ 1 4 this 3 621  
87 0 0 7 136 553 0 0 182 /**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */ 1 4 this 3 621  
88 0 0 7 137 554 0 0 254 /**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */ 1 4 this 3 621  
89 0 0 7 138 618 0 0 224 /**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */ 1 4 this 3 621  
90 0 0 7 139 618 0 0 338 /**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */ 1 4 this 3 621  
91 0 0 4 140 587 0 0 82 /**
 * Sets a time value for this collision relative to other CollisionEntries
 */ 2 4 this 3 574  1 t 1 532  
92 0 0 6 141 532 0 0 83 /**
 * returns time value for this collision relative to other CollisionEntries
 */ 1 4 this 3 621  
93 0 0 6 142 525 0 0 188 /**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */ 1 4 this 3 621  
94 0 0 4 143 587 0 0 45 /**
 * prepare for another collision test
 */ 1 4 this 3 574  
95 0 0 6 144 525 0 0 203 /**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */ 1 4 this 3 621  
96 0 0 4 145 587 0 0 178 /**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 574  5 point 1 596  
97 0 0 4 146 587 0 0 171 /**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 574  6 normal 1 588  
98 0 0 4 147 587 0 0 352 /**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 574  5 point 1 596  
99 0 0 6 148 525 0 0 174 /**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */ 1 4 this 3 621  
100 0 0 6 149 525 0 0 176 /**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */ 1 4 this 3 621  
101 0 0 6 150 525 0 0 176 /**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */ 1 4 this 3 621  
102 0 0 4 151 587 0 0 190 /**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 574  3 pos 1 596  
103 0 0 4 152 587 0 0 154 /**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 574  6 normal 1 588  
104 0 0 6 153 525 0 0 172 /**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */ 1 4 this 3 621  
105 0 0 6 154 525 0 0 176 /**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */ 1 4 this 3 621  
106 0 0 7 155 585 0 0 330 /**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 621  5 space 1 617  
107 0 0 7 156 601 0 0 200 /**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 621  5 space 1 617  
108 0 0 7 157 585 0 0 431 /**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 621  5 space 1 617  
109 0 0 6 158 525 0 0 244 /**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 5 4 this 3 621  5 space 1 617  13 surface_point 1 585  14 surface_normal 1 601  14 interior_point 1 585  
110 0 0 7 159 585 0 0 200 /**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 621  5 space 1 617  
111 0 0 7 160 601 0 0 175 /**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 621  5 space 1 617  
112 0 0 6 161 525 0 0 230 /**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 4 4 this 3 621  5 space 1 617  11 contact_pos 1 585  14 contact_normal 1 601  
113 0 0 4 162 587 0 0 10 /**
 *
 */ 2 4 this 3 621  3 out 1 592  
114 0 0 4 163 587 0 0 10 /**
 *
 */ 3 4 this 3 621  3 out 1 592  12 indent_level 1 542  
115 0 0 7 176 595 0 0 0 0 
116 0 0 7 179 625 388 0 10 /**
 *
 */ 1 4 copy 1 623  
117 0 0 7 179 625 388 0 10 /**
 *
 */ 1 5 plane 1 626  
118 0 0 7 180 601 0 0 10 /**
 *
 */ 1 4 this 3 623  
119 0 0 6 181 532 0 0 10 /**
 *
 */ 2 4 this 3 623  5 point 1 596  
120 0 0 4 182 587 0 0 10 /**
 *
 */ 2 4 this 3 625  5 plane 1 626  
121 0 0 6 183 626 0 0 10 /**
 *
 */ 1 4 this 3 623  
122 0 0 4 184 587 0 0 57 /**
 * Convenience method to flip the plane in-place.
 */ 1 4 this 3 625  
123 0 0 7 190 595 0 0 0 0 
124 0 0 7 193 627 397 0 144 /**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */ 0 
125 0 0 4 194 587 0 0 47 /**
 * store away a vertex to index against
 */ 2 4 this 3 627  4 vert 1 596  
126 0 0 4 195 587 0 0 42 /**
 * store a triangle for processing
 */ 4 4 this 3 627  6 pointA 1 628  6 pointB 1 628  6 pointC 1 628  
127 0 0 6 196 628 0 0 0 1 4 this 3 629  
128 0 0 6 197 596 0 0 0 2 4 this 3 629  5 index 1 628  
129 0 0 6 199 628 0 0 0 1 4 this 3 629  
130 0 0 7 200 631 0 0 0 2 4 this 3 629  5 index 1 628  
131 0 0 7 205 595 0 0 0 0 
132 0 0 7 208 636 406 0 10 /**
 *
 */ 3 1 a 1 632  1 b 1 632  1 c 1 632  
133 0 0 7 208 636 406 0 10 /**
 *
 */ 4 1 a 1 632  1 b 1 632  1 c 1 632  1 d 1 632  
134 0 0 6 209 612 0 0 66 /**
 * Returns the number of vertices of the CollisionPolygon.
 */ 1 4 this 3 637  
135 0 0 7 210 585 0 0 82 /**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */ 2 4 this 3 637  1 n 1 612  
136 0 0 6 212 525 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 3 1 a 1 596  1 b 1 596  1 c 1 596  
137 0 0 6 212 525 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 4 1 a 1 596  1 b 1 596  1 c 1 596  1 d 1 596  
138 0 0 6 212 525 0 0 0 1 6 points 1 639  
139 0 0 6 213 525 0 0 122 /**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */ 1 4 this 3 637  
140 0 0 6 214 525 0 0 106 /**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */ 1 4 this 3 637  
141 0 0 4 215 587 0 0 0 2 4 this 3 636  6 points 1 639  
142 0 0 7 219 595 0 0 0 0 
143 0 0 7 222 642 426 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
144 0 0 7 222 642 426 0 0 1 6 param0 0 643  
145 0 0 4 223 587 0 0 80 /**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */ 1 4 this 3 642  
146 0 0 4 224 587 0 0 1586 /**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 642  10 in_pattern 1 608  
147 0 0 4 225 587 0 0 189 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */ 2 4 this 3 642  10 in_pattern 1 608  
148 0 0 6 226 542 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 643  
149 0 0 6 227 608 0 0 145 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */ 2 4 this 3 643  1 n 1 542  
150 0 0 4 229 587 0 0 83 /**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */ 1 4 this 3 642  
151 0 0 4 230 587 0 0 649 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 642  13 again_pattern 1 608  
152 0 0 4 231 587 0 0 192 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */ 2 4 this 3 642  13 again_pattern 1 608  
153 0 0 6 232 542 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 643  
154 0 0 6 233 608 0 0 148 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */ 2 4 this 3 643  1 n 1 542  
155 0 0 4 235 587 0 0 81 /**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */ 1 4 this 3 642  
156 0 0 4 236 587 0 0 518 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 642  11 out_pattern 1 608  
157 0 0 4 237 587 0 0 190 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */ 2 4 this 3 642  11 out_pattern 1 608  
158 0 0 6 238 542 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 643  
159 0 0 6 239 608 0 0 146 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */ 2 4 this 3 643  1 n 1 542  
160 0 0 4 246 587 0 0 541 /**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */ 1 4 this 3 642  
161 0 0 4 247 587 0 0 58 /**
 * Same as clear() except "out" events are thrown.
 */ 1 4 this 3 642  
162 0 0 7 248 595 0 0 0 0 
163 0 0 4 251 587 0 0 180 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */ 3 4 this 3 645  8 collider 1 617  6 target 1 617  
164 0 0 4 251 587 0 0 374 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */ 4 4 this 3 645  8 collider 1 617  6 target 1 617  15 drive_interface 1 646  
165 0 0 6 252 525 0 0 92 /**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */ 2 4 this 3 645  8 collider 1 617  
166 0 0 6 253 525 0 0 94 /**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */ 2 4 this 3 648  8 collider 1 617  
167 0 0 4 254 587 0 0 77 /**
 * Completely empties the list of colliders this handler knows about.
 */ 1 4 this 3 645  
168 0 0 4 255 587 0 0 269 /**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */ 2 4 this 3 645  6 center 1 617  
169 0 0 4 256 587 0 0 64 /**
 * Clears the center NodePath specified with set_center.
 */ 1 4 this 3 645  
170 0 0 6 257 617 0 0 114 /**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */ 1 4 this 3 648  
171 0 0 6 258 525 0 0 95 /**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */ 1 4 this 3 648  
172 0 0 6 259 525 0 0 255 /**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */ 1 4 this 3 648  
173 0 0 7 262 595 0 0 0 0 
174 0 0 7 264 650 426 0 10 /**
 *
 */ 0 
175 0 0 4 265 587 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 650  6 offset 1 532  
176 0 0 6 266 532 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 651  
177 0 0 4 267 587 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 650  5 reach 1 532  
178 0 0 6 268 532 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 651  
179 0 0 4 269 587 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 650  7 max_vel 1 532  
180 0 0 6 270 532 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 651  
181 0 0 7 274 595 0 0 0 0 
182 0 0 7 276 653 426 0 10 /**
 *
 */ 0 
183 0 0 4 277 587 0 0 10 /**
 *
 */ 2 4 this 3 653  4 flag 1 525  
184 0 0 6 278 525 0 0 10 /**
 *
 */ 1 4 this 3 654  
185 0 0 7 280 595 0 0 0 0 
186 0 0 7 282 656 451 0 10 /**
 *
 */ 0 
187 0 0 7 283 595 0 0 0 0 
188 0 0 7 286 657 426 0 10 /**
 *
 */ 0 
189 0 0 4 287 587 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 657  6 offset 1 532  
190 0 0 6 288 532 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 658  
191 0 0 4 289 587 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 657  5 reach 1 532  
192 0 0 6 290 532 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 658  
193 0 0 6 291 532 0 0 238 /**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */ 1 4 this 3 658  
194 0 0 6 292 525 0 0 33 /**
 * Is the object at rest?
 */ 1 4 this 3 658  
195 0 0 6 293 532 0 0 282 /**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */ 1 4 this 3 658  
196 0 0 6 294 588 0 0 10 /**
 *
 */ 1 4 this 3 658  
197 0 0 4 295 587 0 0 184 /**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */ 2 4 this 3 657  8 velocity 1 532  
198 0 0 4 296 587 0 0 46 /**
 * Sets the current vertical velocity.
 */ 2 4 this 3 657  8 velocity 1 532  
199 0 0 6 297 532 0 0 354 /**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */ 1 4 this 3 658  
200 0 0 4 298 587 0 0 56 /**
 * Sets the linear gravity force (always plumb).
 */ 2 4 this 3 657  7 gravity 1 532  
201 0 0 6 299 532 0 0 56 /**
 * Gets the linear gravity force (always plumb).
 */ 1 4 this 3 658  
202 0 0 4 300 587 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 657  7 max_vel 1 532  
203 0 0 6 301 532 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 658  
204 0 0 4 302 587 0 0 229 /**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */ 2 4 this 3 657  11 legacy_mode 1 525  
205 0 0 6 303 525 0 0 49 /**
 * returns true if legacy mode is enabled
 */ 1 4 this 3 658  
206 0 0 7 314 595 0 0 0 0 
207 0 0 7 316 660 473 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
208 0 0 7 316 660 473 0 0 1 6 param0 0 661  
209 0 0 7 317 595 0 0 0 0 
210 0 0 7 320 663 482 0 10 /**
 *
 */ 0 
211 0 0 7 320 663 482 0 0 1 6 param0 0 664  
212 0 0 4 321 587 0 0 257 /**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */ 1 4 this 3 663  
213 0 0 4 322 587 0 0 50 /**
 * Removes all the entries from the queue.
 */ 1 4 this 3 663  
214 0 0 6 323 542 0 0 69 /**
 * Returns the number of CollisionEntries detected last pass.
 */ 1 4 this 3 664  
215 0 0 7 324 574 380 0 61 /**
 * Returns the nth CollisionEntry detected last pass.
 */ 2 4 this 3 664  1 n 1 542  
216 0 0 4 328 587 0 0 10 /**
 *
 */ 2 4 this 3 664  3 out 1 592  
217 0 0 4 329 587 0 0 10 /**
 *
 */ 3 4 this 3 664  3 out 1 592  12 indent_level 1 542  
218 0 0 7 330 595 0 0 0 0 
219 0 0 7 333 666 489 0 10 /**
 *
 */ 2 6 center 1 596  6 radius 1 532  
220 0 0 7 333 666 489 0 10 /**
 *
 */ 4 2 cx 1 532  2 cy 1 532  2 cz 1 532  6 radius 1 532  
221 0 0 4 334 587 0 0 10 /**
 *
 */ 2 4 this 3 666  6 center 1 596  
222 0 0 4 334 587 0 0 10 /**
 *
 */ 4 4 this 3 666  1 x 1 532  1 y 1 532  1 z 1 532  
223 0 0 6 335 596 0 0 10 /**
 *
 */ 1 4 this 3 667  
224 0 0 4 336 587 0 0 10 /**
 *
 */ 2 4 this 3 666  6 radius 1 532  
225 0 0 6 337 532 0 0 10 /**
 *
 */ 1 4 this 3 667  
226 0 0 7 340 595 0 0 0 0 
227 0 0 7 343 669 492 0 10 /**
 *
 */ 2 6 center 1 596  6 radius 1 532  
228 0 0 7 343 669 492 0 10 /**
 *
 */ 4 2 cx 1 532  2 cy 1 532  2 cz 1 532  6 radius 1 532  
229 0 0 7 344 595 0 0 0 0 
230 0 0 7 347 670 500 0 183 /**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */ 0 
231 0 0 7 347 670 500 0 10 /**
 *
 */ 2 6 origin 1 596  9 direction 1 588  
232 0 0 7 347 670 500 0 10 /**
 *
 */ 6 2 ox 1 532  2 oy 1 532  2 oz 1 532  2 dx 1 532  2 dy 1 532  2 dz 1 532  
233 0 0 4 348 587 0 0 10 /**
 *
 */ 2 4 this 3 670  6 origin 1 596  
234 0 0 4 348 587 0 0 10 /**
 *
 */ 4 4 this 3 670  1 x 1 532  1 y 1 532  1 z 1 532  
235 0 0 6 349 596 0 0 10 /**
 *
 */ 1 4 this 3 671  
236 0 0 4 351 587 0 0 10 /**
 *
 */ 2 4 this 3 670  9 direction 1 588  
237 0 0 4 351 587 0 0 10 /**
 *
 */ 4 4 this 3 670  1 x 1 532  1 y 1 532  1 z 1 532  
238 0 0 6 352 588 0 0 10 /**
 *
 */ 1 4 this 3 671  
239 0 0 6 354 525 0 0 327 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 670  6 camera 1 673  5 point 1 675  
240 0 0 6 354 525 0 0 262 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */ 4 4 this 3 670  6 camera 1 673  2 px 1 532  2 py 1 532  
241 0 0 7 355 595 0 0 0 0 
242 0 0 7 358 679 503 0 185 /**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */ 0 
243 0 0 7 358 679 503 0 10 /**
 *
 */ 2 6 origin 1 596  9 direction 1 588  
244 0 0 7 358 679 503 0 10 /**
 *
 */ 6 2 ox 1 532  2 oy 1 532  2 oz 1 532  2 dx 1 532  2 dy 1 532  2 dz 1 532  
245 0 0 7 359 595 0 0 0 0 
246 0 0 7 362 680 512 0 39 /**
 * Creates an invalid parabola.
 */ 0 
247 0 0 7 362 680 512 0 110 /**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */ 3 8 parabola 1 681  2 t1 1 532  2 t2 1 532  
248 0 0 4 363 587 0 0 57 /**
 * Replaces the parabola specified by this solid.
 */ 2 4 this 3 680  8 parabola 1 681  
249 0 0 6 364 681 0 0 56 /**
 * Returns the parabola specified by this solid.
 */ 1 4 this 3 682  
250 0 0 4 365 587 0 0 54 /**
 * Changes the starting point on the parabola.
 */ 2 4 this 3 680  2 t1 1 532  
251 0 0 6 366 532 0 0 54 /**
 * Returns the starting point on the parabola.
 */ 1 4 this 3 682  
252 0 0 4 367 587 0 0 52 /**
 * Changes the ending point on the parabola.
 */ 2 4 this 3 680  2 t2 1 532  
253 0 0 6 368 532 0 0 52 /**
 * Returns the ending point on the parabola.
 */ 1 4 this 3 682  
254 0 0 7 375 595 0 0 0 0 
255 0 0 7 378 684 520 0 191 /**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */ 0 
256 0 0 7 378 684 520 0 10 /**
 *
 */ 2 1 a 1 596  2 db 1 596  
257 0 0 7 378 684 520 0 10 /**
 *
 */ 6 2 ax 1 532  2 ay 1 532  2 az 1 532  2 bx 1 532  2 by 1 532  2 bz 1 532  
258 0 0 4 379 587 0 0 10 /**
 *
 */ 2 4 this 3 684  1 a 1 596  
259 0 0 4 379 587 0 0 10 /**
 *
 */ 4 4 this 3 684  1 x 1 532  1 y 1 532  1 z 1 532  
260 0 0 6 380 596 0 0 10 /**
 *
 */ 1 4 this 3 685  
261 0 0 4 381 587 0 0 10 /**
 *
 */ 2 4 this 3 684  1 b 1 596  
262 0 0 4 381 587 0 0 10 /**
 *
 */ 4 4 this 3 684  1 x 1 532  1 y 1 532  1 z 1 532  
263 0 0 6 382 596 0 0 10 /**
 *
 */ 1 4 this 3 685  
264 0 0 6 383 525 0 0 336 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 684  6 camera 1 673  5 point 1 675  
265 0 0 6 383 525 0 0 271 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */ 4 4 this 3 684  6 camera 1 673  2 px 1 532  2 py 1 532  
266 0 0 7 386 595 0 0 0 0 
166
521 14 CollisionSolid 0 75777 14 CollisionSolid 14 CollisionSolid 0 0 0 0 0 4 687 688 689 690 14 267 268 269 270 271 272 273 274 275 276 277 278 279 280 0 0 1 0 522 0 0 0 0 457
/**
 * The abstract base class for all things that can collide with other things
 * in the world, and all the things they can collide with (except geometry).
 *
 * This class and its derivatives really work very similarly to the way
 * BoundingVolume and all of its derivatives work.  There's a different
 * subclass for each basic shape of solid, and double-dispatch function calls
 * handle the subset of the N*N intersection tests that we care about.
 */

522 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

523 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 524 0 0 0 0 0 0 0 0 0 0

524 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

525 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

526 32 ConstPointerTo< BoundingVolume > 0 2048 32 ConstPointerTo< BoundingVolume > 32 ConstPointerTo< BoundingVolume > 0 0 0 0 0 0 0 0 0 0 0 0 0

527 12 CollisionBox 0 141313 12 CollisionBox 12 CollisionBox 0 0 0 1 281 294 4 691 692 693 694 12 282 283 284 285 286 287 288 289 290 291 292 293 0 0 1 0 521 0 0 0 0 47
/**
 * A cuboid collision volume or object.
 */

528 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 523 0 0 0 0 0 0 0 0 0 0

529 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 530 0 0 0 0 0 0 0 0 0 0

530 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

531 16 CollisionCapsule 0 141313 16 CollisionCapsule 16 CollisionCapsule 0 0 0 1 295 303 3 695 696 697 7 296 297 298 299 300 301 302 0 0 1 0 521 0 0 0 0 201
/**
 * This implements a solid consisting of a cylinder with hemispherical endcaps,
 * also known as a capsule or a spherocylinder.
 *
 * This shape was previously erroneously called CollisionTube.
 */

532 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 533 0 0 0 0 0 0 0 0 0 0

533 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

534 16 CollisionHandler 0 141313 16 CollisionHandler 16 CollisionHandler 0 0 0 1 305 306 0 1 304 0 0 1 0 535 0 0 0 0 262
/**
 * The abstract interface to a number of classes that decide what to do when a
 * collision is detected.  One of these must be assigned to the
 * CollisionTraverser that is processing collisions in order to specify how to
 * dispatch detected collisions.
 */

535 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

536 13 CollisionNode 0 75777 13 CollisionNode 13 CollisionNode 0 0 0 1 307 0 5 698 699 700 701 702 17 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 1 748 0 1 0 537 0 0 0 0 261
/**
 * A node in the scene graph that can hold any number of CollisionSolids.
 * This may either represent a bit of static geometry in the scene that things
 * will collide with, or an animated object twirling around in the world and
 * running into things.
 */

537 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

538 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 539 0 0 0 0 0 0 0 0 0 0

539 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 540 0 0 0 0 0 0 0 0 0 0

540 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

541 32 ConstPointerTo< CollisionSolid > 0 2048 32 ConstPointerTo< CollisionSolid > 32 ConstPointerTo< CollisionSolid > 0 0 0 0 0 0 0 0 0 0 0 0 0

542 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

543 18 CollisionTraverser 0 26625 18 CollisionTraverser 18 CollisionTraverser 0 0 0 1 325 326 3 703 704 705 19 327 328 329 330 331 332 333 334 335 336 337 338 339 340 343 344 345 346 347 1 749 0 1 0 544 0 0 0 0 467
/**
 * This class manages the traversal through the scene graph to detect
 * collisions.  It holds ownership of a number of collider objects, each of
 * which is a CollisionNode and an associated CollisionHandler.
 *
 * When traverse() is called, it begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */

544 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

545 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

546 19 CollisionRecorder * 0 8576 19 CollisionRecorder * 19 CollisionRecorder * 0 0 547 0 0 0 0 0 0 0 0 0 0

547 17 CollisionRecorder 0 75777 17 CollisionRecorder 17 CollisionRecorder 0 0 0 0 0 0 2 341 342 0 0 1 0 548 0 0 0 0 206
/**
 * This class is used to help debug the work the collisions system is doing.
 * It is a virtual base class that just provides an interface for recording
 * collisions tested and detected each frame.
 */

548 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

549 14 CollisionEntry 0 141313 14 CollisionEntry 14 CollisionEntry 0 0 0 0 380 8 706 707 708 709 710 711 712 713 32 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 0 0 1 0 550 0 0 0 0 437
/**
 * Defines a single collision event.  One of these is created for each
 * collision detected by a CollisionTraverser, to be dealt with by the
 * CollisionHandler.
 *
 * A CollisionEntry provides slots for a number of data values (such as
 * intersection point and normal) that might or might not be known for each
 * collision.  It is up to the handler to determine what information is known
 * and to do the right thing with it.
 */

550 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

551 22 CollisionSolid const * 0 8576 22 CollisionSolid const * 22 CollisionSolid const * 0 0 552 0 0 0 0 0 0 0 0 0 0

552 20 CollisionSolid const 0 8832 20 CollisionSolid const 20 CollisionSolid const 0 0 521 0 0 0 0 0 0 0 0 0 0

553 15 CollisionNode * 0 8576 15 CollisionNode * 15 CollisionNode * 0 0 536 0 0 0 0 0 0 0 0 0 0

554 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 537 0 0 0 0 0 0 0 0 0 0

555 14 CollisionPlane 0 141313 14 CollisionPlane 14 CollisionPlane 0 0 0 1 381 388 2 714 715 6 382 383 384 385 386 387 0 0 1 0 521 0 0 0 0 10
/**
 *
 */

556 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 557 0 0 0 0 0 0 0 0 0 0

557 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 558 0 0 0 0 0 0 0 0 0 0

558 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120
/**
 * An abstract mathematical description of a plane.  A plane is defined by the
 * equation Ax + By + Cz + D = 0.
 */

559 18 CollisionFloorMesh 0 141313 18 CollisionFloorMesh 18 CollisionFloorMesh 0 0 0 1 389 397 2 716 717 7 390 391 392 393 394 395 396 2 750 751 0 1 0 521 0 0 0 0 124
/**
 * This object represents a solid made entirely of triangles, which will only
 * be tested again z axis aligned rays
 */

560 8 LPoint3i 0 2048 8 LPoint3i 8 LPoint3i 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

561 16 CollisionPolygon 0 141313 16 CollisionPolygon 16 CollisionPolygon 0 0 0 1 398 406 3 718 719 720 7 399 400 401 402 403 404 405 1 752 0 1 0 555 0 0 0 0 10
/**
 *
 */

562 21 CollisionHandlerEvent 0 141313 21 CollisionHandlerEvent 21 CollisionHandlerEvent 0 0 0 1 407 426 3 721 722 723 18 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 3 753 754 755 0 1 0 534 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

563 6 string 0 2105344 11 std::string 11 std::string 0 0 564 0 0 0 0 0 0 0 0 0 0

564 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

565 24 CollisionHandlerPhysical 0 75777 24 CollisionHandlerPhysical 24 CollisionHandlerPhysical 0 0 0 0 426 1 724 10 427 428 429 430 431 432 433 434 435 436 0 0 1 0 562 0 0 0 0 209
/**
 * The abstract base class for a number of CollisionHandlers that have some
 * physical effect on their moving bodies: they need to update the nodes'
 * positions based on the effects of the collision.
 */

566 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 545 0 0 0 0 0 0 0 0 0 0

567 21 CollisionHandlerFloor 0 75777 21 CollisionHandlerFloor 21 CollisionHandlerFloor 0 0 0 1 437 426 3 725 726 727 7 438 439 440 441 442 443 444 0 0 1 0 565 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

568 22 CollisionHandlerPusher 0 75777 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 1 445 426 1 728 3 446 447 448 0 0 1 0 565 0 0 0 0 197
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This is the simplest kind of "real-
 * world" collisions you can have.
 */

569 27 CollisionHandlerFluidPusher 0 141313 27 CollisionHandlerFluidPusher 27 CollisionHandlerFluidPusher 0 0 0 1 449 451 0 1 450 0 0 1 0 568 0 0 0 0 139
/**
 * A CollisionHandlerPusher that makes use of timing and spatial information
 * from fluid collisions to improve collision response
 */

570 23 CollisionHandlerGravity 0 75777 23 CollisionHandlerGravity 23 CollisionHandlerGravity 0 0 0 1 452 426 9 729 730 731 732 733 734 735 736 737 18 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 0 0 1 0 565 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

571 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 529 0 0 0 0 0 0 0 0 0 0

572 28 CollisionHandlerHighestEvent 0 141313 28 CollisionHandlerHighestEvent 28 CollisionHandlerHighestEvent 0 0 0 1 471 473 0 1 472 0 0 1 0 562 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

573 21 CollisionHandlerQueue 0 141313 21 CollisionHandlerQueue 21 CollisionHandlerQueue 0 0 0 1 474 482 1 738 7 475 476 477 478 479 480 481 1 756 0 1 0 534 0 0 0 0 313
/**
 * A special kind of CollisionHandler that does nothing except remember the
 * CollisionEntries detected the last pass.  This set of CollisionEntries may
 * then be queried by the calling function.  It's primarily useful when a
 * simple intersection test is being made, e.g.  for picking from the window.
 */

574 16 CollisionEntry * 0 8576 16 CollisionEntry * 16 CollisionEntry * 0 0 549 0 0 0 0 0 0 0 0 0 0

575 15 CollisionSphere 0 141313 15 CollisionSphere 15 CollisionSphere 0 0 0 1 483 489 2 739 740 5 484 485 486 487 488 0 0 1 0 521 0 0 0 0 50
/**
 * A spherical collision volume or object.
 */

576 18 CollisionInvSphere 0 141313 18 CollisionInvSphere 18 CollisionInvSphere 0 0 0 1 490 492 0 1 491 0 0 1 0 575 0 0 0 0 272
/**
 * An inverted sphere: this is a sphere whose collision surface is the inside
 * surface of the sphere.  Everything outside the sphere is solid matter;
 * everything inside is empty space.  Useful for constraining objects to
 * remain within a spherical perimeter.
 */

577 12 CollisionRay 0 141313 12 CollisionRay 12 CollisionRay 0 0 0 1 493 500 2 741 742 6 494 495 496 497 498 499 0 0 1 0 521 0 0 0 0 220
/**
 * An infinite ray, with a specific origin and direction.  It begins at its
 * origin and continues in one direction to infinity, and it has no radius.
 * Useful for picking from a window, or for gravity effects.
 */

578 13 CollisionLine 0 141313 13 CollisionLine 13 CollisionLine 0 0 0 1 501 503 0 1 502 0 0 1 0 577 0 0 0 0 131
/**
 * An infinite line, similar to a CollisionRay, except that it extends in both
 * directions.  It is, however, directional.
 */

579 17 CollisionParabola 0 141313 17 CollisionParabola 17 CollisionParabola 0 0 0 1 504 512 3 743 744 745 7 505 506 507 508 509 510 511 0 0 1 0 521 0 0 0 0 308
/**
 * This defines a parabolic arc, or subset of an arc, similar to the path of a
 * projectile or falling object.  It is finite, having a specific beginning
 * and end, but it is infinitely thin.
 *
 * Think of it as a wire bending from point t1 to point t2 along the path of a
 * pre-defined parabola.
 */

580 15 LParabola const 0 8832 15 LParabola const 15 LParabola const 0 0 581 0 0 0 0 0 0 0 0 0 0

581 9 LParabola 0 2105344 9 LParabola 9 LParabola 0 0 582 0 0 0 0 0 0 0 0 0 0

582 10 LParabolaf 0 2048 10 LParabolaf 10 LParabolaf 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * An abstract mathematical description of a parabola, particularly useful for
 * describing arcs of projectiles.
 *
 * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.
 */

583 16 CollisionSegment 0 141313 16 CollisionSegment 16 CollisionSegment 0 0 0 1 513 520 2 746 747 6 514 515 516 517 518 519 0 0 1 0 521 0 0 0 0 371
/**
 * A finite line segment, with two specific endpoints but no thickness.  It's
 * similar to a CollisionRay, except it does not continue to infinity.
 *
 * It does have an ordering, from point A to point B. If more than a single
 * point of the segment is intersecting a solid, the reported intersection
 * point is generally the closest on the segment to point A.
 */

584 13 CollisionTube 0 2105345 13 CollisionTube 13 CollisionTube 0 0 531 0 0 0 0 0 0 0 0 0 0

585 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 523 0 0 0 0 0 0 0 0 0 0

586 16 CollisionSolid * 0 8576 16 CollisionSolid * 16 CollisionSolid * 0 0 521 0 0 0 0 0 0 0 0 0 0

587 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

588 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 571 0 0 0 0 0 0 0 0 0 0

589 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 590 0 0 0 0 0 0 0 0 0 0

590 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330
/**
 * This is an abstract class for any volume in any sense which can be said to
 * define the locality of reference of a node in a graph, along with all of
 * its descendants.  It is not necessarily a geometric volume (although see
 * GeometricBoundingVolume); this is simply an abstract interface for bounds
 * of any sort.
 */

591 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 589 0 0 0 0 0 0 0 0 0 0

592 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 593 0 0 0 0 0 0 0 0 0 0

593 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

594 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

595 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 594 0 0 0 0 0 0 0 0 0 0

596 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 528 0 0 0 0 0 0 0 0 0 0

597 14 CollisionBox * 0 8576 14 CollisionBox * 14 CollisionBox * 0 0 527 0 0 0 0 0 0 0 0 0 0

598 20 CollisionBox const * 0 8576 20 CollisionBox const * 20 CollisionBox const * 0 0 599 0 0 0 0 0 0 0 0 0 0

599 18 CollisionBox const 0 8832 18 CollisionBox const 18 CollisionBox const 0 0 527 0 0 0 0 0 0 0 0 0 0

600 8 LPlane * 0 8576 8 LPlane * 8 LPlane * 0 0 557 0 0 0 0 0 0 0 0 0 0

601 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 529 0 0 0 0 0 0 0 0 0 0

602 18 CollisionCapsule * 0 8576 18 CollisionCapsule * 18 CollisionCapsule * 0 0 531 0 0 0 0 0 0 0 0 0 0

603 24 CollisionCapsule const * 0 8576 24 CollisionCapsule const * 24 CollisionCapsule const * 0 0 604 0 0 0 0 0 0 0 0 0 0

604 22 CollisionCapsule const 0 8832 22 CollisionCapsule const 22 CollisionCapsule const 0 0 531 0 0 0 0 0 0 0 0 0 0

605 24 CollisionHandler const * 0 8576 24 CollisionHandler const * 24 CollisionHandler const * 0 0 606 0 0 0 0 0 0 0 0 0 0

606 22 CollisionHandler const 0 8832 22 CollisionHandler const 22 CollisionHandler const 0 0 534 0 0 0 0 0 0 0 0 0 0

607 18 CollisionHandler * 0 8576 18 CollisionHandler * 18 CollisionHandler * 0 0 534 0 0 0 0 0 0 0 0 0 0

608 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

609 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 538 0 0 0 0 0 0 0 0 0 0

610 21 CollisionNode const * 0 8576 21 CollisionNode const * 21 CollisionNode const * 0 0 611 0 0 0 0 0 0 0 0 0 0

611 19 CollisionNode const 0 8832 19 CollisionNode const 19 CollisionNode const 0 0 536 0 0 0 0 0 0 0 0 0 0

612 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 613 0 0 0 0 0 0 0 0 0 0

613 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

614 26 CollisionTraverser const * 0 8576 26 CollisionTraverser const * 26 CollisionTraverser const * 0 0 615 0 0 0 0 0 0 0 0 0 0

615 24 CollisionTraverser const 0 8832 24 CollisionTraverser const 24 CollisionTraverser const 0 0 543 0 0 0 0 0 0 0 0 0 0

616 20 CollisionTraverser * 0 8576 20 CollisionTraverser * 20 CollisionTraverser * 0 0 543 0 0 0 0 0 0 0 0 0 0

617 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 566 0 0 0 0 0 0 0 0 0 0

618 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 545 0 0 0 0 0 0 0 0 0 0

619 25 CollisionRecorder const * 0 8576 25 CollisionRecorder const * 25 CollisionRecorder const * 0 0 620 0 0 0 0 0 0 0 0 0 0

620 23 CollisionRecorder const 0 8832 23 CollisionRecorder const 23 CollisionRecorder const 0 0 547 0 0 0 0 0 0 0 0 0 0

621 22 CollisionEntry const * 0 8576 22 CollisionEntry const * 22 CollisionEntry const * 0 0 622 0 0 0 0 0 0 0 0 0 0

622 20 CollisionEntry const 0 8832 20 CollisionEntry const 20 CollisionEntry const 0 0 549 0 0 0 0 0 0 0 0 0 0

623 22 CollisionPlane const * 0 8576 22 CollisionPlane const * 22 CollisionPlane const * 0 0 624 0 0 0 0 0 0 0 0 0 0

624 20 CollisionPlane const 0 8832 20 CollisionPlane const 20 CollisionPlane const 0 0 555 0 0 0 0 0 0 0 0 0 0

625 16 CollisionPlane * 0 8576 16 CollisionPlane * 16 CollisionPlane * 0 0 555 0 0 0 0 0 0 0 0 0 0

626 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 556 0 0 0 0 0 0 0 0 0 0

627 20 CollisionFloorMesh * 0 8576 20 CollisionFloorMesh * 20 CollisionFloorMesh * 0 0 559 0 0 0 0 0 0 0 0 0 0

628 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

629 26 CollisionFloorMesh const * 0 8576 26 CollisionFloorMesh const * 26 CollisionFloorMesh const * 0 0 630 0 0 0 0 0 0 0 0 0 0

630 24 CollisionFloorMesh const 0 8832 24 CollisionFloorMesh const 24 CollisionFloorMesh const 0 0 559 0 0 0 0 0 0 0 0 0 0

631 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 560 0 0 0 0 0 0 0 0 0 0

632 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 633 0 0 0 0 0 0 0 0 0 0

633 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 634 0 0 0 0 0 0 0 0 0 0

634 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 635 0 0 0 0 0 0 0 0 0 0

635 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

636 18 CollisionPolygon * 0 8576 18 CollisionPolygon * 18 CollisionPolygon * 0 0 561 0 0 0 0 0 0 0 0 0 0

637 24 CollisionPolygon const * 0 8576 24 CollisionPolygon const * 24 CollisionPolygon const * 0 0 638 0 0 0 0 0 0 0 0 0 0

638 22 CollisionPolygon const 0 8832 22 CollisionPolygon const 22 CollisionPolygon const 0 0 561 0 0 0 0 0 0 0 0 0 0

639 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 640 0 0 0 0 0 0 0 0 0 0

640 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 641 0 0 0 0 0 0 0 0 0 0

641 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

642 23 CollisionHandlerEvent * 0 8576 23 CollisionHandlerEvent * 23 CollisionHandlerEvent * 0 0 562 0 0 0 0 0 0 0 0 0 0

643 29 CollisionHandlerEvent const * 0 8576 29 CollisionHandlerEvent const * 29 CollisionHandlerEvent const * 0 0 644 0 0 0 0 0 0 0 0 0 0

644 27 CollisionHandlerEvent const 0 8832 27 CollisionHandlerEvent const 27 CollisionHandlerEvent const 0 0 562 0 0 0 0 0 0 0 0 0 0

645 26 CollisionHandlerPhysical * 0 8576 26 CollisionHandlerPhysical * 26 CollisionHandlerPhysical * 0 0 565 0 0 0 0 0 0 0 0 0 0

646 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 647 0 0 0 0 0 0 0 0 0 0

647 14 DriveInterface 0 2048 14 DriveInterface 14 DriveInterface 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * This is a TFormer, similar to Trackball, that moves around a transform
 * matrix in response to mouse input.  The basic motion is on a horizontal
 * plane, as if driving a vehicle.
 */

648 32 CollisionHandlerPhysical const * 0 8576 32 CollisionHandlerPhysical const * 32 CollisionHandlerPhysical const * 0 0 649 0 0 0 0 0 0 0 0 0 0

649 30 CollisionHandlerPhysical const 0 8832 30 CollisionHandlerPhysical const 30 CollisionHandlerPhysical const 0 0 565 0 0 0 0 0 0 0 0 0 0

650 23 CollisionHandlerFloor * 0 8576 23 CollisionHandlerFloor * 23 CollisionHandlerFloor * 0 0 567 0 0 0 0 0 0 0 0 0 0

651 29 CollisionHandlerFloor const * 0 8576 29 CollisionHandlerFloor const * 29 CollisionHandlerFloor const * 0 0 652 0 0 0 0 0 0 0 0 0 0

652 27 CollisionHandlerFloor const 0 8832 27 CollisionHandlerFloor const 27 CollisionHandlerFloor const 0 0 567 0 0 0 0 0 0 0 0 0 0

653 24 CollisionHandlerPusher * 0 8576 24 CollisionHandlerPusher * 24 CollisionHandlerPusher * 0 0 568 0 0 0 0 0 0 0 0 0 0

654 30 CollisionHandlerPusher const * 0 8576 30 CollisionHandlerPusher const * 30 CollisionHandlerPusher const * 0 0 655 0 0 0 0 0 0 0 0 0 0

655 28 CollisionHandlerPusher const 0 8832 28 CollisionHandlerPusher const 28 CollisionHandlerPusher const 0 0 568 0 0 0 0 0 0 0 0 0 0

656 29 CollisionHandlerFluidPusher * 0 8576 29 CollisionHandlerFluidPusher * 29 CollisionHandlerFluidPusher * 0 0 569 0 0 0 0 0 0 0 0 0 0

657 25 CollisionHandlerGravity * 0 8576 25 CollisionHandlerGravity * 25 CollisionHandlerGravity * 0 0 570 0 0 0 0 0 0 0 0 0 0

658 31 CollisionHandlerGravity const * 0 8576 31 CollisionHandlerGravity const * 31 CollisionHandlerGravity const * 0 0 659 0 0 0 0 0 0 0 0 0 0

659 29 CollisionHandlerGravity const 0 8832 29 CollisionHandlerGravity const 29 CollisionHandlerGravity const 0 0 570 0 0 0 0 0 0 0 0 0 0

660 30 CollisionHandlerHighestEvent * 0 8576 30 CollisionHandlerHighestEvent * 30 CollisionHandlerHighestEvent * 0 0 572 0 0 0 0 0 0 0 0 0 0

661 36 CollisionHandlerHighestEvent const * 0 8576 36 CollisionHandlerHighestEvent const * 36 CollisionHandlerHighestEvent const * 0 0 662 0 0 0 0 0 0 0 0 0 0

662 34 CollisionHandlerHighestEvent const 0 8832 34 CollisionHandlerHighestEvent const 34 CollisionHandlerHighestEvent const 0 0 572 0 0 0 0 0 0 0 0 0 0

663 23 CollisionHandlerQueue * 0 8576 23 CollisionHandlerQueue * 23 CollisionHandlerQueue * 0 0 573 0 0 0 0 0 0 0 0 0 0

664 29 CollisionHandlerQueue const * 0 8576 29 CollisionHandlerQueue const * 29 CollisionHandlerQueue const * 0 0 665 0 0 0 0 0 0 0 0 0 0

665 27 CollisionHandlerQueue const 0 8832 27 CollisionHandlerQueue const 27 CollisionHandlerQueue const 0 0 573 0 0 0 0 0 0 0 0 0 0

666 17 CollisionSphere * 0 8576 17 CollisionSphere * 17 CollisionSphere * 0 0 575 0 0 0 0 0 0 0 0 0 0

667 23 CollisionSphere const * 0 8576 23 CollisionSphere const * 23 CollisionSphere const * 0 0 668 0 0 0 0 0 0 0 0 0 0

668 21 CollisionSphere const 0 8832 21 CollisionSphere const 21 CollisionSphere const 0 0 575 0 0 0 0 0 0 0 0 0 0

669 20 CollisionInvSphere * 0 8576 20 CollisionInvSphere * 20 CollisionInvSphere * 0 0 576 0 0 0 0 0 0 0 0 0 0

670 14 CollisionRay * 0 8576 14 CollisionRay * 14 CollisionRay * 0 0 577 0 0 0 0 0 0 0 0 0 0

671 20 CollisionRay const * 0 8576 20 CollisionRay const * 20 CollisionRay const * 0 0 672 0 0 0 0 0 0 0 0 0 0

672 18 CollisionRay const 0 8832 18 CollisionRay const 18 CollisionRay const 0 0 577 0 0 0 0 0 0 0 0 0 0

673 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 674 0 0 0 0 0 0 0 0 0 0

674 8 LensNode 0 2048 8 LensNode 8 LensNode 0 0 0 0 0 0 0 0 0 0 0 0 181
/**
 * A node that contains a Lens.  The most important example of this kind of
 * node is a Camera, but other kinds of nodes also contain a lens (for
 * instance, a Spotlight).
 */

675 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 676 0 0 0 0 0 0 0 0 0 0

676 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 677 0 0 0 0 0 0 0 0 0 0

677 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 678 0 0 0 0 0 0 0 0 0 0

678 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

679 15 CollisionLine * 0 8576 15 CollisionLine * 15 CollisionLine * 0 0 578 0 0 0 0 0 0 0 0 0 0

680 19 CollisionParabola * 0 8576 19 CollisionParabola * 19 CollisionParabola * 0 0 579 0 0 0 0 0 0 0 0 0 0

681 17 LParabola const * 0 8576 17 LParabola const * 17 LParabola const * 0 0 580 0 0 0 0 0 0 0 0 0 0

682 25 CollisionParabola const * 0 8576 25 CollisionParabola const * 25 CollisionParabola const * 0 0 683 0 0 0 0 0 0 0 0 0 0

683 23 CollisionParabola const 0 8832 23 CollisionParabola const 23 CollisionParabola const 0 0 579 0 0 0 0 0 0 0 0 0 0

684 18 CollisionSegment * 0 8576 18 CollisionSegment * 18 CollisionSegment * 0 0 583 0 0 0 0 0 0 0 0 0 0

685 24 CollisionSegment const * 0 8576 24 CollisionSegment const * 24 CollisionSegment const * 0 0 686 0 0 0 0 0 0 0 0 0 0

686 22 CollisionSegment const 0 8832 22 CollisionSegment const 22 CollisionSegment const 0 0 583 0 0 0 0 0 0 0 0 0 0

0
61
687 16 collision_origin 0 2 523 267 0 0 0 0 0 0 0 32 CollisionSolid::collision_origin 0

688 8 tangible 0 6 525 269 268 0 0 0 0 0 0 24 CollisionSolid::tangible 0

689 24 respect_effective_normal 0 6 525 275 274 0 0 0 0 0 0 40 CollisionSolid::respect_effective_normal 0

690 6 bounds 0 6 526 276 277 0 0 0 0 0 0 22 CollisionSolid::bounds 0

691 6 center 0 2 528 289 0 0 0 0 0 0 0 20 CollisionBox::center 0

692 3 min 0 2 528 290 0 0 0 0 0 0 0 17 CollisionBox::min 0

693 3 max 0 2 528 291 0 0 0 0 0 0 0 17 CollisionBox::max 0

694 10 dimensions 0 2 529 292 0 0 0 0 0 0 0 24 CollisionBox::dimensions 0

695 7 point_a 0 6 528 297 296 0 0 0 0 0 0 25 CollisionCapsule::point_a 0

696 7 point_b 0 6 528 299 298 0 0 0 0 0 0 25 CollisionCapsule::point_b 0

697 6 radius 0 6 532 301 300 0 0 0 0 0 0 24 CollisionCapsule::radius 0

698 17 from_collide_mask 0 6 538 311 309 0 0 0 0 0 0 32 CollisionNode::from_collide_mask 0

699 17 into_collide_mask 0 6 538 312 310 0 0 0 0 0 0 32 CollisionNode::into_collide_mask 0

700 6 solids 0 358 541 315 317 0 0 319 314 318 0 21 CollisionNode::solids 0

701 13 collider_sort 0 6 542 321 322 0 0 0 0 0 0 28 CollisionNode::collider_sort 0

702 20 default_collide_mask 0 2 538 323 0 0 0 0 0 0 0 35 CollisionNode::default_collide_mask 0

703 22 respect_prev_transform 0 6 525 328 327 0 0 0 0 0 0 42 CollisionTraverser::respect_prev_transform 0

704 9 colliders 0 66 545 333 0 0 0 0 332 0 0 29 CollisionTraverser::colliders 0

705 8 recorder 0 30 546 339 337 338 340 0 0 0 0 28 CollisionTraverser::recorder 0

706 10 from_solid 0 2 551 348 0 0 0 0 0 0 0 26 CollisionEntry::from_solid 0

707 10 into_solid 0 2 551 350 0 0 0 0 0 0 0 26 CollisionEntry::into_solid 0

708 9 from_node 0 2 553 351 0 0 0 0 0 0 0 25 CollisionEntry::from_node 0

709 9 into_node 0 2 554 352 0 0 0 0 0 0 0 25 CollisionEntry::into_node 0

710 14 from_node_path 0 2 545 353 0 0 0 0 0 0 0 30 CollisionEntry::from_node_path 0

711 14 into_node_path 0 2 545 354 0 0 0 0 0 0 0 30 CollisionEntry::into_node_path 0

712 1 t 0 6 532 356 355 0 0 0 0 0 0 17 CollisionEntry::t 0

713 22 respect_prev_transform 0 2 525 359 0 0 0 0 0 0 0 38 CollisionEntry::respect_prev_transform 0

714 6 normal 0 2 529 382 0 0 0 0 0 0 0 22 CollisionPlane::normal 0

715 5 plane 0 6 556 385 384 0 0 0 0 0 0 21 CollisionPlane::plane 0

716 8 vertices 0 66 528 393 0 0 0 0 392 0 0 28 CollisionFloorMesh::vertices 0

717 9 triangles 0 66 560 395 0 0 0 0 394 0 0 29 CollisionFloorMesh::triangles 0

718 6 points 0 66 523 400 0 0 0 0 399 0 0 24 CollisionPolygon::points 0

719 5 valid 0 2 525 402 0 0 0 0 0 0 0 23 CollisionPolygon::valid 0

720 7 concave 0 2 525 403 0 0 0 0 0 0 0 25 CollisionPolygon::concave 0

721 11 in_patterns 0 66 563 412 0 0 0 0 411 0 0 34 CollisionHandlerEvent::in_patterns 0

722 14 again_patterns 0 66 563 422 0 0 0 0 416 0 0 37 CollisionHandlerEvent::again_patterns 0

723 12 out_patterns 0 66 563 422 0 0 0 0 421 0 0 35 CollisionHandlerEvent::out_patterns 0

724 6 center 0 30 566 433 431 434 432 0 0 0 0 32 CollisionHandlerPhysical::center 0

725 6 offset 0 6 532 439 438 0 0 0 0 0 0 29 CollisionHandlerFloor::offset 0

726 5 reach 0 6 532 441 440 0 0 0 0 0 0 28 CollisionHandlerFloor::reach 0

727 12 max_velocity 0 6 532 443 442 0 0 0 0 0 0 35 CollisionHandlerFloor::max_velocity 0

728 10 horizontal 0 6 525 447 446 0 0 0 0 0 0 34 CollisionHandlerPusher::horizontal 0

729 6 offset 0 6 532 454 453 0 0 0 0 0 0 31 CollisionHandlerGravity::offset 0

730 5 reach 0 6 532 456 455 0 0 0 0 0 0 30 CollisionHandlerGravity::reach 0

731 15 airborne_height 0 2 532 457 0 0 0 0 0 0 0 40 CollisionHandlerGravity::airborne_height 0

732 9 on_ground 0 2 525 458 0 0 0 0 0 0 0 34 CollisionHandlerGravity::on_ground 0

733 15 impact_velocity 0 2 532 459 0 0 0 0 0 0 0 40 CollisionHandlerGravity::impact_velocity 0

734 14 contact_normal 0 2 571 460 0 0 0 0 0 0 0 39 CollisionHandlerGravity::contact_normal 0

735 8 velocity 0 6 532 463 462 0 0 0 0 0 0 33 CollisionHandlerGravity::velocity 0

736 7 gravity 0 6 532 465 464 0 0 0 0 0 0 32 CollisionHandlerGravity::gravity 0

737 12 max_velocity 0 6 532 467 466 0 0 0 0 0 0 37 CollisionHandlerGravity::max_velocity 0

738 7 entries 0 66 574 478 0 0 0 0 477 0 0 30 CollisionHandlerQueue::entries 0

739 6 center 0 6 528 485 484 0 0 0 0 0 0 23 CollisionSphere::center 0

740 6 radius 0 6 532 487 486 0 0 0 0 0 0 23 CollisionSphere::radius 0

741 6 origin 0 6 528 495 494 0 0 0 0 0 0 20 CollisionRay::origin 0

742 9 direction 0 6 571 497 496 0 0 0 0 0 0 23 CollisionRay::direction 0

743 8 parabola 0 6 580 506 505 0 0 0 0 0 0 27 CollisionParabola::parabola 0

744 2 t1 0 6 532 508 507 0 0 0 0 0 0 21 CollisionParabola::t1 0

745 2 t2 0 6 532 510 509 0 0 0 0 0 0 21 CollisionParabola::t2 0

746 7 point_a 0 6 528 515 514 0 0 0 0 0 0 25 CollisionSegment::point_a 0

747 7 point_b 0 6 528 517 516 0 0 0 0 0 0 25 CollisionSegment::point_b 0

9
748 10 get_solids 0 314 315 25 CollisionNode::get_solids 0

749 13 get_colliders 0 332 333 33 CollisionTraverser::get_colliders 0

750 12 get_vertices 0 392 393 32 CollisionFloorMesh::get_vertices 0

751 13 get_triangles 0 394 395 33 CollisionFloorMesh::get_triangles 0

752 10 get_points 0 399 400 28 CollisionPolygon::get_points 0

753 15 get_in_patterns 0 411 412 38 CollisionHandlerEvent::get_in_patterns 0

754 18 get_again_patterns 0 416 417 41 CollisionHandlerEvent::get_again_patterns 0

755 16 get_out_patterns 0 421 422 39 CollisionHandlerEvent::get_out_patterns 0

756 11 get_entries 0 477 478 34 CollisionHandlerQueue::get_entries 0

