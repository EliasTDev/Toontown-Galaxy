1641926114
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1650
2067 11 MathNumbers 0 4 3717 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

2068 12 ~MathNumbers 0 4 3717 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

2069 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1977 1978 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

2070 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1979 1980 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

2071 10 LVecBase2f 0 4 3718 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

2072 12 operator new 0 4 3718 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

2073 15 operator delete 0 4 3718 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

2074 12 validate_ptr 0 4 3718 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

2075 10 operator = 0 4 3718 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

2076 4 zero 0 4 3718 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

2077 6 unit_x 0 4 3718 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

2078 6 unit_y 0 4 3718 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

2079 10 __reduce__ 0 4 3718 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

2080 11 __getattr__ 0 4 3718 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2081 11 __setattr__ 0 4 3718 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2082 11 operator [] 0 4 3718 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

2083 13 operator [] = 0 260 3718 25 LVecBase2f::operator [] = 0 1 18 0
63
void LVecBase2f::operator [] =(int i, float const &assign_val);

2084 4 size 0 4 3718 16 LVecBase2f::size 0 1 19 0
44
static constexpr int LVecBase2f::size(void);

2085 6 is_nan 0 4 3718 18 LVecBase2f::is_nan 0 1 20 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

2086 8 get_cell 0 4 3718 20 LVecBase2f::get_cell 0 1 21 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

2087 8 set_cell 0 4 3718 20 LVecBase2f::set_cell 0 1 22 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

2088 5 get_x 0 4 3718 17 LVecBase2f::get_x 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

2089 5 get_y 0 4 3718 17 LVecBase2f::get_y 0 1 24 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

2090 5 set_x 0 4 3718 17 LVecBase2f::set_x 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

2091 5 set_y 0 4 3718 17 LVecBase2f::set_y 0 1 26 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

2092 11 add_to_cell 0 4 3718 23 LVecBase2f::add_to_cell 0 1 27 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

2093 5 add_x 0 4 3718 17 LVecBase2f::add_x 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

2094 5 add_y 0 4 3718 17 LVecBase2f::add_y 0 1 29 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

2095 8 get_data 0 4 3718 20 LVecBase2f::get_data 0 1 30 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

2096 18 get_num_components 0 4 3718 30 LVecBase2f::get_num_components 0 1 31 0
58
static constexpr int LVecBase2f::get_num_components(void);

2097 4 fill 0 4 3718 16 LVecBase2f::fill 0 1 32 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

2098 3 set 0 4 3718 15 LVecBase2f::set 0 1 33 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

2099 3 dot 0 4 3718 15 LVecBase2f::dot 0 1 34 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

2100 14 length_squared 0 4 3718 26 LVecBase2f::length_squared 0 1 35 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

2101 6 length 0 4 3718 18 LVecBase2f::length 0 1 36 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2102 9 normalize 0 4 3718 21 LVecBase2f::normalize 0 1 37 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2103 10 normalized 0 4 3718 22 LVecBase2f::normalized 0 1 38 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2104 7 project 0 4 3718 19 LVecBase2f::project 0 1 39 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2105 10 operator < 0 4 3718 22 LVecBase2f::operator < 0 1 40 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2106 11 operator == 0 4 3718 23 LVecBase2f::operator == 0 1 41 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2107 11 operator != 0 4 3718 23 LVecBase2f::operator != 0 1 42 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2108 10 compare_to 0 4 3718 22 LVecBase2f::compare_to 0 2 43 44 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2109 8 get_hash 0 4 3718 20 LVecBase2f::get_hash 0 2 45 46 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2110 8 add_hash 0 4 3718 20 LVecBase2f::add_hash 0 2 47 48 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2111 13 generate_hash 0 4 3718 25 LVecBase2f::generate_hash 0 2 49 50 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2112 10 operator - 0 68 3718 22 LVecBase2f::operator - 0 1 51 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2113 10 operator + 0 4 3718 22 LVecBase2f::operator + 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2114 10 operator - 0 4 3718 22 LVecBase2f::operator - 0 1 53 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2115 10 operator * 0 4 3718 22 LVecBase2f::operator * 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2116 10 operator / 0 4 3718 22 LVecBase2f::operator / 0 1 55 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2117 11 operator += 0 4 3718 23 LVecBase2f::operator += 0 1 56 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2118 11 operator -= 0 4 3718 23 LVecBase2f::operator -= 0 1 57 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2119 11 operator *= 0 4 3718 23 LVecBase2f::operator *= 0 1 58 0
50
inline void LVecBase2f::operator *=(float scalar);

2120 11 operator /= 0 4 3718 23 LVecBase2f::operator /= 0 1 59 0
50
inline void LVecBase2f::operator /=(float scalar);

2121 18 componentwise_mult 0 4 3718 30 LVecBase2f::componentwise_mult 0 1 60 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2122 8 __rmul__ 0 4 3718 20 LVecBase2f::__rmul__ 0 1 61 0
74
inline PyObject *LVecBase2f::__rmul__(PyObject *self, float scalar) const;

2123 12 __floordiv__ 0 4 3718 24 LVecBase2f::__floordiv__ 0 1 62 0
78
inline PyObject *LVecBase2f::__floordiv__(PyObject *self, float scalar) const;

2124 13 __ifloordiv__ 0 4 3718 25 LVecBase2f::__ifloordiv__ 0 1 63 0
73
inline PyObject *LVecBase2f::__ifloordiv__(PyObject *self, float scalar);

2125 7 __pow__ 0 4 3718 19 LVecBase2f::__pow__ 0 1 64 0
75
inline PyObject *LVecBase2f::__pow__(PyObject *self, float exponent) const;

2126 8 __ipow__ 0 4 3718 20 LVecBase2f::__ipow__ 0 1 65 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2127 9 __round__ 0 4 3718 21 LVecBase2f::__round__ 0 1 66 0
55
inline PyObject *LVecBase2f::__round__(PyObject *self);

2128 9 __floor__ 0 4 3718 21 LVecBase2f::__floor__ 0 1 67 0
55
inline PyObject *LVecBase2f::__floor__(PyObject *self);

2129 8 __ceil__ 0 4 3718 20 LVecBase2f::__ceil__ 0 1 68 0
54
inline PyObject *LVecBase2f::__ceil__(PyObject *self);

2130 4 fmax 0 4 3718 16 LVecBase2f::fmax 0 1 69 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2131 4 fmin 0 4 3718 16 LVecBase2f::fmin 0 1 70 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2132 12 almost_equal 0 4 3718 24 LVecBase2f::almost_equal 0 2 71 72 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2133 6 output 0 4 3718 18 LVecBase2f::output 0 1 73 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2134 8 __repr__ 0 4 3718 20 LVecBase2f::__repr__ 0 1 74 0
52
inline std::string LVecBase2f::__repr__(void) const;

2135 20 write_datagram_fixed 0 4 3718 32 LVecBase2f::write_datagram_fixed 0 1 75 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2136 19 read_datagram_fixed 0 4 3718 31 LVecBase2f::read_datagram_fixed 0 1 76 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2137 14 write_datagram 0 4 3718 26 LVecBase2f::write_datagram 0 1 77 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2138 13 read_datagram 0 4 3718 25 LVecBase2f::read_datagram 0 1 78 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2139 13 __getbuffer__ 0 4 3718 25 LVecBase2f::__getbuffer__ 0 1 79 0
87
inline int LVecBase2f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2140 14 get_class_type 0 4 3718 26 LVecBase2f::get_class_type 0 1 80 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2141 11 ~LVecBase2f 0 4 3718 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2142 10 LVecBase2d 0 4 3721 22 LVecBase2d::LVecBase2d 0 4 81 82 83 84 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2143 12 operator new 0 4 3721 24 LVecBase2d::operator new 0 1 85 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2144 15 operator delete 0 4 3721 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2145 12 validate_ptr 0 4 3721 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2146 10 operator = 0 4 3721 22 LVecBase2d::operator = 0 2 86 87 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2147 4 zero 0 4 3721 16 LVecBase2d::zero 0 1 88 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2148 6 unit_x 0 4 3721 18 LVecBase2d::unit_x 0 1 89 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2149 6 unit_y 0 4 3721 18 LVecBase2d::unit_y 0 1 90 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2150 10 __reduce__ 0 4 3721 22 LVecBase2d::__reduce__ 0 1 91 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2151 11 __getattr__ 0 4 3721 23 LVecBase2d::__getattr__ 0 1 92 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2152 11 __setattr__ 0 4 3721 23 LVecBase2d::__setattr__ 0 1 93 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2153 11 operator [] 0 4 3721 23 LVecBase2d::operator [] 0 2 94 95 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2154 13 operator [] = 0 260 3721 25 LVecBase2d::operator [] = 0 1 96 0
64
void LVecBase2d::operator [] =(int i, double const &assign_val);

2155 4 size 0 4 3721 16 LVecBase2d::size 0 1 97 0
44
static constexpr int LVecBase2d::size(void);

2156 6 is_nan 0 4 3721 18 LVecBase2d::is_nan 0 1 98 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2157 8 get_cell 0 4 3721 20 LVecBase2d::get_cell 0 1 99 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2158 8 set_cell 0 4 3721 20 LVecBase2d::set_cell 0 1 100 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2159 5 get_x 0 4 3721 17 LVecBase2d::get_x 0 1 101 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2160 5 get_y 0 4 3721 17 LVecBase2d::get_y 0 1 102 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2161 5 set_x 0 4 3721 17 LVecBase2d::set_x 0 1 103 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2162 5 set_y 0 4 3721 17 LVecBase2d::set_y 0 1 104 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2163 11 add_to_cell 0 4 3721 23 LVecBase2d::add_to_cell 0 1 105 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2164 5 add_x 0 4 3721 17 LVecBase2d::add_x 0 1 106 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2165 5 add_y 0 4 3721 17 LVecBase2d::add_y 0 1 107 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2166 8 get_data 0 4 3721 20 LVecBase2d::get_data 0 1 108 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2167 18 get_num_components 0 4 3721 30 LVecBase2d::get_num_components 0 1 109 0
58
static constexpr int LVecBase2d::get_num_components(void);

2168 4 fill 0 4 3721 16 LVecBase2d::fill 0 1 110 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2169 3 set 0 4 3721 15 LVecBase2d::set 0 1 111 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2170 3 dot 0 4 3721 15 LVecBase2d::dot 0 1 112 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2171 14 length_squared 0 4 3721 26 LVecBase2d::length_squared 0 1 113 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2172 6 length 0 4 3721 18 LVecBase2d::length 0 1 114 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2173 9 normalize 0 4 3721 21 LVecBase2d::normalize 0 1 115 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2174 10 normalized 0 4 3721 22 LVecBase2d::normalized 0 1 116 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2175 7 project 0 4 3721 19 LVecBase2d::project 0 1 117 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2176 10 operator < 0 4 3721 22 LVecBase2d::operator < 0 1 118 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2177 11 operator == 0 4 3721 23 LVecBase2d::operator == 0 1 119 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2178 11 operator != 0 4 3721 23 LVecBase2d::operator != 0 1 120 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2179 10 compare_to 0 4 3721 22 LVecBase2d::compare_to 0 2 121 122 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2180 8 get_hash 0 4 3721 20 LVecBase2d::get_hash 0 2 123 124 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2181 8 add_hash 0 4 3721 20 LVecBase2d::add_hash 0 2 125 126 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2182 13 generate_hash 0 4 3721 25 LVecBase2d::generate_hash 0 2 127 128 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2183 10 operator - 0 68 3721 22 LVecBase2d::operator - 0 1 129 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2184 10 operator + 0 4 3721 22 LVecBase2d::operator + 0 1 130 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2185 10 operator - 0 4 3721 22 LVecBase2d::operator - 0 1 131 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2186 10 operator * 0 4 3721 22 LVecBase2d::operator * 0 1 132 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2187 10 operator / 0 4 3721 22 LVecBase2d::operator / 0 1 133 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2188 11 operator += 0 4 3721 23 LVecBase2d::operator += 0 1 134 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2189 11 operator -= 0 4 3721 23 LVecBase2d::operator -= 0 1 135 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2190 11 operator *= 0 4 3721 23 LVecBase2d::operator *= 0 1 136 0
51
inline void LVecBase2d::operator *=(double scalar);

2191 11 operator /= 0 4 3721 23 LVecBase2d::operator /= 0 1 137 0
51
inline void LVecBase2d::operator /=(double scalar);

2192 18 componentwise_mult 0 4 3721 30 LVecBase2d::componentwise_mult 0 1 138 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2193 8 __rmul__ 0 4 3721 20 LVecBase2d::__rmul__ 0 1 139 0
75
inline PyObject *LVecBase2d::__rmul__(PyObject *self, double scalar) const;

2194 12 __floordiv__ 0 4 3721 24 LVecBase2d::__floordiv__ 0 1 140 0
79
inline PyObject *LVecBase2d::__floordiv__(PyObject *self, double scalar) const;

2195 13 __ifloordiv__ 0 4 3721 25 LVecBase2d::__ifloordiv__ 0 1 141 0
74
inline PyObject *LVecBase2d::__ifloordiv__(PyObject *self, double scalar);

2196 7 __pow__ 0 4 3721 19 LVecBase2d::__pow__ 0 1 142 0
76
inline PyObject *LVecBase2d::__pow__(PyObject *self, double exponent) const;

2197 8 __ipow__ 0 4 3721 20 LVecBase2d::__ipow__ 0 1 143 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2198 9 __round__ 0 4 3721 21 LVecBase2d::__round__ 0 1 144 0
55
inline PyObject *LVecBase2d::__round__(PyObject *self);

2199 9 __floor__ 0 4 3721 21 LVecBase2d::__floor__ 0 1 145 0
55
inline PyObject *LVecBase2d::__floor__(PyObject *self);

2200 8 __ceil__ 0 4 3721 20 LVecBase2d::__ceil__ 0 1 146 0
54
inline PyObject *LVecBase2d::__ceil__(PyObject *self);

2201 4 fmax 0 4 3721 16 LVecBase2d::fmax 0 1 147 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2202 4 fmin 0 4 3721 16 LVecBase2d::fmin 0 1 148 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2203 12 almost_equal 0 4 3721 24 LVecBase2d::almost_equal 0 2 149 150 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2204 6 output 0 4 3721 18 LVecBase2d::output 0 1 151 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2205 8 __repr__ 0 4 3721 20 LVecBase2d::__repr__ 0 1 152 0
52
inline std::string LVecBase2d::__repr__(void) const;

2206 20 write_datagram_fixed 0 4 3721 32 LVecBase2d::write_datagram_fixed 0 1 153 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2207 19 read_datagram_fixed 0 4 3721 31 LVecBase2d::read_datagram_fixed 0 1 154 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2208 14 write_datagram 0 4 3721 26 LVecBase2d::write_datagram 0 1 155 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2209 13 read_datagram 0 4 3721 25 LVecBase2d::read_datagram 0 1 156 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2210 13 __getbuffer__ 0 4 3721 25 LVecBase2d::__getbuffer__ 0 1 157 0
87
inline int LVecBase2d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2211 14 get_class_type 0 4 3721 26 LVecBase2d::get_class_type 0 1 158 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2212 11 ~LVecBase2d 0 4 3721 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2213 10 LVecBase2i 0 4 3724 22 LVecBase2i::LVecBase2i 0 4 159 160 161 162 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2214 12 operator new 0 4 3724 24 LVecBase2i::operator new 0 1 163 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2215 15 operator delete 0 4 3724 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2216 12 validate_ptr 0 4 3724 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2217 10 operator = 0 4 3724 22 LVecBase2i::operator = 0 2 164 165 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2218 4 zero 0 4 3724 16 LVecBase2i::zero 0 1 166 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2219 6 unit_x 0 4 3724 18 LVecBase2i::unit_x 0 1 167 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2220 6 unit_y 0 4 3724 18 LVecBase2i::unit_y 0 1 168 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2221 10 __reduce__ 0 4 3724 22 LVecBase2i::__reduce__ 0 1 169 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2222 11 __getattr__ 0 4 3724 23 LVecBase2i::__getattr__ 0 1 170 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2223 11 __setattr__ 0 4 3724 23 LVecBase2i::__setattr__ 0 1 171 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2224 11 operator [] 0 4 3724 23 LVecBase2i::operator [] 0 2 172 173 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2225 13 operator [] = 0 260 3724 25 LVecBase2i::operator [] = 0 1 174 0
61
void LVecBase2i::operator [] =(int i, int const &assign_val);

2226 4 size 0 4 3724 16 LVecBase2i::size 0 1 175 0
44
static constexpr int LVecBase2i::size(void);

2227 6 is_nan 0 4 3724 18 LVecBase2i::is_nan 0 1 176 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2228 8 get_cell 0 4 3724 20 LVecBase2i::get_cell 0 1 177 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2229 8 set_cell 0 4 3724 20 LVecBase2i::set_cell 0 1 178 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2230 5 get_x 0 4 3724 17 LVecBase2i::get_x 0 1 179 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2231 5 get_y 0 4 3724 17 LVecBase2i::get_y 0 1 180 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2232 5 set_x 0 4 3724 17 LVecBase2i::set_x 0 1 181 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2233 5 set_y 0 4 3724 17 LVecBase2i::set_y 0 1 182 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2234 11 add_to_cell 0 4 3724 23 LVecBase2i::add_to_cell 0 1 183 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2235 5 add_x 0 4 3724 17 LVecBase2i::add_x 0 1 184 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2236 5 add_y 0 4 3724 17 LVecBase2i::add_y 0 1 185 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2237 8 get_data 0 4 3724 20 LVecBase2i::get_data 0 1 186 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2238 18 get_num_components 0 4 3724 30 LVecBase2i::get_num_components 0 1 187 0
58
static constexpr int LVecBase2i::get_num_components(void);

2239 4 fill 0 4 3724 16 LVecBase2i::fill 0 1 188 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2240 3 set 0 4 3724 15 LVecBase2i::set 0 1 189 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2241 3 dot 0 4 3724 15 LVecBase2i::dot 0 1 190 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2242 14 length_squared 0 4 3724 26 LVecBase2i::length_squared 0 1 191 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2243 10 operator < 0 4 3724 22 LVecBase2i::operator < 0 1 192 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2244 11 operator == 0 4 3724 23 LVecBase2i::operator == 0 1 193 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2245 11 operator != 0 4 3724 23 LVecBase2i::operator != 0 1 194 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2246 10 compare_to 0 4 3724 22 LVecBase2i::compare_to 0 1 195 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2247 8 get_hash 0 4 3724 20 LVecBase2i::get_hash 0 1 196 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2248 8 add_hash 0 4 3724 20 LVecBase2i::add_hash 0 1 197 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2249 13 generate_hash 0 4 3724 25 LVecBase2i::generate_hash 0 1 198 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2250 10 operator - 0 68 3724 22 LVecBase2i::operator - 0 1 199 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2251 10 operator + 0 4 3724 22 LVecBase2i::operator + 0 1 200 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2252 10 operator - 0 4 3724 22 LVecBase2i::operator - 0 1 201 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2253 10 operator * 0 4 3724 22 LVecBase2i::operator * 0 1 202 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2254 10 operator / 0 4 3724 22 LVecBase2i::operator / 0 1 203 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2255 11 operator += 0 4 3724 23 LVecBase2i::operator += 0 1 204 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2256 11 operator -= 0 4 3724 23 LVecBase2i::operator -= 0 1 205 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2257 11 operator *= 0 4 3724 23 LVecBase2i::operator *= 0 1 206 0
48
inline void LVecBase2i::operator *=(int scalar);

2258 11 operator /= 0 4 3724 23 LVecBase2i::operator /= 0 1 207 0
48
inline void LVecBase2i::operator /=(int scalar);

2259 18 componentwise_mult 0 4 3724 30 LVecBase2i::componentwise_mult 0 1 208 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2260 8 __rmul__ 0 4 3724 20 LVecBase2i::__rmul__ 0 1 209 0
72
inline PyObject *LVecBase2i::__rmul__(PyObject *self, int scalar) const;

2261 12 __floordiv__ 0 4 3724 24 LVecBase2i::__floordiv__ 0 1 210 0
76
inline PyObject *LVecBase2i::__floordiv__(PyObject *self, int scalar) const;

2262 13 __ifloordiv__ 0 4 3724 25 LVecBase2i::__ifloordiv__ 0 1 211 0
71
inline PyObject *LVecBase2i::__ifloordiv__(PyObject *self, int scalar);

2263 7 __pow__ 0 4 3724 19 LVecBase2i::__pow__ 0 1 212 0
73
inline PyObject *LVecBase2i::__pow__(PyObject *self, int exponent) const;

2264 8 __ipow__ 0 4 3724 20 LVecBase2i::__ipow__ 0 1 213 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2265 9 __round__ 0 4 3724 21 LVecBase2i::__round__ 0 1 214 0
55
inline PyObject *LVecBase2i::__round__(PyObject *self);

2266 9 __floor__ 0 4 3724 21 LVecBase2i::__floor__ 0 1 215 0
55
inline PyObject *LVecBase2i::__floor__(PyObject *self);

2267 8 __ceil__ 0 4 3724 20 LVecBase2i::__ceil__ 0 1 216 0
54
inline PyObject *LVecBase2i::__ceil__(PyObject *self);

2268 4 fmax 0 4 3724 16 LVecBase2i::fmax 0 1 217 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2269 4 fmin 0 4 3724 16 LVecBase2i::fmin 0 1 218 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2270 12 almost_equal 0 4 3724 24 LVecBase2i::almost_equal 0 2 219 220 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2271 6 output 0 4 3724 18 LVecBase2i::output 0 1 221 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2272 8 __repr__ 0 4 3724 20 LVecBase2i::__repr__ 0 1 222 0
52
inline std::string LVecBase2i::__repr__(void) const;

2273 20 write_datagram_fixed 0 4 3724 32 LVecBase2i::write_datagram_fixed 0 1 223 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2274 19 read_datagram_fixed 0 4 3724 31 LVecBase2i::read_datagram_fixed 0 1 224 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2275 14 write_datagram 0 4 3724 26 LVecBase2i::write_datagram 0 1 225 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2276 13 read_datagram 0 4 3724 25 LVecBase2i::read_datagram 0 1 226 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2277 13 __getbuffer__ 0 4 3724 25 LVecBase2i::__getbuffer__ 0 1 227 0
87
inline int LVecBase2i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2278 14 get_class_type 0 4 3724 26 LVecBase2i::get_class_type 0 1 228 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2279 11 ~LVecBase2i 0 4 3724 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2280 9 LVector2f 0 4 3727 20 LVector2f::LVector2f 0 5 229 230 231 232 233 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2281 11 __getattr__ 0 4 3727 22 LVector2f::__getattr__ 0 1 234 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2282 11 __setattr__ 0 4 3727 22 LVector2f::__setattr__ 0 1 235 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2283 4 zero 0 4 3727 15 LVector2f::zero 0 1 236 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2284 6 unit_x 0 4 3727 17 LVector2f::unit_x 0 1 237 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2285 6 unit_y 0 4 3727 17 LVector2f::unit_y 0 1 238 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2286 10 operator - 0 68 3727 21 LVector2f::operator - 0 1 239 0
51
inline LVector2f LVector2f::operator -(void) const;

2287 10 operator + 0 4 3727 21 LVector2f::operator + 0 2 240 241 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2288 10 operator - 0 4 3727 21 LVector2f::operator - 0 2 242 243 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2289 10 operator * 0 4 3727 21 LVector2f::operator * 0 1 244 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2290 10 operator / 0 4 3727 21 LVector2f::operator / 0 1 245 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2291 8 __rmul__ 0 4 3727 19 LVector2f::__rmul__ 0 1 246 0
57
inline LVector2f LVector2f::__rmul__(float scalar) const;

2292 10 normalized 0 4 3727 21 LVector2f::normalized 0 1 247 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2293 7 project 0 4 3727 18 LVector2f::project 0 1 248 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2294 16 signed_angle_rad 0 4 3727 27 LVector2f::signed_angle_rad 0 1 249 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2295 16 signed_angle_deg 0 4 3727 27 LVector2f::signed_angle_deg 0 1 250 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2296 8 __repr__ 0 4 3727 19 LVector2f::__repr__ 0 1 251 0
51
inline std::string LVector2f::__repr__(void) const;

2297 14 get_class_type 0 4 3727 25 LVector2f::get_class_type 0 1 252 0
50
static TypeHandle LVector2f::get_class_type(void);

2298 10 ~LVector2f 0 4 3727 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2299 9 LVector2d 0 4 3728 20 LVector2d::LVector2d 0 5 253 254 255 256 257 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2300 11 __getattr__ 0 4 3728 22 LVector2d::__getattr__ 0 1 258 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2301 11 __setattr__ 0 4 3728 22 LVector2d::__setattr__ 0 1 259 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2302 4 zero 0 4 3728 15 LVector2d::zero 0 1 260 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2303 6 unit_x 0 4 3728 17 LVector2d::unit_x 0 1 261 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2304 6 unit_y 0 4 3728 17 LVector2d::unit_y 0 1 262 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2305 10 operator - 0 68 3728 21 LVector2d::operator - 0 1 263 0
51
inline LVector2d LVector2d::operator -(void) const;

2306 10 operator + 0 4 3728 21 LVector2d::operator + 0 2 264 265 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2307 10 operator - 0 4 3728 21 LVector2d::operator - 0 2 266 267 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2308 10 operator * 0 4 3728 21 LVector2d::operator * 0 1 268 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2309 10 operator / 0 4 3728 21 LVector2d::operator / 0 1 269 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2310 8 __rmul__ 0 4 3728 19 LVector2d::__rmul__ 0 1 270 0
58
inline LVector2d LVector2d::__rmul__(double scalar) const;

2311 10 normalized 0 4 3728 21 LVector2d::normalized 0 1 271 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2312 7 project 0 4 3728 18 LVector2d::project 0 1 272 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2313 16 signed_angle_rad 0 4 3728 27 LVector2d::signed_angle_rad 0 1 273 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2314 16 signed_angle_deg 0 4 3728 27 LVector2d::signed_angle_deg 0 1 274 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2315 8 __repr__ 0 4 3728 19 LVector2d::__repr__ 0 1 275 0
51
inline std::string LVector2d::__repr__(void) const;

2316 14 get_class_type 0 4 3728 25 LVector2d::get_class_type 0 1 276 0
50
static TypeHandle LVector2d::get_class_type(void);

2317 10 ~LVector2d 0 4 3728 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2318 9 LVector2i 0 4 3729 20 LVector2i::LVector2i 0 5 277 278 279 280 281 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2319 11 __getattr__ 0 4 3729 22 LVector2i::__getattr__ 0 1 282 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2320 11 __setattr__ 0 4 3729 22 LVector2i::__setattr__ 0 1 283 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2321 4 zero 0 4 3729 15 LVector2i::zero 0 1 284 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2322 6 unit_x 0 4 3729 17 LVector2i::unit_x 0 1 285 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2323 6 unit_y 0 4 3729 17 LVector2i::unit_y 0 1 286 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2324 10 operator - 0 68 3729 21 LVector2i::operator - 0 1 287 0
51
inline LVector2i LVector2i::operator -(void) const;

2325 10 operator + 0 4 3729 21 LVector2i::operator + 0 2 288 289 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2326 10 operator - 0 4 3729 21 LVector2i::operator - 0 2 290 291 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2327 10 operator * 0 4 3729 21 LVector2i::operator * 0 1 292 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2328 10 operator / 0 4 3729 21 LVector2i::operator / 0 1 293 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2329 8 __rmul__ 0 4 3729 19 LVector2i::__rmul__ 0 1 294 0
55
inline LVector2i LVector2i::__rmul__(int scalar) const;

2330 8 __repr__ 0 4 3729 19 LVector2i::__repr__ 0 1 295 0
51
inline std::string LVector2i::__repr__(void) const;

2331 14 get_class_type 0 4 3729 25 LVector2i::get_class_type 0 1 296 0
50
static TypeHandle LVector2i::get_class_type(void);

2332 10 ~LVector2i 0 4 3729 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2333 8 LPoint2f 0 4 3730 18 LPoint2f::LPoint2f 0 5 297 298 299 300 301 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2334 11 __getattr__ 0 4 3730 21 LPoint2f::__getattr__ 0 1 302 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2335 11 __setattr__ 0 4 3730 21 LPoint2f::__setattr__ 0 1 303 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2336 4 zero 0 4 3730 14 LPoint2f::zero 0 1 304 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2337 6 unit_x 0 4 3730 16 LPoint2f::unit_x 0 1 305 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2338 6 unit_y 0 4 3730 16 LPoint2f::unit_y 0 1 306 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2339 10 operator - 0 68 3730 20 LPoint2f::operator - 0 1 307 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2340 10 operator + 0 4 3730 20 LPoint2f::operator + 0 2 308 309 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2341 10 operator - 0 4 3730 20 LPoint2f::operator - 0 3 310 311 312 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2342 10 operator * 0 4 3730 20 LPoint2f::operator * 0 1 313 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2343 10 operator / 0 4 3730 20 LPoint2f::operator / 0 1 314 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2344 8 __rmul__ 0 4 3730 18 LPoint2f::__rmul__ 0 1 315 0
55
inline LPoint2f LPoint2f::__rmul__(float scalar) const;

2345 10 normalized 0 4 3730 20 LPoint2f::normalized 0 1 316 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2346 7 project 0 4 3730 17 LPoint2f::project 0 1 317 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2347 8 __repr__ 0 4 3730 18 LPoint2f::__repr__ 0 1 318 0
50
inline std::string LPoint2f::__repr__(void) const;

2348 14 get_class_type 0 4 3730 24 LPoint2f::get_class_type 0 1 319 0
49
static TypeHandle LPoint2f::get_class_type(void);

2349 9 ~LPoint2f 0 4 3730 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2350 8 LPoint2d 0 4 3731 18 LPoint2d::LPoint2d 0 5 320 321 322 323 324 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2351 11 __getattr__ 0 4 3731 21 LPoint2d::__getattr__ 0 1 325 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2352 11 __setattr__ 0 4 3731 21 LPoint2d::__setattr__ 0 1 326 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2353 4 zero 0 4 3731 14 LPoint2d::zero 0 1 327 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2354 6 unit_x 0 4 3731 16 LPoint2d::unit_x 0 1 328 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2355 6 unit_y 0 4 3731 16 LPoint2d::unit_y 0 1 329 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2356 10 operator - 0 68 3731 20 LPoint2d::operator - 0 1 330 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2357 10 operator + 0 4 3731 20 LPoint2d::operator + 0 2 331 332 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2358 10 operator - 0 4 3731 20 LPoint2d::operator - 0 3 333 334 335 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2359 10 operator * 0 4 3731 20 LPoint2d::operator * 0 1 336 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2360 10 operator / 0 4 3731 20 LPoint2d::operator / 0 1 337 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2361 8 __rmul__ 0 4 3731 18 LPoint2d::__rmul__ 0 1 338 0
56
inline LPoint2d LPoint2d::__rmul__(double scalar) const;

2362 10 normalized 0 4 3731 20 LPoint2d::normalized 0 1 339 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2363 7 project 0 4 3731 17 LPoint2d::project 0 1 340 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2364 8 __repr__ 0 4 3731 18 LPoint2d::__repr__ 0 1 341 0
50
inline std::string LPoint2d::__repr__(void) const;

2365 14 get_class_type 0 4 3731 24 LPoint2d::get_class_type 0 1 342 0
49
static TypeHandle LPoint2d::get_class_type(void);

2366 9 ~LPoint2d 0 4 3731 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2367 8 LPoint2i 0 4 3732 18 LPoint2i::LPoint2i 0 5 343 344 345 346 347 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2368 11 __getattr__ 0 4 3732 21 LPoint2i::__getattr__ 0 1 348 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2369 11 __setattr__ 0 4 3732 21 LPoint2i::__setattr__ 0 1 349 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2370 4 zero 0 4 3732 14 LPoint2i::zero 0 1 350 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2371 6 unit_x 0 4 3732 16 LPoint2i::unit_x 0 1 351 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2372 6 unit_y 0 4 3732 16 LPoint2i::unit_y 0 1 352 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2373 10 operator - 0 68 3732 20 LPoint2i::operator - 0 1 353 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2374 10 operator + 0 4 3732 20 LPoint2i::operator + 0 2 354 355 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2375 10 operator - 0 4 3732 20 LPoint2i::operator - 0 3 356 357 358 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2376 10 operator * 0 4 3732 20 LPoint2i::operator * 0 1 359 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2377 10 operator / 0 4 3732 20 LPoint2i::operator / 0 1 360 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2378 8 __rmul__ 0 4 3732 18 LPoint2i::__rmul__ 0 1 361 0
53
inline LPoint2i LPoint2i::__rmul__(int scalar) const;

2379 8 __repr__ 0 4 3732 18 LPoint2i::__repr__ 0 1 362 0
50
inline std::string LPoint2i::__repr__(void) const;

2380 14 get_class_type 0 4 3732 24 LPoint2i::get_class_type 0 1 363 0
49
static TypeHandle LPoint2i::get_class_type(void);

2381 9 ~LPoint2i 0 4 3732 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2382 10 LVecBase3f 0 4 3733 22 LVecBase3f::LVecBase3f 0 5 364 365 366 367 368 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2383 12 operator new 0 4 3733 24 LVecBase3f::operator new 0 1 369 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2384 15 operator delete 0 4 3733 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2385 12 validate_ptr 0 4 3733 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2386 10 operator = 0 4 3733 22 LVecBase3f::operator = 0 2 370 371 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2387 4 zero 0 4 3733 16 LVecBase3f::zero 0 1 372 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2388 6 unit_x 0 4 3733 18 LVecBase3f::unit_x 0 1 373 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2389 6 unit_y 0 4 3733 18 LVecBase3f::unit_y 0 1 374 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2390 6 unit_z 0 4 3733 18 LVecBase3f::unit_z 0 1 375 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2391 10 __reduce__ 0 4 3733 22 LVecBase3f::__reduce__ 0 1 376 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2392 11 __getattr__ 0 4 3733 23 LVecBase3f::__getattr__ 0 1 377 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2393 11 __setattr__ 0 4 3733 23 LVecBase3f::__setattr__ 0 1 378 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2394 11 operator [] 0 4 3733 23 LVecBase3f::operator [] 0 2 379 380 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2395 13 operator [] = 0 260 3733 25 LVecBase3f::operator [] = 0 1 381 0
63
void LVecBase3f::operator [] =(int i, float const &assign_val);

2396 4 size 0 4 3733 16 LVecBase3f::size 0 1 382 0
44
static constexpr int LVecBase3f::size(void);

2397 6 is_nan 0 4 3733 18 LVecBase3f::is_nan 0 1 383 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2398 8 get_cell 0 4 3733 20 LVecBase3f::get_cell 0 1 384 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2399 5 get_x 0 4 3733 17 LVecBase3f::get_x 0 1 385 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2400 5 get_y 0 4 3733 17 LVecBase3f::get_y 0 1 386 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2401 5 get_z 0 4 3733 17 LVecBase3f::get_z 0 1 387 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2402 8 set_cell 0 4 3733 20 LVecBase3f::set_cell 0 1 388 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2403 5 set_x 0 4 3733 17 LVecBase3f::set_x 0 1 389 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2404 5 set_y 0 4 3733 17 LVecBase3f::set_y 0 1 390 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2405 5 set_z 0 4 3733 17 LVecBase3f::set_z 0 1 391 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2406 6 get_xy 0 4 3733 18 LVecBase3f::get_xy 0 1 392 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2407 6 get_xz 0 4 3733 18 LVecBase3f::get_xz 0 1 393 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2408 6 get_yz 0 4 3733 18 LVecBase3f::get_yz 0 1 394 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2409 11 add_to_cell 0 4 3733 23 LVecBase3f::add_to_cell 0 1 395 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2410 5 add_x 0 4 3733 17 LVecBase3f::add_x 0 1 396 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2411 5 add_y 0 4 3733 17 LVecBase3f::add_y 0 1 397 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2412 5 add_z 0 4 3733 17 LVecBase3f::add_z 0 1 398 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2413 8 get_data 0 4 3733 20 LVecBase3f::get_data 0 1 399 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2414 18 get_num_components 0 4 3733 30 LVecBase3f::get_num_components 0 1 400 0
58
static constexpr int LVecBase3f::get_num_components(void);

2415 4 fill 0 4 3733 16 LVecBase3f::fill 0 1 401 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2416 3 set 0 4 3733 15 LVecBase3f::set 0 1 402 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2417 3 dot 0 4 3733 15 LVecBase3f::dot 0 1 403 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2418 14 length_squared 0 4 3733 26 LVecBase3f::length_squared 0 1 404 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2419 6 length 0 4 3733 18 LVecBase3f::length 0 1 405 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2420 9 normalize 0 4 3733 21 LVecBase3f::normalize 0 1 406 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2421 10 normalized 0 4 3733 22 LVecBase3f::normalized 0 1 407 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2422 7 project 0 4 3733 19 LVecBase3f::project 0 1 408 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2423 5 cross 0 4 3733 17 LVecBase3f::cross 0 1 409 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2424 10 operator < 0 4 3733 22 LVecBase3f::operator < 0 1 410 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2425 11 operator == 0 4 3733 23 LVecBase3f::operator == 0 1 411 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2426 11 operator != 0 4 3733 23 LVecBase3f::operator != 0 1 412 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2427 20 get_standardized_hpr 0 4 3733 32 LVecBase3f::get_standardized_hpr 0 1 413 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2428 10 compare_to 0 4 3733 22 LVecBase3f::compare_to 0 2 414 415 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2429 8 get_hash 0 4 3733 20 LVecBase3f::get_hash 0 2 416 417 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2430 8 add_hash 0 4 3733 20 LVecBase3f::add_hash 0 2 418 419 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2431 13 generate_hash 0 4 3733 25 LVecBase3f::generate_hash 0 2 420 421 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2432 10 operator - 0 68 3733 22 LVecBase3f::operator - 0 1 422 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2433 10 operator + 0 4 3733 22 LVecBase3f::operator + 0 1 423 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2434 10 operator - 0 4 3733 22 LVecBase3f::operator - 0 1 424 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2435 10 operator * 0 4 3733 22 LVecBase3f::operator * 0 1 425 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2436 10 operator / 0 4 3733 22 LVecBase3f::operator / 0 1 426 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2437 11 operator += 0 4 3733 23 LVecBase3f::operator += 0 1 427 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2438 11 operator -= 0 4 3733 23 LVecBase3f::operator -= 0 1 428 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2439 11 operator *= 0 4 3733 23 LVecBase3f::operator *= 0 1 429 0
50
inline void LVecBase3f::operator *=(float scalar);

2440 11 operator /= 0 4 3733 23 LVecBase3f::operator /= 0 1 430 0
50
inline void LVecBase3f::operator /=(float scalar);

2441 18 componentwise_mult 0 4 3733 30 LVecBase3f::componentwise_mult 0 1 431 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2442 8 __rmul__ 0 4 3733 20 LVecBase3f::__rmul__ 0 1 432 0
74
inline PyObject *LVecBase3f::__rmul__(PyObject *self, float scalar) const;

2443 12 __floordiv__ 0 4 3733 24 LVecBase3f::__floordiv__ 0 1 433 0
78
inline PyObject *LVecBase3f::__floordiv__(PyObject *self, float scalar) const;

2444 13 __ifloordiv__ 0 4 3733 25 LVecBase3f::__ifloordiv__ 0 1 434 0
73
inline PyObject *LVecBase3f::__ifloordiv__(PyObject *self, float scalar);

2445 7 __pow__ 0 4 3733 19 LVecBase3f::__pow__ 0 1 435 0
75
inline PyObject *LVecBase3f::__pow__(PyObject *self, float exponent) const;

2446 8 __ipow__ 0 4 3733 20 LVecBase3f::__ipow__ 0 1 436 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2447 9 __round__ 0 4 3733 21 LVecBase3f::__round__ 0 1 437 0
55
inline PyObject *LVecBase3f::__round__(PyObject *self);

2448 9 __floor__ 0 4 3733 21 LVecBase3f::__floor__ 0 1 438 0
55
inline PyObject *LVecBase3f::__floor__(PyObject *self);

2449 8 __ceil__ 0 4 3733 20 LVecBase3f::__ceil__ 0 1 439 0
54
inline PyObject *LVecBase3f::__ceil__(PyObject *self);

2450 4 fmax 0 4 3733 16 LVecBase3f::fmax 0 1 440 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2451 4 fmin 0 4 3733 16 LVecBase3f::fmin 0 1 441 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2452 10 cross_into 0 4 3733 22 LVecBase3f::cross_into 0 1 442 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2453 12 almost_equal 0 4 3733 24 LVecBase3f::almost_equal 0 2 443 444 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2454 6 output 0 4 3733 18 LVecBase3f::output 0 1 445 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2455 8 __repr__ 0 4 3733 20 LVecBase3f::__repr__ 0 1 446 0
52
inline std::string LVecBase3f::__repr__(void) const;

2456 20 write_datagram_fixed 0 4 3733 32 LVecBase3f::write_datagram_fixed 0 1 447 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2457 19 read_datagram_fixed 0 4 3733 31 LVecBase3f::read_datagram_fixed 0 1 448 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2458 14 write_datagram 0 4 3733 26 LVecBase3f::write_datagram 0 1 449 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2459 13 read_datagram 0 4 3733 25 LVecBase3f::read_datagram 0 1 450 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2460 13 __getbuffer__ 0 4 3733 25 LVecBase3f::__getbuffer__ 0 1 451 0
87
inline int LVecBase3f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2461 14 get_class_type 0 4 3733 26 LVecBase3f::get_class_type 0 1 452 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2462 11 ~LVecBase3f 0 4 3733 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2463 10 LVecBase3d 0 4 3735 22 LVecBase3d::LVecBase3d 0 5 453 454 455 456 457 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2464 12 operator new 0 4 3735 24 LVecBase3d::operator new 0 1 458 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2465 15 operator delete 0 4 3735 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2466 12 validate_ptr 0 4 3735 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2467 10 operator = 0 4 3735 22 LVecBase3d::operator = 0 2 459 460 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2468 4 zero 0 4 3735 16 LVecBase3d::zero 0 1 461 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2469 6 unit_x 0 4 3735 18 LVecBase3d::unit_x 0 1 462 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2470 6 unit_y 0 4 3735 18 LVecBase3d::unit_y 0 1 463 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2471 6 unit_z 0 4 3735 18 LVecBase3d::unit_z 0 1 464 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2472 10 __reduce__ 0 4 3735 22 LVecBase3d::__reduce__ 0 1 465 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2473 11 __getattr__ 0 4 3735 23 LVecBase3d::__getattr__ 0 1 466 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2474 11 __setattr__ 0 4 3735 23 LVecBase3d::__setattr__ 0 1 467 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2475 11 operator [] 0 4 3735 23 LVecBase3d::operator [] 0 2 468 469 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2476 13 operator [] = 0 260 3735 25 LVecBase3d::operator [] = 0 1 470 0
64
void LVecBase3d::operator [] =(int i, double const &assign_val);

2477 4 size 0 4 3735 16 LVecBase3d::size 0 1 471 0
44
static constexpr int LVecBase3d::size(void);

2478 6 is_nan 0 4 3735 18 LVecBase3d::is_nan 0 1 472 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2479 8 get_cell 0 4 3735 20 LVecBase3d::get_cell 0 1 473 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2480 5 get_x 0 4 3735 17 LVecBase3d::get_x 0 1 474 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2481 5 get_y 0 4 3735 17 LVecBase3d::get_y 0 1 475 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2482 5 get_z 0 4 3735 17 LVecBase3d::get_z 0 1 476 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2483 8 set_cell 0 4 3735 20 LVecBase3d::set_cell 0 1 477 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2484 5 set_x 0 4 3735 17 LVecBase3d::set_x 0 1 478 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2485 5 set_y 0 4 3735 17 LVecBase3d::set_y 0 1 479 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2486 5 set_z 0 4 3735 17 LVecBase3d::set_z 0 1 480 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2487 6 get_xy 0 4 3735 18 LVecBase3d::get_xy 0 1 481 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2488 6 get_xz 0 4 3735 18 LVecBase3d::get_xz 0 1 482 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2489 6 get_yz 0 4 3735 18 LVecBase3d::get_yz 0 1 483 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2490 11 add_to_cell 0 4 3735 23 LVecBase3d::add_to_cell 0 1 484 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2491 5 add_x 0 4 3735 17 LVecBase3d::add_x 0 1 485 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2492 5 add_y 0 4 3735 17 LVecBase3d::add_y 0 1 486 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2493 5 add_z 0 4 3735 17 LVecBase3d::add_z 0 1 487 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2494 8 get_data 0 4 3735 20 LVecBase3d::get_data 0 1 488 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2495 18 get_num_components 0 4 3735 30 LVecBase3d::get_num_components 0 1 489 0
58
static constexpr int LVecBase3d::get_num_components(void);

2496 4 fill 0 4 3735 16 LVecBase3d::fill 0 1 490 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2497 3 set 0 4 3735 15 LVecBase3d::set 0 1 491 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2498 3 dot 0 4 3735 15 LVecBase3d::dot 0 1 492 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2499 14 length_squared 0 4 3735 26 LVecBase3d::length_squared 0 1 493 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2500 6 length 0 4 3735 18 LVecBase3d::length 0 1 494 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2501 9 normalize 0 4 3735 21 LVecBase3d::normalize 0 1 495 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2502 10 normalized 0 4 3735 22 LVecBase3d::normalized 0 1 496 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2503 7 project 0 4 3735 19 LVecBase3d::project 0 1 497 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2504 5 cross 0 4 3735 17 LVecBase3d::cross 0 1 498 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2505 10 operator < 0 4 3735 22 LVecBase3d::operator < 0 1 499 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2506 11 operator == 0 4 3735 23 LVecBase3d::operator == 0 1 500 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2507 11 operator != 0 4 3735 23 LVecBase3d::operator != 0 1 501 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2508 20 get_standardized_hpr 0 4 3735 32 LVecBase3d::get_standardized_hpr 0 1 502 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2509 10 compare_to 0 4 3735 22 LVecBase3d::compare_to 0 2 503 504 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2510 8 get_hash 0 4 3735 20 LVecBase3d::get_hash 0 2 505 506 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2511 8 add_hash 0 4 3735 20 LVecBase3d::add_hash 0 2 507 508 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2512 13 generate_hash 0 4 3735 25 LVecBase3d::generate_hash 0 2 509 510 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2513 10 operator - 0 68 3735 22 LVecBase3d::operator - 0 1 511 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2514 10 operator + 0 4 3735 22 LVecBase3d::operator + 0 1 512 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2515 10 operator - 0 4 3735 22 LVecBase3d::operator - 0 1 513 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2516 10 operator * 0 4 3735 22 LVecBase3d::operator * 0 1 514 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2517 10 operator / 0 4 3735 22 LVecBase3d::operator / 0 1 515 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2518 11 operator += 0 4 3735 23 LVecBase3d::operator += 0 1 516 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2519 11 operator -= 0 4 3735 23 LVecBase3d::operator -= 0 1 517 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2520 11 operator *= 0 4 3735 23 LVecBase3d::operator *= 0 1 518 0
51
inline void LVecBase3d::operator *=(double scalar);

2521 11 operator /= 0 4 3735 23 LVecBase3d::operator /= 0 1 519 0
51
inline void LVecBase3d::operator /=(double scalar);

2522 18 componentwise_mult 0 4 3735 30 LVecBase3d::componentwise_mult 0 1 520 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2523 8 __rmul__ 0 4 3735 20 LVecBase3d::__rmul__ 0 1 521 0
75
inline PyObject *LVecBase3d::__rmul__(PyObject *self, double scalar) const;

2524 12 __floordiv__ 0 4 3735 24 LVecBase3d::__floordiv__ 0 1 522 0
79
inline PyObject *LVecBase3d::__floordiv__(PyObject *self, double scalar) const;

2525 13 __ifloordiv__ 0 4 3735 25 LVecBase3d::__ifloordiv__ 0 1 523 0
74
inline PyObject *LVecBase3d::__ifloordiv__(PyObject *self, double scalar);

2526 7 __pow__ 0 4 3735 19 LVecBase3d::__pow__ 0 1 524 0
76
inline PyObject *LVecBase3d::__pow__(PyObject *self, double exponent) const;

2527 8 __ipow__ 0 4 3735 20 LVecBase3d::__ipow__ 0 1 525 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2528 9 __round__ 0 4 3735 21 LVecBase3d::__round__ 0 1 526 0
55
inline PyObject *LVecBase3d::__round__(PyObject *self);

2529 9 __floor__ 0 4 3735 21 LVecBase3d::__floor__ 0 1 527 0
55
inline PyObject *LVecBase3d::__floor__(PyObject *self);

2530 8 __ceil__ 0 4 3735 20 LVecBase3d::__ceil__ 0 1 528 0
54
inline PyObject *LVecBase3d::__ceil__(PyObject *self);

2531 4 fmax 0 4 3735 16 LVecBase3d::fmax 0 1 529 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2532 4 fmin 0 4 3735 16 LVecBase3d::fmin 0 1 530 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2533 10 cross_into 0 4 3735 22 LVecBase3d::cross_into 0 1 531 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2534 12 almost_equal 0 4 3735 24 LVecBase3d::almost_equal 0 2 532 533 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2535 6 output 0 4 3735 18 LVecBase3d::output 0 1 534 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2536 8 __repr__ 0 4 3735 20 LVecBase3d::__repr__ 0 1 535 0
52
inline std::string LVecBase3d::__repr__(void) const;

2537 20 write_datagram_fixed 0 4 3735 32 LVecBase3d::write_datagram_fixed 0 1 536 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2538 19 read_datagram_fixed 0 4 3735 31 LVecBase3d::read_datagram_fixed 0 1 537 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2539 14 write_datagram 0 4 3735 26 LVecBase3d::write_datagram 0 1 538 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2540 13 read_datagram 0 4 3735 25 LVecBase3d::read_datagram 0 1 539 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2541 13 __getbuffer__ 0 4 3735 25 LVecBase3d::__getbuffer__ 0 1 540 0
87
inline int LVecBase3d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2542 14 get_class_type 0 4 3735 26 LVecBase3d::get_class_type 0 1 541 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2543 11 ~LVecBase3d 0 4 3735 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2544 10 LVecBase3i 0 4 3737 22 LVecBase3i::LVecBase3i 0 5 542 543 544 545 546 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2545 12 operator new 0 4 3737 24 LVecBase3i::operator new 0 1 547 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2546 15 operator delete 0 4 3737 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2547 12 validate_ptr 0 4 3737 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2548 10 operator = 0 4 3737 22 LVecBase3i::operator = 0 2 548 549 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2549 4 zero 0 4 3737 16 LVecBase3i::zero 0 1 550 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2550 6 unit_x 0 4 3737 18 LVecBase3i::unit_x 0 1 551 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2551 6 unit_y 0 4 3737 18 LVecBase3i::unit_y 0 1 552 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2552 6 unit_z 0 4 3737 18 LVecBase3i::unit_z 0 1 553 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2553 10 __reduce__ 0 4 3737 22 LVecBase3i::__reduce__ 0 1 554 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2554 11 __getattr__ 0 4 3737 23 LVecBase3i::__getattr__ 0 1 555 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2555 11 __setattr__ 0 4 3737 23 LVecBase3i::__setattr__ 0 1 556 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2556 11 operator [] 0 4 3737 23 LVecBase3i::operator [] 0 2 557 558 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2557 13 operator [] = 0 260 3737 25 LVecBase3i::operator [] = 0 1 559 0
61
void LVecBase3i::operator [] =(int i, int const &assign_val);

2558 4 size 0 4 3737 16 LVecBase3i::size 0 1 560 0
44
static constexpr int LVecBase3i::size(void);

2559 6 is_nan 0 4 3737 18 LVecBase3i::is_nan 0 1 561 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2560 8 get_cell 0 4 3737 20 LVecBase3i::get_cell 0 1 562 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2561 5 get_x 0 4 3737 17 LVecBase3i::get_x 0 1 563 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2562 5 get_y 0 4 3737 17 LVecBase3i::get_y 0 1 564 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2563 5 get_z 0 4 3737 17 LVecBase3i::get_z 0 1 565 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2564 8 set_cell 0 4 3737 20 LVecBase3i::set_cell 0 1 566 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2565 5 set_x 0 4 3737 17 LVecBase3i::set_x 0 1 567 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2566 5 set_y 0 4 3737 17 LVecBase3i::set_y 0 1 568 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2567 5 set_z 0 4 3737 17 LVecBase3i::set_z 0 1 569 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2568 6 get_xy 0 4 3737 18 LVecBase3i::get_xy 0 1 570 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2569 6 get_xz 0 4 3737 18 LVecBase3i::get_xz 0 1 571 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2570 6 get_yz 0 4 3737 18 LVecBase3i::get_yz 0 1 572 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2571 11 add_to_cell 0 4 3737 23 LVecBase3i::add_to_cell 0 1 573 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2572 5 add_x 0 4 3737 17 LVecBase3i::add_x 0 1 574 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2573 5 add_y 0 4 3737 17 LVecBase3i::add_y 0 1 575 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2574 5 add_z 0 4 3737 17 LVecBase3i::add_z 0 1 576 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2575 8 get_data 0 4 3737 20 LVecBase3i::get_data 0 1 577 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2576 18 get_num_components 0 4 3737 30 LVecBase3i::get_num_components 0 1 578 0
58
static constexpr int LVecBase3i::get_num_components(void);

2577 4 fill 0 4 3737 16 LVecBase3i::fill 0 1 579 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2578 3 set 0 4 3737 15 LVecBase3i::set 0 1 580 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2579 3 dot 0 4 3737 15 LVecBase3i::dot 0 1 581 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2580 14 length_squared 0 4 3737 26 LVecBase3i::length_squared 0 1 582 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2581 5 cross 0 4 3737 17 LVecBase3i::cross 0 1 583 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2582 10 operator < 0 4 3737 22 LVecBase3i::operator < 0 1 584 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2583 11 operator == 0 4 3737 23 LVecBase3i::operator == 0 1 585 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2584 11 operator != 0 4 3737 23 LVecBase3i::operator != 0 1 586 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2585 10 compare_to 0 4 3737 22 LVecBase3i::compare_to 0 1 587 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2586 8 get_hash 0 4 3737 20 LVecBase3i::get_hash 0 1 588 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2587 8 add_hash 0 4 3737 20 LVecBase3i::add_hash 0 1 589 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2588 13 generate_hash 0 4 3737 25 LVecBase3i::generate_hash 0 1 590 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2589 10 operator - 0 68 3737 22 LVecBase3i::operator - 0 1 591 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2590 10 operator + 0 4 3737 22 LVecBase3i::operator + 0 1 592 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2591 10 operator - 0 4 3737 22 LVecBase3i::operator - 0 1 593 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2592 10 operator * 0 4 3737 22 LVecBase3i::operator * 0 1 594 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2593 10 operator / 0 4 3737 22 LVecBase3i::operator / 0 1 595 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2594 11 operator += 0 4 3737 23 LVecBase3i::operator += 0 1 596 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2595 11 operator -= 0 4 3737 23 LVecBase3i::operator -= 0 1 597 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2596 11 operator *= 0 4 3737 23 LVecBase3i::operator *= 0 1 598 0
48
inline void LVecBase3i::operator *=(int scalar);

2597 11 operator /= 0 4 3737 23 LVecBase3i::operator /= 0 1 599 0
48
inline void LVecBase3i::operator /=(int scalar);

2598 18 componentwise_mult 0 4 3737 30 LVecBase3i::componentwise_mult 0 1 600 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2599 8 __rmul__ 0 4 3737 20 LVecBase3i::__rmul__ 0 1 601 0
72
inline PyObject *LVecBase3i::__rmul__(PyObject *self, int scalar) const;

2600 12 __floordiv__ 0 4 3737 24 LVecBase3i::__floordiv__ 0 1 602 0
76
inline PyObject *LVecBase3i::__floordiv__(PyObject *self, int scalar) const;

2601 13 __ifloordiv__ 0 4 3737 25 LVecBase3i::__ifloordiv__ 0 1 603 0
71
inline PyObject *LVecBase3i::__ifloordiv__(PyObject *self, int scalar);

2602 7 __pow__ 0 4 3737 19 LVecBase3i::__pow__ 0 1 604 0
73
inline PyObject *LVecBase3i::__pow__(PyObject *self, int exponent) const;

2603 8 __ipow__ 0 4 3737 20 LVecBase3i::__ipow__ 0 1 605 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2604 9 __round__ 0 4 3737 21 LVecBase3i::__round__ 0 1 606 0
55
inline PyObject *LVecBase3i::__round__(PyObject *self);

2605 9 __floor__ 0 4 3737 21 LVecBase3i::__floor__ 0 1 607 0
55
inline PyObject *LVecBase3i::__floor__(PyObject *self);

2606 8 __ceil__ 0 4 3737 20 LVecBase3i::__ceil__ 0 1 608 0
54
inline PyObject *LVecBase3i::__ceil__(PyObject *self);

2607 4 fmax 0 4 3737 16 LVecBase3i::fmax 0 1 609 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2608 4 fmin 0 4 3737 16 LVecBase3i::fmin 0 1 610 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2609 10 cross_into 0 4 3737 22 LVecBase3i::cross_into 0 1 611 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2610 12 almost_equal 0 4 3737 24 LVecBase3i::almost_equal 0 2 612 613 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2611 6 output 0 4 3737 18 LVecBase3i::output 0 1 614 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2612 8 __repr__ 0 4 3737 20 LVecBase3i::__repr__ 0 1 615 0
52
inline std::string LVecBase3i::__repr__(void) const;

2613 20 write_datagram_fixed 0 4 3737 32 LVecBase3i::write_datagram_fixed 0 1 616 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2614 19 read_datagram_fixed 0 4 3737 31 LVecBase3i::read_datagram_fixed 0 1 617 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2615 14 write_datagram 0 4 3737 26 LVecBase3i::write_datagram 0 1 618 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2616 13 read_datagram 0 4 3737 25 LVecBase3i::read_datagram 0 1 619 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2617 13 __getbuffer__ 0 4 3737 25 LVecBase3i::__getbuffer__ 0 1 620 0
87
inline int LVecBase3i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2618 14 get_class_type 0 4 3737 26 LVecBase3i::get_class_type 0 1 621 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2619 11 ~LVecBase3i 0 4 3737 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2620 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1981 0
53
CoordinateSystem get_default_coordinate_system(void);

2621 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1982 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2622 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1983 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2623 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1984 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2624 9 LVector3f 0 4 3740 20 LVector3f::LVector3f 0 6 622 623 624 625 626 627 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2625 11 __getattr__ 0 4 3740 22 LVector3f::__getattr__ 0 1 628 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2626 11 __setattr__ 0 4 3740 22 LVector3f::__setattr__ 0 1 629 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2627 4 zero 0 4 3740 15 LVector3f::zero 0 1 630 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2628 6 unit_x 0 4 3740 17 LVector3f::unit_x 0 1 631 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2629 6 unit_y 0 4 3740 17 LVector3f::unit_y 0 1 632 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2630 6 unit_z 0 4 3740 17 LVector3f::unit_z 0 1 633 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2631 6 get_xy 0 4 3740 17 LVector3f::get_xy 0 1 634 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2632 6 get_xz 0 4 3740 17 LVector3f::get_xz 0 1 635 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2633 6 get_yz 0 4 3740 17 LVector3f::get_yz 0 1 636 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2634 10 operator - 0 68 3740 21 LVector3f::operator - 0 1 637 0
51
inline LVector3f LVector3f::operator -(void) const;

2635 10 operator + 0 4 3740 21 LVector3f::operator + 0 2 638 639 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2636 10 operator - 0 4 3740 21 LVector3f::operator - 0 2 640 641 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2637 5 cross 0 4 3740 16 LVector3f::cross 0 1 642 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2638 10 normalized 0 4 3740 21 LVector3f::normalized 0 1 643 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2639 7 project 0 4 3740 18 LVector3f::project 0 1 644 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2640 9 angle_rad 0 4 3740 20 LVector3f::angle_rad 0 1 645 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2641 9 angle_deg 0 4 3740 20 LVector3f::angle_deg 0 1 646 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2642 16 signed_angle_rad 0 4 3740 27 LVector3f::signed_angle_rad 0 1 647 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2643 16 signed_angle_deg 0 4 3740 27 LVector3f::signed_angle_deg 0 1 648 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2644 18 relative_angle_rad 0 4 3740 29 LVector3f::relative_angle_rad 0 1 649 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2645 18 relative_angle_deg 0 4 3740 29 LVector3f::relative_angle_deg 0 1 650 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2646 10 operator * 0 4 3740 21 LVector3f::operator * 0 1 651 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2647 10 operator / 0 4 3740 21 LVector3f::operator / 0 1 652 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2648 8 __rmul__ 0 4 3740 19 LVector3f::__rmul__ 0 1 653 0
57
inline LVector3f LVector3f::__rmul__(float scalar) const;

2649 2 up 0 4 3740 13 LVector3f::up 0 1 654 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2650 5 right 0 4 3740 16 LVector3f::right 0 1 655 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2651 7 forward 0 4 3740 18 LVector3f::forward 0 1 656 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2652 4 down 0 4 3740 15 LVector3f::down 0 1 657 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2653 4 left 0 4 3740 15 LVector3f::left 0 1 658 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2654 4 back 0 4 3740 15 LVector3f::back 0 1 659 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2655 3 rfu 0 4 3740 14 LVector3f::rfu 0 1 660 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2656 8 __repr__ 0 4 3740 19 LVector3f::__repr__ 0 1 661 0
51
inline std::string LVector3f::__repr__(void) const;

2657 14 get_class_type 0 4 3740 25 LVector3f::get_class_type 0 1 662 0
50
static TypeHandle LVector3f::get_class_type(void);

2658 10 ~LVector3f 0 4 3740 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2659 9 LVector3d 0 4 3741 20 LVector3d::LVector3d 0 6 663 664 665 666 667 668 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2660 11 __getattr__ 0 4 3741 22 LVector3d::__getattr__ 0 1 669 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2661 11 __setattr__ 0 4 3741 22 LVector3d::__setattr__ 0 1 670 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2662 4 zero 0 4 3741 15 LVector3d::zero 0 1 671 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2663 6 unit_x 0 4 3741 17 LVector3d::unit_x 0 1 672 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2664 6 unit_y 0 4 3741 17 LVector3d::unit_y 0 1 673 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2665 6 unit_z 0 4 3741 17 LVector3d::unit_z 0 1 674 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2666 6 get_xy 0 4 3741 17 LVector3d::get_xy 0 1 675 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2667 6 get_xz 0 4 3741 17 LVector3d::get_xz 0 1 676 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2668 6 get_yz 0 4 3741 17 LVector3d::get_yz 0 1 677 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2669 10 operator - 0 68 3741 21 LVector3d::operator - 0 1 678 0
51
inline LVector3d LVector3d::operator -(void) const;

2670 10 operator + 0 4 3741 21 LVector3d::operator + 0 2 679 680 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2671 10 operator - 0 4 3741 21 LVector3d::operator - 0 2 681 682 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2672 5 cross 0 4 3741 16 LVector3d::cross 0 1 683 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2673 10 normalized 0 4 3741 21 LVector3d::normalized 0 1 684 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2674 7 project 0 4 3741 18 LVector3d::project 0 1 685 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2675 9 angle_rad 0 4 3741 20 LVector3d::angle_rad 0 1 686 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2676 9 angle_deg 0 4 3741 20 LVector3d::angle_deg 0 1 687 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2677 16 signed_angle_rad 0 4 3741 27 LVector3d::signed_angle_rad 0 1 688 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2678 16 signed_angle_deg 0 4 3741 27 LVector3d::signed_angle_deg 0 1 689 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2679 18 relative_angle_rad 0 4 3741 29 LVector3d::relative_angle_rad 0 1 690 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2680 18 relative_angle_deg 0 4 3741 29 LVector3d::relative_angle_deg 0 1 691 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2681 10 operator * 0 4 3741 21 LVector3d::operator * 0 1 692 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2682 10 operator / 0 4 3741 21 LVector3d::operator / 0 1 693 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2683 8 __rmul__ 0 4 3741 19 LVector3d::__rmul__ 0 1 694 0
58
inline LVector3d LVector3d::__rmul__(double scalar) const;

2684 2 up 0 4 3741 13 LVector3d::up 0 1 695 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2685 5 right 0 4 3741 16 LVector3d::right 0 1 696 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2686 7 forward 0 4 3741 18 LVector3d::forward 0 1 697 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2687 4 down 0 4 3741 15 LVector3d::down 0 1 698 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2688 4 left 0 4 3741 15 LVector3d::left 0 1 699 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2689 4 back 0 4 3741 15 LVector3d::back 0 1 700 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2690 3 rfu 0 4 3741 14 LVector3d::rfu 0 1 701 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2691 8 __repr__ 0 4 3741 19 LVector3d::__repr__ 0 1 702 0
51
inline std::string LVector3d::__repr__(void) const;

2692 14 get_class_type 0 4 3741 25 LVector3d::get_class_type 0 1 703 0
50
static TypeHandle LVector3d::get_class_type(void);

2693 10 ~LVector3d 0 4 3741 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2694 9 LVector3i 0 4 3742 20 LVector3i::LVector3i 0 6 704 705 706 707 708 709 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2695 11 __getattr__ 0 4 3742 22 LVector3i::__getattr__ 0 1 710 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2696 11 __setattr__ 0 4 3742 22 LVector3i::__setattr__ 0 1 711 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2697 4 zero 0 4 3742 15 LVector3i::zero 0 1 712 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2698 6 unit_x 0 4 3742 17 LVector3i::unit_x 0 1 713 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2699 6 unit_y 0 4 3742 17 LVector3i::unit_y 0 1 714 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2700 6 unit_z 0 4 3742 17 LVector3i::unit_z 0 1 715 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2701 6 get_xy 0 4 3742 17 LVector3i::get_xy 0 1 716 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2702 6 get_xz 0 4 3742 17 LVector3i::get_xz 0 1 717 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2703 6 get_yz 0 4 3742 17 LVector3i::get_yz 0 1 718 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2704 10 operator - 0 68 3742 21 LVector3i::operator - 0 1 719 0
51
inline LVector3i LVector3i::operator -(void) const;

2705 10 operator + 0 4 3742 21 LVector3i::operator + 0 2 720 721 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2706 10 operator - 0 4 3742 21 LVector3i::operator - 0 2 722 723 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2707 5 cross 0 4 3742 16 LVector3i::cross 0 1 724 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2708 10 operator * 0 4 3742 21 LVector3i::operator * 0 1 725 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2709 10 operator / 0 4 3742 21 LVector3i::operator / 0 1 726 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2710 8 __rmul__ 0 4 3742 19 LVector3i::__rmul__ 0 1 727 0
55
inline LVector3i LVector3i::__rmul__(int scalar) const;

2711 2 up 0 4 3742 13 LVector3i::up 0 1 728 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2712 5 right 0 4 3742 16 LVector3i::right 0 1 729 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2713 7 forward 0 4 3742 18 LVector3i::forward 0 1 730 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2714 4 down 0 4 3742 15 LVector3i::down 0 1 731 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2715 4 left 0 4 3742 15 LVector3i::left 0 1 732 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2716 4 back 0 4 3742 15 LVector3i::back 0 1 733 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2717 3 rfu 0 4 3742 14 LVector3i::rfu 0 1 734 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2718 8 __repr__ 0 4 3742 19 LVector3i::__repr__ 0 1 735 0
51
inline std::string LVector3i::__repr__(void) const;

2719 14 get_class_type 0 4 3742 25 LVector3i::get_class_type 0 1 736 0
50
static TypeHandle LVector3i::get_class_type(void);

2720 10 ~LVector3i 0 4 3742 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2721 8 LPoint3f 0 4 3743 18 LPoint3f::LPoint3f 0 6 737 738 739 740 741 742 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2722 11 __getattr__ 0 4 3743 21 LPoint3f::__getattr__ 0 1 743 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2723 11 __setattr__ 0 4 3743 21 LPoint3f::__setattr__ 0 1 744 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2724 4 zero 0 4 3743 14 LPoint3f::zero 0 1 745 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2725 6 unit_x 0 4 3743 16 LPoint3f::unit_x 0 1 746 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2726 6 unit_y 0 4 3743 16 LPoint3f::unit_y 0 1 747 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2727 6 unit_z 0 4 3743 16 LPoint3f::unit_z 0 1 748 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2728 6 get_xy 0 4 3743 16 LPoint3f::get_xy 0 1 749 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2729 6 get_xz 0 4 3743 16 LPoint3f::get_xz 0 1 750 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2730 6 get_yz 0 4 3743 16 LPoint3f::get_yz 0 1 751 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2731 10 operator - 0 68 3743 20 LPoint3f::operator - 0 1 752 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2732 10 operator + 0 4 3743 20 LPoint3f::operator + 0 2 753 754 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2733 10 operator - 0 4 3743 20 LPoint3f::operator - 0 3 755 756 757 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2734 5 cross 0 4 3743 15 LPoint3f::cross 0 1 758 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2735 10 normalized 0 4 3743 20 LPoint3f::normalized 0 1 759 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2736 7 project 0 4 3743 17 LPoint3f::project 0 1 760 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2737 10 operator * 0 4 3743 20 LPoint3f::operator * 0 1 761 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2738 10 operator / 0 4 3743 20 LPoint3f::operator / 0 1 762 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2739 8 __rmul__ 0 4 3743 18 LPoint3f::__rmul__ 0 1 763 0
55
inline LPoint3f LPoint3f::__rmul__(float scalar) const;

2740 6 origin 0 4 3743 16 LPoint3f::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2741 3 rfu 0 4 3743 13 LPoint3f::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2742 8 __repr__ 0 4 3743 18 LPoint3f::__repr__ 0 1 766 0
50
inline std::string LPoint3f::__repr__(void) const;

2743 14 get_class_type 0 4 3743 24 LPoint3f::get_class_type 0 1 767 0
49
static TypeHandle LPoint3f::get_class_type(void);

2744 9 ~LPoint3f 0 4 3743 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2745 8 LPoint3d 0 4 3744 18 LPoint3d::LPoint3d 0 6 768 769 770 771 772 773 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2746 11 __getattr__ 0 4 3744 21 LPoint3d::__getattr__ 0 1 774 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2747 11 __setattr__ 0 4 3744 21 LPoint3d::__setattr__ 0 1 775 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2748 4 zero 0 4 3744 14 LPoint3d::zero 0 1 776 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2749 6 unit_x 0 4 3744 16 LPoint3d::unit_x 0 1 777 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2750 6 unit_y 0 4 3744 16 LPoint3d::unit_y 0 1 778 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2751 6 unit_z 0 4 3744 16 LPoint3d::unit_z 0 1 779 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2752 6 get_xy 0 4 3744 16 LPoint3d::get_xy 0 1 780 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2753 6 get_xz 0 4 3744 16 LPoint3d::get_xz 0 1 781 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2754 6 get_yz 0 4 3744 16 LPoint3d::get_yz 0 1 782 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2755 10 operator - 0 68 3744 20 LPoint3d::operator - 0 1 783 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2756 10 operator + 0 4 3744 20 LPoint3d::operator + 0 2 784 785 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2757 10 operator - 0 4 3744 20 LPoint3d::operator - 0 3 786 787 788 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2758 5 cross 0 4 3744 15 LPoint3d::cross 0 1 789 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2759 10 normalized 0 4 3744 20 LPoint3d::normalized 0 1 790 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2760 7 project 0 4 3744 17 LPoint3d::project 0 1 791 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2761 10 operator * 0 4 3744 20 LPoint3d::operator * 0 1 792 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2762 10 operator / 0 4 3744 20 LPoint3d::operator / 0 1 793 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2763 8 __rmul__ 0 4 3744 18 LPoint3d::__rmul__ 0 1 794 0
56
inline LPoint3d LPoint3d::__rmul__(double scalar) const;

2764 6 origin 0 4 3744 16 LPoint3d::origin 0 1 795 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2765 3 rfu 0 4 3744 13 LPoint3d::rfu 0 1 796 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2766 8 __repr__ 0 4 3744 18 LPoint3d::__repr__ 0 1 797 0
50
inline std::string LPoint3d::__repr__(void) const;

2767 14 get_class_type 0 4 3744 24 LPoint3d::get_class_type 0 1 798 0
49
static TypeHandle LPoint3d::get_class_type(void);

2768 9 ~LPoint3d 0 4 3744 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2769 8 LPoint3i 0 4 3745 18 LPoint3i::LPoint3i 0 6 799 800 801 802 803 804 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2770 11 __getattr__ 0 4 3745 21 LPoint3i::__getattr__ 0 1 805 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2771 11 __setattr__ 0 4 3745 21 LPoint3i::__setattr__ 0 1 806 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2772 4 zero 0 4 3745 14 LPoint3i::zero 0 1 807 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2773 6 unit_x 0 4 3745 16 LPoint3i::unit_x 0 1 808 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2774 6 unit_y 0 4 3745 16 LPoint3i::unit_y 0 1 809 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2775 6 unit_z 0 4 3745 16 LPoint3i::unit_z 0 1 810 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2776 6 get_xy 0 4 3745 16 LPoint3i::get_xy 0 1 811 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2777 6 get_xz 0 4 3745 16 LPoint3i::get_xz 0 1 812 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2778 6 get_yz 0 4 3745 16 LPoint3i::get_yz 0 1 813 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2779 10 operator - 0 68 3745 20 LPoint3i::operator - 0 1 814 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2780 10 operator + 0 4 3745 20 LPoint3i::operator + 0 2 815 816 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2781 10 operator - 0 4 3745 20 LPoint3i::operator - 0 3 817 818 819 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2782 5 cross 0 4 3745 15 LPoint3i::cross 0 1 820 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2783 10 operator * 0 4 3745 20 LPoint3i::operator * 0 1 821 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2784 10 operator / 0 4 3745 20 LPoint3i::operator / 0 1 822 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2785 8 __rmul__ 0 4 3745 18 LPoint3i::__rmul__ 0 1 823 0
53
inline LPoint3i LPoint3i::__rmul__(int scalar) const;

2786 6 origin 0 4 3745 16 LPoint3i::origin 0 1 824 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2787 3 rfu 0 4 3745 13 LPoint3i::rfu 0 1 825 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2788 8 __repr__ 0 4 3745 18 LPoint3i::__repr__ 0 1 826 0
50
inline std::string LPoint3i::__repr__(void) const;

2789 14 get_class_type 0 4 3745 24 LPoint3i::get_class_type 0 1 827 0
49
static TypeHandle LPoint3i::get_class_type(void);

2790 9 ~LPoint3i 0 4 3745 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2791 10 LVecBase4f 0 4 3746 22 LVecBase4f::LVecBase4f 0 8 828 829 830 831 832 833 834 835 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2792 12 operator new 0 4 3746 24 LVecBase4f::operator new 0 1 836 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2793 15 operator delete 0 4 3746 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2794 12 validate_ptr 0 4 3746 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2795 10 operator = 0 4 3746 22 LVecBase4f::operator = 0 2 837 838 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2796 4 zero 0 4 3746 16 LVecBase4f::zero 0 1 839 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2797 6 unit_x 0 4 3746 18 LVecBase4f::unit_x 0 1 840 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2798 6 unit_y 0 4 3746 18 LVecBase4f::unit_y 0 1 841 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2799 6 unit_z 0 4 3746 18 LVecBase4f::unit_z 0 1 842 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2800 6 unit_w 0 4 3746 18 LVecBase4f::unit_w 0 1 843 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2801 10 __reduce__ 0 4 3746 22 LVecBase4f::__reduce__ 0 1 844 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2802 11 __getattr__ 0 4 3746 23 LVecBase4f::__getattr__ 0 1 845 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2803 11 __setattr__ 0 4 3746 23 LVecBase4f::__setattr__ 0 1 846 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2804 11 operator [] 0 4 3746 23 LVecBase4f::operator [] 0 2 847 848 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2805 13 operator [] = 0 260 3746 25 LVecBase4f::operator [] = 0 1 849 0
63
void LVecBase4f::operator [] =(int i, float const &assign_val);

2806 4 size 0 4 3746 16 LVecBase4f::size 0 1 850 0
44
static constexpr int LVecBase4f::size(void);

2807 6 is_nan 0 4 3746 18 LVecBase4f::is_nan 0 1 851 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2808 8 get_cell 0 4 3746 20 LVecBase4f::get_cell 0 1 852 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2809 8 set_cell 0 4 3746 20 LVecBase4f::set_cell 0 1 853 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2810 5 get_x 0 4 3746 17 LVecBase4f::get_x 0 1 854 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2811 5 get_y 0 4 3746 17 LVecBase4f::get_y 0 1 855 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2812 5 get_z 0 4 3746 17 LVecBase4f::get_z 0 1 856 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2813 5 get_w 0 4 3746 17 LVecBase4f::get_w 0 1 857 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2814 7 get_xyz 0 4 3746 19 LVecBase4f::get_xyz 0 1 858 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2815 6 get_xy 0 4 3746 18 LVecBase4f::get_xy 0 1 859 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2816 5 set_x 0 4 3746 17 LVecBase4f::set_x 0 1 860 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2817 5 set_y 0 4 3746 17 LVecBase4f::set_y 0 1 861 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2818 5 set_z 0 4 3746 17 LVecBase4f::set_z 0 1 862 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2819 5 set_w 0 4 3746 17 LVecBase4f::set_w 0 1 863 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2820 11 add_to_cell 0 4 3746 23 LVecBase4f::add_to_cell 0 1 864 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2821 5 add_x 0 4 3746 17 LVecBase4f::add_x 0 1 865 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2822 5 add_y 0 4 3746 17 LVecBase4f::add_y 0 1 866 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2823 5 add_z 0 4 3746 17 LVecBase4f::add_z 0 1 867 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2824 5 add_w 0 4 3746 17 LVecBase4f::add_w 0 1 868 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2825 8 get_data 0 4 3746 20 LVecBase4f::get_data 0 1 869 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2826 18 get_num_components 0 4 3746 30 LVecBase4f::get_num_components 0 1 870 0
58
static constexpr int LVecBase4f::get_num_components(void);

2827 12 extract_data 0 4 3746 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2828 4 fill 0 4 3746 16 LVecBase4f::fill 0 1 871 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2829 3 set 0 4 3746 15 LVecBase4f::set 0 1 872 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2830 3 dot 0 4 3746 15 LVecBase4f::dot 0 1 873 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2831 14 length_squared 0 4 3746 26 LVecBase4f::length_squared 0 1 874 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2832 6 length 0 4 3746 18 LVecBase4f::length 0 1 875 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2833 9 normalize 0 4 3746 21 LVecBase4f::normalize 0 1 876 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2834 10 normalized 0 4 3746 22 LVecBase4f::normalized 0 1 877 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2835 7 project 0 4 3746 19 LVecBase4f::project 0 1 878 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2836 10 operator < 0 4 3746 22 LVecBase4f::operator < 0 1 879 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2837 11 operator == 0 4 3746 23 LVecBase4f::operator == 0 1 880 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2838 11 operator != 0 4 3746 23 LVecBase4f::operator != 0 1 881 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2839 10 compare_to 0 4 3746 22 LVecBase4f::compare_to 0 2 882 883 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2840 8 get_hash 0 4 3746 20 LVecBase4f::get_hash 0 2 884 885 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2841 8 add_hash 0 4 3746 20 LVecBase4f::add_hash 0 2 886 887 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2842 13 generate_hash 0 4 3746 25 LVecBase4f::generate_hash 0 2 888 889 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2843 10 operator - 0 68 3746 22 LVecBase4f::operator - 0 1 890 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2844 10 operator + 0 4 3746 22 LVecBase4f::operator + 0 1 891 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2845 10 operator - 0 4 3746 22 LVecBase4f::operator - 0 1 892 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2846 10 operator * 0 4 3746 22 LVecBase4f::operator * 0 1 893 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2847 10 operator / 0 4 3746 22 LVecBase4f::operator / 0 1 894 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2848 11 operator += 0 4 3746 23 LVecBase4f::operator += 0 1 895 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2849 11 operator -= 0 4 3746 23 LVecBase4f::operator -= 0 1 896 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2850 11 operator *= 0 4 3746 23 LVecBase4f::operator *= 0 1 897 0
50
inline void LVecBase4f::operator *=(float scalar);

2851 11 operator /= 0 4 3746 23 LVecBase4f::operator /= 0 1 898 0
50
inline void LVecBase4f::operator /=(float scalar);

2852 18 componentwise_mult 0 4 3746 30 LVecBase4f::componentwise_mult 0 1 899 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2853 8 __rmul__ 0 4 3746 20 LVecBase4f::__rmul__ 0 1 900 0
74
inline PyObject *LVecBase4f::__rmul__(PyObject *self, float scalar) const;

2854 12 __floordiv__ 0 4 3746 24 LVecBase4f::__floordiv__ 0 1 901 0
78
inline PyObject *LVecBase4f::__floordiv__(PyObject *self, float scalar) const;

2855 13 __ifloordiv__ 0 4 3746 25 LVecBase4f::__ifloordiv__ 0 1 902 0
73
inline PyObject *LVecBase4f::__ifloordiv__(PyObject *self, float scalar);

2856 7 __pow__ 0 4 3746 19 LVecBase4f::__pow__ 0 1 903 0
75
inline PyObject *LVecBase4f::__pow__(PyObject *self, float exponent) const;

2857 8 __ipow__ 0 4 3746 20 LVecBase4f::__ipow__ 0 1 904 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2858 9 __round__ 0 4 3746 21 LVecBase4f::__round__ 0 1 905 0
55
inline PyObject *LVecBase4f::__round__(PyObject *self);

2859 9 __floor__ 0 4 3746 21 LVecBase4f::__floor__ 0 1 906 0
55
inline PyObject *LVecBase4f::__floor__(PyObject *self);

2860 8 __ceil__ 0 4 3746 20 LVecBase4f::__ceil__ 0 1 907 0
54
inline PyObject *LVecBase4f::__ceil__(PyObject *self);

2861 4 fmax 0 4 3746 16 LVecBase4f::fmax 0 1 908 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2862 4 fmin 0 4 3746 16 LVecBase4f::fmin 0 1 909 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2863 12 almost_equal 0 4 3746 24 LVecBase4f::almost_equal 0 2 910 911 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2864 6 output 0 4 3746 18 LVecBase4f::output 0 1 912 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2865 8 __repr__ 0 4 3746 20 LVecBase4f::__repr__ 0 1 913 0
52
inline std::string LVecBase4f::__repr__(void) const;

2866 20 write_datagram_fixed 0 4 3746 32 LVecBase4f::write_datagram_fixed 0 1 914 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2867 19 read_datagram_fixed 0 4 3746 31 LVecBase4f::read_datagram_fixed 0 1 915 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2868 14 write_datagram 0 4 3746 26 LVecBase4f::write_datagram 0 1 916 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2869 13 read_datagram 0 4 3746 25 LVecBase4f::read_datagram 0 1 917 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2870 13 __getbuffer__ 0 4 3746 25 LVecBase4f::__getbuffer__ 0 1 918 0
87
inline int LVecBase4f::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2871 14 get_class_type 0 4 3746 26 LVecBase4f::get_class_type 0 1 919 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2872 11 ~LVecBase4f 0 4 3746 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2873 19 UnalignedLVecBase4f 0 4 3748 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 920 921 922 923 924 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2874 4 fill 0 4 3748 25 UnalignedLVecBase4f::fill 0 1 925 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2875 3 set 0 4 3748 24 UnalignedLVecBase4f::set 0 1 926 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2876 11 operator [] 0 4 3748 32 UnalignedLVecBase4f::operator [] 0 2 927 928 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2877 13 operator [] = 0 260 3748 34 UnalignedLVecBase4f::operator [] = 0 1 929 0
72
void UnalignedLVecBase4f::operator [] =(int i, float const &assign_val);

2878 4 size 0 4 3748 25 UnalignedLVecBase4f::size 0 1 930 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2879 8 get_data 0 4 3748 29 UnalignedLVecBase4f::get_data 0 1 931 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2880 18 get_num_components 0 4 3748 39 UnalignedLVecBase4f::get_num_components 0 1 932 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2881 11 operator == 0 4 3748 32 UnalignedLVecBase4f::operator == 0 1 933 0
85
inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &other) const;

2882 11 operator != 0 4 3748 32 UnalignedLVecBase4f::operator != 0 1 934 0
85
inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &other) const;

2883 14 get_class_type 0 4 3748 35 UnalignedLVecBase4f::get_class_type 0 1 935 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2884 20 ~UnalignedLVecBase4f 0 4 3748 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2885 10 LVecBase4d 0 4 3750 22 LVecBase4d::LVecBase4d 0 8 936 937 938 939 940 941 942 943 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2886 12 operator new 0 4 3750 24 LVecBase4d::operator new 0 1 944 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2887 15 operator delete 0 4 3750 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2888 12 validate_ptr 0 4 3750 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2889 10 operator = 0 4 3750 22 LVecBase4d::operator = 0 2 945 946 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2890 4 zero 0 4 3750 16 LVecBase4d::zero 0 1 947 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2891 6 unit_x 0 4 3750 18 LVecBase4d::unit_x 0 1 948 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2892 6 unit_y 0 4 3750 18 LVecBase4d::unit_y 0 1 949 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2893 6 unit_z 0 4 3750 18 LVecBase4d::unit_z 0 1 950 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2894 6 unit_w 0 4 3750 18 LVecBase4d::unit_w 0 1 951 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2895 10 __reduce__ 0 4 3750 22 LVecBase4d::__reduce__ 0 1 952 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2896 11 __getattr__ 0 4 3750 23 LVecBase4d::__getattr__ 0 1 953 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2897 11 __setattr__ 0 4 3750 23 LVecBase4d::__setattr__ 0 1 954 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2898 11 operator [] 0 4 3750 23 LVecBase4d::operator [] 0 2 955 956 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2899 13 operator [] = 0 260 3750 25 LVecBase4d::operator [] = 0 1 957 0
64
void LVecBase4d::operator [] =(int i, double const &assign_val);

2900 4 size 0 4 3750 16 LVecBase4d::size 0 1 958 0
44
static constexpr int LVecBase4d::size(void);

2901 6 is_nan 0 4 3750 18 LVecBase4d::is_nan 0 1 959 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2902 8 get_cell 0 4 3750 20 LVecBase4d::get_cell 0 1 960 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2903 8 set_cell 0 4 3750 20 LVecBase4d::set_cell 0 1 961 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2904 5 get_x 0 4 3750 17 LVecBase4d::get_x 0 1 962 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2905 5 get_y 0 4 3750 17 LVecBase4d::get_y 0 1 963 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2906 5 get_z 0 4 3750 17 LVecBase4d::get_z 0 1 964 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2907 5 get_w 0 4 3750 17 LVecBase4d::get_w 0 1 965 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2908 7 get_xyz 0 4 3750 19 LVecBase4d::get_xyz 0 1 966 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2909 6 get_xy 0 4 3750 18 LVecBase4d::get_xy 0 1 967 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2910 5 set_x 0 4 3750 17 LVecBase4d::set_x 0 1 968 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2911 5 set_y 0 4 3750 17 LVecBase4d::set_y 0 1 969 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2912 5 set_z 0 4 3750 17 LVecBase4d::set_z 0 1 970 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2913 5 set_w 0 4 3750 17 LVecBase4d::set_w 0 1 971 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2914 11 add_to_cell 0 4 3750 23 LVecBase4d::add_to_cell 0 1 972 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2915 5 add_x 0 4 3750 17 LVecBase4d::add_x 0 1 973 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2916 5 add_y 0 4 3750 17 LVecBase4d::add_y 0 1 974 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2917 5 add_z 0 4 3750 17 LVecBase4d::add_z 0 1 975 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2918 5 add_w 0 4 3750 17 LVecBase4d::add_w 0 1 976 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2919 8 get_data 0 4 3750 20 LVecBase4d::get_data 0 1 977 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2920 18 get_num_components 0 4 3750 30 LVecBase4d::get_num_components 0 1 978 0
58
static constexpr int LVecBase4d::get_num_components(void);

2921 12 extract_data 0 4 3750 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2922 4 fill 0 4 3750 16 LVecBase4d::fill 0 1 979 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2923 3 set 0 4 3750 15 LVecBase4d::set 0 1 980 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2924 3 dot 0 4 3750 15 LVecBase4d::dot 0 1 981 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2925 14 length_squared 0 4 3750 26 LVecBase4d::length_squared 0 1 982 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2926 6 length 0 4 3750 18 LVecBase4d::length 0 1 983 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2927 9 normalize 0 4 3750 21 LVecBase4d::normalize 0 1 984 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2928 10 normalized 0 4 3750 22 LVecBase4d::normalized 0 1 985 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2929 7 project 0 4 3750 19 LVecBase4d::project 0 1 986 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2930 10 operator < 0 4 3750 22 LVecBase4d::operator < 0 1 987 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2931 11 operator == 0 4 3750 23 LVecBase4d::operator == 0 1 988 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2932 11 operator != 0 4 3750 23 LVecBase4d::operator != 0 1 989 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2933 10 compare_to 0 4 3750 22 LVecBase4d::compare_to 0 2 990 991 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2934 8 get_hash 0 4 3750 20 LVecBase4d::get_hash 0 2 992 993 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2935 8 add_hash 0 4 3750 20 LVecBase4d::add_hash 0 2 994 995 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2936 13 generate_hash 0 4 3750 25 LVecBase4d::generate_hash 0 2 996 997 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2937 10 operator - 0 68 3750 22 LVecBase4d::operator - 0 1 998 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2938 10 operator + 0 4 3750 22 LVecBase4d::operator + 0 1 999 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2939 10 operator - 0 4 3750 22 LVecBase4d::operator - 0 1 1000 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2940 10 operator * 0 4 3750 22 LVecBase4d::operator * 0 1 1001 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2941 10 operator / 0 4 3750 22 LVecBase4d::operator / 0 1 1002 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2942 11 operator += 0 4 3750 23 LVecBase4d::operator += 0 1 1003 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2943 11 operator -= 0 4 3750 23 LVecBase4d::operator -= 0 1 1004 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2944 11 operator *= 0 4 3750 23 LVecBase4d::operator *= 0 1 1005 0
51
inline void LVecBase4d::operator *=(double scalar);

2945 11 operator /= 0 4 3750 23 LVecBase4d::operator /= 0 1 1006 0
51
inline void LVecBase4d::operator /=(double scalar);

2946 18 componentwise_mult 0 4 3750 30 LVecBase4d::componentwise_mult 0 1 1007 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2947 8 __rmul__ 0 4 3750 20 LVecBase4d::__rmul__ 0 1 1008 0
75
inline PyObject *LVecBase4d::__rmul__(PyObject *self, double scalar) const;

2948 12 __floordiv__ 0 4 3750 24 LVecBase4d::__floordiv__ 0 1 1009 0
79
inline PyObject *LVecBase4d::__floordiv__(PyObject *self, double scalar) const;

2949 13 __ifloordiv__ 0 4 3750 25 LVecBase4d::__ifloordiv__ 0 1 1010 0
74
inline PyObject *LVecBase4d::__ifloordiv__(PyObject *self, double scalar);

2950 7 __pow__ 0 4 3750 19 LVecBase4d::__pow__ 0 1 1011 0
76
inline PyObject *LVecBase4d::__pow__(PyObject *self, double exponent) const;

2951 8 __ipow__ 0 4 3750 20 LVecBase4d::__ipow__ 0 1 1012 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2952 9 __round__ 0 4 3750 21 LVecBase4d::__round__ 0 1 1013 0
55
inline PyObject *LVecBase4d::__round__(PyObject *self);

2953 9 __floor__ 0 4 3750 21 LVecBase4d::__floor__ 0 1 1014 0
55
inline PyObject *LVecBase4d::__floor__(PyObject *self);

2954 8 __ceil__ 0 4 3750 20 LVecBase4d::__ceil__ 0 1 1015 0
54
inline PyObject *LVecBase4d::__ceil__(PyObject *self);

2955 4 fmax 0 4 3750 16 LVecBase4d::fmax 0 1 1016 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2956 4 fmin 0 4 3750 16 LVecBase4d::fmin 0 1 1017 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2957 12 almost_equal 0 4 3750 24 LVecBase4d::almost_equal 0 2 1018 1019 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2958 6 output 0 4 3750 18 LVecBase4d::output 0 1 1020 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2959 8 __repr__ 0 4 3750 20 LVecBase4d::__repr__ 0 1 1021 0
52
inline std::string LVecBase4d::__repr__(void) const;

2960 20 write_datagram_fixed 0 4 3750 32 LVecBase4d::write_datagram_fixed 0 1 1022 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2961 19 read_datagram_fixed 0 4 3750 31 LVecBase4d::read_datagram_fixed 0 1 1023 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2962 14 write_datagram 0 4 3750 26 LVecBase4d::write_datagram 0 1 1024 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2963 13 read_datagram 0 4 3750 25 LVecBase4d::read_datagram 0 1 1025 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2964 13 __getbuffer__ 0 4 3750 25 LVecBase4d::__getbuffer__ 0 1 1026 0
87
inline int LVecBase4d::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

2965 14 get_class_type 0 4 3750 26 LVecBase4d::get_class_type 0 1 1027 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2966 11 ~LVecBase4d 0 4 3750 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2967 19 UnalignedLVecBase4d 0 4 3752 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 1028 1029 1030 1031 1032 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2968 4 fill 0 4 3752 25 UnalignedLVecBase4d::fill 0 1 1033 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2969 3 set 0 4 3752 24 UnalignedLVecBase4d::set 0 1 1034 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2970 11 operator [] 0 4 3752 32 UnalignedLVecBase4d::operator [] 0 2 1035 1036 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2971 13 operator [] = 0 260 3752 34 UnalignedLVecBase4d::operator [] = 0 1 1037 0
73
void UnalignedLVecBase4d::operator [] =(int i, double const &assign_val);

2972 4 size 0 4 3752 25 UnalignedLVecBase4d::size 0 1 1038 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2973 8 get_data 0 4 3752 29 UnalignedLVecBase4d::get_data 0 1 1039 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2974 18 get_num_components 0 4 3752 39 UnalignedLVecBase4d::get_num_components 0 1 1040 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2975 11 operator == 0 4 3752 32 UnalignedLVecBase4d::operator == 0 1 1041 0
85
inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &other) const;

2976 11 operator != 0 4 3752 32 UnalignedLVecBase4d::operator != 0 1 1042 0
85
inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &other) const;

2977 14 get_class_type 0 4 3752 35 UnalignedLVecBase4d::get_class_type 0 1 1043 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2978 20 ~UnalignedLVecBase4d 0 4 3752 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2979 10 LVecBase4i 0 4 3754 22 LVecBase4i::LVecBase4i 0 8 1044 1045 1046 1047 1048 1049 1050 1051 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2980 12 operator new 0 4 3754 24 LVecBase4i::operator new 0 1 1052 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2981 15 operator delete 0 4 3754 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2982 12 validate_ptr 0 4 3754 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2983 10 operator = 0 4 3754 22 LVecBase4i::operator = 0 2 1053 1054 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2984 4 zero 0 4 3754 16 LVecBase4i::zero 0 1 1055 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2985 6 unit_x 0 4 3754 18 LVecBase4i::unit_x 0 1 1056 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2986 6 unit_y 0 4 3754 18 LVecBase4i::unit_y 0 1 1057 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2987 6 unit_z 0 4 3754 18 LVecBase4i::unit_z 0 1 1058 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2988 6 unit_w 0 4 3754 18 LVecBase4i::unit_w 0 1 1059 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2989 10 __reduce__ 0 4 3754 22 LVecBase4i::__reduce__ 0 1 1060 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2990 11 __getattr__ 0 4 3754 23 LVecBase4i::__getattr__ 0 1 1061 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2991 11 __setattr__ 0 4 3754 23 LVecBase4i::__setattr__ 0 1 1062 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2992 11 operator [] 0 4 3754 23 LVecBase4i::operator [] 0 2 1063 1064 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2993 13 operator [] = 0 260 3754 25 LVecBase4i::operator [] = 0 1 1065 0
61
void LVecBase4i::operator [] =(int i, int const &assign_val);

2994 4 size 0 4 3754 16 LVecBase4i::size 0 1 1066 0
44
static constexpr int LVecBase4i::size(void);

2995 6 is_nan 0 4 3754 18 LVecBase4i::is_nan 0 1 1067 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2996 8 get_cell 0 4 3754 20 LVecBase4i::get_cell 0 1 1068 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2997 8 set_cell 0 4 3754 20 LVecBase4i::set_cell 0 1 1069 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2998 5 get_x 0 4 3754 17 LVecBase4i::get_x 0 1 1070 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2999 5 get_y 0 4 3754 17 LVecBase4i::get_y 0 1 1071 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

3000 5 get_z 0 4 3754 17 LVecBase4i::get_z 0 1 1072 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

3001 5 get_w 0 4 3754 17 LVecBase4i::get_w 0 1 1073 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

3002 7 get_xyz 0 4 3754 19 LVecBase4i::get_xyz 0 1 1074 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

3003 6 get_xy 0 4 3754 18 LVecBase4i::get_xy 0 1 1075 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

3004 5 set_x 0 4 3754 17 LVecBase4i::set_x 0 1 1076 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

3005 5 set_y 0 4 3754 17 LVecBase4i::set_y 0 1 1077 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

3006 5 set_z 0 4 3754 17 LVecBase4i::set_z 0 1 1078 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

3007 5 set_w 0 4 3754 17 LVecBase4i::set_w 0 1 1079 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

3008 11 add_to_cell 0 4 3754 23 LVecBase4i::add_to_cell 0 1 1080 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

3009 5 add_x 0 4 3754 17 LVecBase4i::add_x 0 1 1081 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

3010 5 add_y 0 4 3754 17 LVecBase4i::add_y 0 1 1082 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

3011 5 add_z 0 4 3754 17 LVecBase4i::add_z 0 1 1083 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

3012 5 add_w 0 4 3754 17 LVecBase4i::add_w 0 1 1084 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

3013 8 get_data 0 4 3754 20 LVecBase4i::get_data 0 1 1085 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

3014 18 get_num_components 0 4 3754 30 LVecBase4i::get_num_components 0 1 1086 0
58
static constexpr int LVecBase4i::get_num_components(void);

3015 12 extract_data 0 4 3754 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

3016 4 fill 0 4 3754 16 LVecBase4i::fill 0 1 1087 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

3017 3 set 0 4 3754 15 LVecBase4i::set 0 1 1088 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

3018 3 dot 0 4 3754 15 LVecBase4i::dot 0 1 1089 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

3019 14 length_squared 0 4 3754 26 LVecBase4i::length_squared 0 1 1090 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

3020 10 operator < 0 4 3754 22 LVecBase4i::operator < 0 1 1091 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

3021 11 operator == 0 4 3754 23 LVecBase4i::operator == 0 1 1092 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

3022 11 operator != 0 4 3754 23 LVecBase4i::operator != 0 1 1093 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

3023 10 compare_to 0 4 3754 22 LVecBase4i::compare_to 0 1 1094 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

3024 8 get_hash 0 4 3754 20 LVecBase4i::get_hash 0 1 1095 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

3025 8 add_hash 0 4 3754 20 LVecBase4i::add_hash 0 1 1096 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

3026 13 generate_hash 0 4 3754 25 LVecBase4i::generate_hash 0 1 1097 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

3027 10 operator - 0 68 3754 22 LVecBase4i::operator - 0 1 1098 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

3028 10 operator + 0 4 3754 22 LVecBase4i::operator + 0 1 1099 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

3029 10 operator - 0 4 3754 22 LVecBase4i::operator - 0 1 1100 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

3030 10 operator * 0 4 3754 22 LVecBase4i::operator * 0 1 1101 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

3031 10 operator / 0 4 3754 22 LVecBase4i::operator / 0 1 1102 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

3032 11 operator += 0 4 3754 23 LVecBase4i::operator += 0 1 1103 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

3033 11 operator -= 0 4 3754 23 LVecBase4i::operator -= 0 1 1104 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

3034 11 operator *= 0 4 3754 23 LVecBase4i::operator *= 0 1 1105 0
48
inline void LVecBase4i::operator *=(int scalar);

3035 11 operator /= 0 4 3754 23 LVecBase4i::operator /= 0 1 1106 0
48
inline void LVecBase4i::operator /=(int scalar);

3036 18 componentwise_mult 0 4 3754 30 LVecBase4i::componentwise_mult 0 1 1107 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

3037 8 __rmul__ 0 4 3754 20 LVecBase4i::__rmul__ 0 1 1108 0
72
inline PyObject *LVecBase4i::__rmul__(PyObject *self, int scalar) const;

3038 12 __floordiv__ 0 4 3754 24 LVecBase4i::__floordiv__ 0 1 1109 0
76
inline PyObject *LVecBase4i::__floordiv__(PyObject *self, int scalar) const;

3039 13 __ifloordiv__ 0 4 3754 25 LVecBase4i::__ifloordiv__ 0 1 1110 0
71
inline PyObject *LVecBase4i::__ifloordiv__(PyObject *self, int scalar);

3040 7 __pow__ 0 4 3754 19 LVecBase4i::__pow__ 0 1 1111 0
73
inline PyObject *LVecBase4i::__pow__(PyObject *self, int exponent) const;

3041 8 __ipow__ 0 4 3754 20 LVecBase4i::__ipow__ 0 1 1112 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

3042 9 __round__ 0 4 3754 21 LVecBase4i::__round__ 0 1 1113 0
55
inline PyObject *LVecBase4i::__round__(PyObject *self);

3043 9 __floor__ 0 4 3754 21 LVecBase4i::__floor__ 0 1 1114 0
55
inline PyObject *LVecBase4i::__floor__(PyObject *self);

3044 8 __ceil__ 0 4 3754 20 LVecBase4i::__ceil__ 0 1 1115 0
54
inline PyObject *LVecBase4i::__ceil__(PyObject *self);

3045 4 fmax 0 4 3754 16 LVecBase4i::fmax 0 1 1116 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

3046 4 fmin 0 4 3754 16 LVecBase4i::fmin 0 1 1117 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

3047 12 almost_equal 0 4 3754 24 LVecBase4i::almost_equal 0 2 1118 1119 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

3048 6 output 0 4 3754 18 LVecBase4i::output 0 1 1120 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

3049 8 __repr__ 0 4 3754 20 LVecBase4i::__repr__ 0 1 1121 0
52
inline std::string LVecBase4i::__repr__(void) const;

3050 20 write_datagram_fixed 0 4 3754 32 LVecBase4i::write_datagram_fixed 0 1 1122 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

3051 19 read_datagram_fixed 0 4 3754 31 LVecBase4i::read_datagram_fixed 0 1 1123 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

3052 14 write_datagram 0 4 3754 26 LVecBase4i::write_datagram 0 1 1124 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

3053 13 read_datagram 0 4 3754 25 LVecBase4i::read_datagram 0 1 1125 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

3054 13 __getbuffer__ 0 4 3754 25 LVecBase4i::__getbuffer__ 0 1 1126 0
87
inline int LVecBase4i::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

3055 14 get_class_type 0 4 3754 26 LVecBase4i::get_class_type 0 1 1127 0
51
static TypeHandle LVecBase4i::get_class_type(void);

3056 11 ~LVecBase4i 0 4 3754 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

3057 19 UnalignedLVecBase4i 0 4 3756 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1128 1129 1130 1131 1132 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

3058 4 fill 0 4 3756 25 UnalignedLVecBase4i::fill 0 1 1133 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

3059 3 set 0 4 3756 24 UnalignedLVecBase4i::set 0 1 1134 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

3060 11 operator [] 0 4 3756 32 UnalignedLVecBase4i::operator [] 0 2 1135 1136 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

3061 13 operator [] = 0 260 3756 34 UnalignedLVecBase4i::operator [] = 0 1 1137 0
70
void UnalignedLVecBase4i::operator [] =(int i, int const &assign_val);

3062 4 size 0 4 3756 25 UnalignedLVecBase4i::size 0 1 1138 0
53
static constexpr int UnalignedLVecBase4i::size(void);

3063 8 get_data 0 4 3756 29 UnalignedLVecBase4i::get_data 0 1 1139 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

3064 18 get_num_components 0 4 3756 39 UnalignedLVecBase4i::get_num_components 0 1 1140 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

3065 11 operator == 0 4 3756 32 UnalignedLVecBase4i::operator == 0 1 1141 0
85
inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &other) const;

3066 11 operator != 0 4 3756 32 UnalignedLVecBase4i::operator != 0 1 1142 0
85
inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &other) const;

3067 14 get_class_type 0 4 3756 35 UnalignedLVecBase4i::get_class_type 0 1 1143 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

3068 20 ~UnalignedLVecBase4i 0 4 3756 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

3069 9 LVector4f 0 4 3758 20 LVector4f::LVector4f 0 6 1144 1145 1146 1147 1148 1149 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

3070 11 __getattr__ 0 4 3758 22 LVector4f::__getattr__ 0 1 1150 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

3071 11 __setattr__ 0 4 3758 22 LVector4f::__setattr__ 0 1 1151 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3072 4 zero 0 4 3758 15 LVector4f::zero 0 1 1152 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

3073 6 unit_x 0 4 3758 17 LVector4f::unit_x 0 1 1153 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

3074 6 unit_y 0 4 3758 17 LVector4f::unit_y 0 1 1154 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

3075 6 unit_z 0 4 3758 17 LVector4f::unit_z 0 1 1155 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

3076 6 unit_w 0 4 3758 17 LVector4f::unit_w 0 1 1156 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

3077 7 get_xyz 0 4 3758 18 LVector4f::get_xyz 0 1 1157 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

3078 6 get_xy 0 4 3758 17 LVector4f::get_xy 0 1 1158 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

3079 10 operator - 0 68 3758 21 LVector4f::operator - 0 1 1159 0
51
inline LVector4f LVector4f::operator -(void) const;

3080 10 operator + 0 4 3758 21 LVector4f::operator + 0 2 1160 1161 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

3081 10 operator - 0 4 3758 21 LVector4f::operator - 0 2 1162 1163 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

3082 10 operator * 0 4 3758 21 LVector4f::operator * 0 1 1164 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

3083 10 operator / 0 4 3758 21 LVector4f::operator / 0 1 1165 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

3084 8 __rmul__ 0 4 3758 19 LVector4f::__rmul__ 0 1 1166 0
57
inline LVector4f LVector4f::__rmul__(float scalar) const;

3085 10 normalized 0 4 3758 21 LVector4f::normalized 0 1 1167 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

3086 7 project 0 4 3758 18 LVector4f::project 0 1 1168 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

3087 8 __repr__ 0 4 3758 19 LVector4f::__repr__ 0 1 1169 0
51
inline std::string LVector4f::__repr__(void) const;

3088 14 get_class_type 0 4 3758 25 LVector4f::get_class_type 0 1 1170 0
50
static TypeHandle LVector4f::get_class_type(void);

3089 10 ~LVector4f 0 4 3758 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

3090 9 LVector4d 0 4 3759 20 LVector4d::LVector4d 0 6 1171 1172 1173 1174 1175 1176 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

3091 11 __getattr__ 0 4 3759 22 LVector4d::__getattr__ 0 1 1177 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

3092 11 __setattr__ 0 4 3759 22 LVector4d::__setattr__ 0 1 1178 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3093 4 zero 0 4 3759 15 LVector4d::zero 0 1 1179 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

3094 6 unit_x 0 4 3759 17 LVector4d::unit_x 0 1 1180 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

3095 6 unit_y 0 4 3759 17 LVector4d::unit_y 0 1 1181 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

3096 6 unit_z 0 4 3759 17 LVector4d::unit_z 0 1 1182 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

3097 6 unit_w 0 4 3759 17 LVector4d::unit_w 0 1 1183 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

3098 7 get_xyz 0 4 3759 18 LVector4d::get_xyz 0 1 1184 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

3099 6 get_xy 0 4 3759 17 LVector4d::get_xy 0 1 1185 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

3100 10 operator - 0 68 3759 21 LVector4d::operator - 0 1 1186 0
51
inline LVector4d LVector4d::operator -(void) const;

3101 10 operator + 0 4 3759 21 LVector4d::operator + 0 2 1187 1188 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

3102 10 operator - 0 4 3759 21 LVector4d::operator - 0 2 1189 1190 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

3103 10 operator * 0 4 3759 21 LVector4d::operator * 0 1 1191 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

3104 10 operator / 0 4 3759 21 LVector4d::operator / 0 1 1192 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

3105 8 __rmul__ 0 4 3759 19 LVector4d::__rmul__ 0 1 1193 0
58
inline LVector4d LVector4d::__rmul__(double scalar) const;

3106 10 normalized 0 4 3759 21 LVector4d::normalized 0 1 1194 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

3107 7 project 0 4 3759 18 LVector4d::project 0 1 1195 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

3108 8 __repr__ 0 4 3759 19 LVector4d::__repr__ 0 1 1196 0
51
inline std::string LVector4d::__repr__(void) const;

3109 14 get_class_type 0 4 3759 25 LVector4d::get_class_type 0 1 1197 0
50
static TypeHandle LVector4d::get_class_type(void);

3110 10 ~LVector4d 0 4 3759 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

3111 9 LVector4i 0 4 3760 20 LVector4i::LVector4i 0 6 1198 1199 1200 1201 1202 1203 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

3112 11 __getattr__ 0 4 3760 22 LVector4i::__getattr__ 0 1 1204 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3113 11 __setattr__ 0 4 3760 22 LVector4i::__setattr__ 0 1 1205 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3114 4 zero 0 4 3760 15 LVector4i::zero 0 1 1206 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

3115 6 unit_x 0 4 3760 17 LVector4i::unit_x 0 1 1207 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

3116 6 unit_y 0 4 3760 17 LVector4i::unit_y 0 1 1208 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

3117 6 unit_z 0 4 3760 17 LVector4i::unit_z 0 1 1209 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

3118 6 unit_w 0 4 3760 17 LVector4i::unit_w 0 1 1210 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

3119 7 get_xyz 0 4 3760 18 LVector4i::get_xyz 0 1 1211 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

3120 6 get_xy 0 4 3760 17 LVector4i::get_xy 0 1 1212 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

3121 10 operator - 0 68 3760 21 LVector4i::operator - 0 1 1213 0
51
inline LVector4i LVector4i::operator -(void) const;

3122 10 operator + 0 4 3760 21 LVector4i::operator + 0 2 1214 1215 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

3123 10 operator - 0 4 3760 21 LVector4i::operator - 0 2 1216 1217 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

3124 10 operator * 0 4 3760 21 LVector4i::operator * 0 1 1218 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

3125 10 operator / 0 4 3760 21 LVector4i::operator / 0 1 1219 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

3126 8 __rmul__ 0 4 3760 19 LVector4i::__rmul__ 0 1 1220 0
55
inline LVector4i LVector4i::__rmul__(int scalar) const;

3127 8 __repr__ 0 4 3760 19 LVector4i::__repr__ 0 1 1221 0
51
inline std::string LVector4i::__repr__(void) const;

3128 14 get_class_type 0 4 3760 25 LVector4i::get_class_type 0 1 1222 0
50
static TypeHandle LVector4i::get_class_type(void);

3129 10 ~LVector4i 0 4 3760 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

3130 8 LPoint4f 0 4 3761 18 LPoint4f::LPoint4f 0 6 1223 1224 1225 1226 1227 1228 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

3131 11 __getattr__ 0 4 3761 21 LPoint4f::__getattr__ 0 1 1229 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

3132 11 __setattr__ 0 4 3761 21 LPoint4f::__setattr__ 0 1 1230 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3133 4 zero 0 4 3761 14 LPoint4f::zero 0 1 1231 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

3134 6 unit_x 0 4 3761 16 LPoint4f::unit_x 0 1 1232 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

3135 6 unit_y 0 4 3761 16 LPoint4f::unit_y 0 1 1233 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

3136 6 unit_z 0 4 3761 16 LPoint4f::unit_z 0 1 1234 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

3137 6 unit_w 0 4 3761 16 LPoint4f::unit_w 0 1 1235 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

3138 7 get_xyz 0 4 3761 17 LPoint4f::get_xyz 0 1 1236 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

3139 6 get_xy 0 4 3761 16 LPoint4f::get_xy 0 1 1237 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

3140 10 operator - 0 68 3761 20 LPoint4f::operator - 0 1 1238 0
49
inline LPoint4f LPoint4f::operator -(void) const;

3141 10 operator + 0 4 3761 20 LPoint4f::operator + 0 2 1239 1240 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

3142 10 operator - 0 4 3761 20 LPoint4f::operator - 0 3 1241 1242 1243 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

3143 10 operator * 0 4 3761 20 LPoint4f::operator * 0 1 1244 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

3144 10 operator / 0 4 3761 20 LPoint4f::operator / 0 1 1245 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

3145 8 __rmul__ 0 4 3761 18 LPoint4f::__rmul__ 0 1 1246 0
55
inline LPoint4f LPoint4f::__rmul__(float scalar) const;

3146 10 normalized 0 4 3761 20 LPoint4f::normalized 0 1 1247 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

3147 7 project 0 4 3761 17 LPoint4f::project 0 1 1248 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

3148 8 __repr__ 0 4 3761 18 LPoint4f::__repr__ 0 1 1249 0
50
inline std::string LPoint4f::__repr__(void) const;

3149 14 get_class_type 0 4 3761 24 LPoint4f::get_class_type 0 1 1250 0
49
static TypeHandle LPoint4f::get_class_type(void);

3150 9 ~LPoint4f 0 4 3761 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

3151 8 LPoint4d 0 4 3762 18 LPoint4d::LPoint4d 0 6 1251 1252 1253 1254 1255 1256 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

3152 11 __getattr__ 0 4 3762 21 LPoint4d::__getattr__ 0 1 1257 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

3153 11 __setattr__ 0 4 3762 21 LPoint4d::__setattr__ 0 1 1258 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3154 4 zero 0 4 3762 14 LPoint4d::zero 0 1 1259 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

3155 6 unit_x 0 4 3762 16 LPoint4d::unit_x 0 1 1260 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

3156 6 unit_y 0 4 3762 16 LPoint4d::unit_y 0 1 1261 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

3157 6 unit_z 0 4 3762 16 LPoint4d::unit_z 0 1 1262 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

3158 6 unit_w 0 4 3762 16 LPoint4d::unit_w 0 1 1263 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

3159 7 get_xyz 0 4 3762 17 LPoint4d::get_xyz 0 1 1264 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

3160 6 get_xy 0 4 3762 16 LPoint4d::get_xy 0 1 1265 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

3161 10 operator - 0 68 3762 20 LPoint4d::operator - 0 1 1266 0
49
inline LPoint4d LPoint4d::operator -(void) const;

3162 10 operator + 0 4 3762 20 LPoint4d::operator + 0 2 1267 1268 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

3163 10 operator - 0 4 3762 20 LPoint4d::operator - 0 3 1269 1270 1271 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

3164 10 operator * 0 4 3762 20 LPoint4d::operator * 0 1 1272 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

3165 10 operator / 0 4 3762 20 LPoint4d::operator / 0 1 1273 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

3166 8 __rmul__ 0 4 3762 18 LPoint4d::__rmul__ 0 1 1274 0
56
inline LPoint4d LPoint4d::__rmul__(double scalar) const;

3167 10 normalized 0 4 3762 20 LPoint4d::normalized 0 1 1275 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

3168 7 project 0 4 3762 17 LPoint4d::project 0 1 1276 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

3169 8 __repr__ 0 4 3762 18 LPoint4d::__repr__ 0 1 1277 0
50
inline std::string LPoint4d::__repr__(void) const;

3170 14 get_class_type 0 4 3762 24 LPoint4d::get_class_type 0 1 1278 0
49
static TypeHandle LPoint4d::get_class_type(void);

3171 9 ~LPoint4d 0 4 3762 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

3172 8 LPoint4i 0 4 3763 18 LPoint4i::LPoint4i 0 6 1279 1280 1281 1282 1283 1284 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

3173 11 __getattr__ 0 4 3763 21 LPoint4i::__getattr__ 0 1 1285 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3174 11 __setattr__ 0 4 3763 21 LPoint4i::__setattr__ 0 1 1286 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3175 4 zero 0 4 3763 14 LPoint4i::zero 0 1 1287 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

3176 6 unit_x 0 4 3763 16 LPoint4i::unit_x 0 1 1288 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

3177 6 unit_y 0 4 3763 16 LPoint4i::unit_y 0 1 1289 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

3178 6 unit_z 0 4 3763 16 LPoint4i::unit_z 0 1 1290 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

3179 6 unit_w 0 4 3763 16 LPoint4i::unit_w 0 1 1291 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

3180 7 get_xyz 0 4 3763 17 LPoint4i::get_xyz 0 1 1292 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

3181 6 get_xy 0 4 3763 16 LPoint4i::get_xy 0 1 1293 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

3182 10 operator - 0 68 3763 20 LPoint4i::operator - 0 1 1294 0
49
inline LPoint4i LPoint4i::operator -(void) const;

3183 10 operator + 0 4 3763 20 LPoint4i::operator + 0 2 1295 1296 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

3184 10 operator - 0 4 3763 20 LPoint4i::operator - 0 3 1297 1298 1299 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

3185 10 operator * 0 4 3763 20 LPoint4i::operator * 0 1 1300 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

3186 10 operator / 0 4 3763 20 LPoint4i::operator / 0 1 1301 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

3187 8 __rmul__ 0 4 3763 18 LPoint4i::__rmul__ 0 1 1302 0
53
inline LPoint4i LPoint4i::__rmul__(int scalar) const;

3188 8 __repr__ 0 4 3763 18 LPoint4i::__repr__ 0 1 1303 0
50
inline std::string LPoint4i::__repr__(void) const;

3189 14 get_class_type 0 4 3763 24 LPoint4i::get_class_type 0 1 1304 0
49
static TypeHandle LPoint4i::get_class_type(void);

3190 9 ~LPoint4i 0 4 3763 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

3191 11 operator [] 0 4 3766 27 LMatrix3f::Row::operator [] 0 2 1408 1409 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

3192 13 operator [] = 0 260 3766 29 LMatrix3f::Row::operator [] = 0 1 1410 0
67
void LMatrix3f::Row::operator [] =(int i, float const &assign_val);

3193 4 size 0 4 3766 20 LMatrix3f::Row::size 0 1 1411 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

3194 17 operator typecast 0 132 3766 33 LMatrix3f::Row::operator typecast 0 1 1412 0
47
inline operator LVecBase3f const &(void) const;

3195 3 Row 0 4 3766 19 LMatrix3f::Row::Row 0 1 1407 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3196 4 ~Row 0 4 3766 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3197 11 operator [] 0 4 3767 28 LMatrix3f::CRow::operator [] 0 1 1414 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3198 4 size 0 4 3767 21 LMatrix3f::CRow::size 0 1 1415 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3199 17 operator typecast 0 132 3767 34 LMatrix3f::CRow::operator typecast 0 1 1416 0
47
inline operator LVecBase3f const &(void) const;

3200 4 CRow 0 4 3767 21 LMatrix3f::CRow::CRow 0 1 1413 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3201 5 ~CRow 0 4 3767 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3202 9 LMatrix3f 0 4 3764 20 LMatrix3f::LMatrix3f 0 4 1305 1306 1307 1308 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
297
inline LMatrix3f::LMatrix3f(void) = default;
inline LMatrix3f::LMatrix3f(LMatrix3f const &other) = default;
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3203 10 operator = 0 4 3764 21 LMatrix3f::operator = 0 2 1309 1310 10
/**
 *
 */
121
inline void LMatrix3f::operator =(LMatrix3f const &other) = default;
inline void LMatrix3f::operator =(float fill_value);

3204 12 operator new 0 4 3764 23 LMatrix3f::operator new 0 1 1311 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3205 15 operator delete 0 4 3764 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3206 12 validate_ptr 0 4 3764 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3207 10 __reduce__ 0 4 3764 21 LMatrix3f::__reduce__ 0 1 1312 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3208 4 fill 0 4 3764 15 LMatrix3f::fill 0 1 1313 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3209 3 set 0 4 3764 14 LMatrix3f::set 0 1 1314 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3210 11 operator [] 0 4 3764 22 LMatrix3f::operator [] 0 2 1315 1316 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3211 4 size 0 4 3764 15 LMatrix3f::size 0 1 1317 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3212 7 set_row 0 4 3764 18 LMatrix3f::set_row 0 2 1318 1319 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3213 7 set_col 0 4 3764 18 LMatrix3f::set_col 0 2 1320 1321 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3214 7 get_row 0 4 3764 18 LMatrix3f::get_row 0 2 1322 1323 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3215 7 get_col 0 4 3764 18 LMatrix3f::get_col 0 1 1324 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3216 8 get_row2 0 4 3764 19 LMatrix3f::get_row2 0 1 1325 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3217 8 get_col2 0 4 3764 19 LMatrix3f::get_col2 0 1 1326 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3218 11 operator () 0 4 3764 22 LMatrix3f::operator () 0 2 1327 1328 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3219 6 is_nan 0 4 3764 17 LMatrix3f::is_nan 0 1 1329 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3220 11 is_identity 0 4 3764 22 LMatrix3f::is_identity 0 1 1330 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3221 8 get_cell 0 4 3764 19 LMatrix3f::get_cell 0 1 1331 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3222 8 set_cell 0 4 3764 19 LMatrix3f::set_cell 0 1 1332 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3223 8 get_data 0 4 3764 19 LMatrix3f::get_data 0 1 1333 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3224 18 get_num_components 0 4 3764 29 LMatrix3f::get_num_components 0 1 1334 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3225 10 operator < 0 4 3764 21 LMatrix3f::operator < 0 1 1335 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3226 11 operator == 0 4 3764 22 LMatrix3f::operator == 0 1 1336 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3227 11 operator != 0 4 3764 22 LMatrix3f::operator != 0 1 1337 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3228 10 compare_to 0 4 3764 21 LMatrix3f::compare_to 0 2 1338 1339 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3229 8 get_hash 0 4 3764 19 LMatrix3f::get_hash 0 2 1340 1341 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3230 8 add_hash 0 4 3764 19 LMatrix3f::add_hash 0 2 1342 1343 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3231 5 xform 0 4 3764 16 LMatrix3f::xform 0 1 1344 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3232 11 xform_point 0 4 3764 22 LMatrix3f::xform_point 0 1 1345 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3233 9 xform_vec 0 4 3764 20 LMatrix3f::xform_vec 0 2 1346 1347 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3234 17 xform_vec_general 0 4 3764 28 LMatrix3f::xform_vec_general 0 1 1348 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3235 14 xform_in_place 0 4 3764 25 LMatrix3f::xform_in_place 0 1 1349 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3236 20 xform_point_in_place 0 4 3764 31 LMatrix3f::xform_point_in_place 0 1 1350 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3237 18 xform_vec_in_place 0 4 3764 29 LMatrix3f::xform_vec_in_place 0 2 1351 1352 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3238 26 xform_vec_general_in_place 0 4 3764 37 LMatrix3f::xform_vec_general_in_place 0 1 1353 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3239 8 multiply 0 4 3764 19 LMatrix3f::multiply 0 1 1354 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3240 10 operator * 0 4 3764 21 LMatrix3f::operator * 0 2 1355 1356 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3241 10 operator / 0 4 3764 21 LMatrix3f::operator / 0 1 1357 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3242 11 operator += 0 4 3764 22 LMatrix3f::operator += 0 1 1358 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3243 11 operator -= 0 4 3764 22 LMatrix3f::operator -= 0 1 1359 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3244 11 operator *= 0 4 3764 22 LMatrix3f::operator *= 0 2 1360 1361 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3245 11 operator /= 0 4 3764 22 LMatrix3f::operator /= 0 1 1362 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3246 8 __rmul__ 0 4 3764 19 LMatrix3f::__rmul__ 0 1 1363 0
57
inline LMatrix3f LMatrix3f::__rmul__(float scalar) const;

3247 18 componentwise_mult 0 4 3764 29 LMatrix3f::componentwise_mult 0 1 1364 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3248 11 determinant 0 4 3764 22 LMatrix3f::determinant 0 1 1365 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3249 14 transpose_from 0 4 3764 25 LMatrix3f::transpose_from 0 1 1366 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3250 18 transpose_in_place 0 4 3764 29 LMatrix3f::transpose_in_place 0 1 1367 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3251 11 invert_from 0 4 3764 22 LMatrix3f::invert_from 0 1 1368 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3252 15 invert_in_place 0 4 3764 26 LMatrix3f::invert_in_place 0 1 1369 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3253 21 invert_transpose_from 0 4 3764 32 LMatrix3f::invert_transpose_from 0 2 1370 1371 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3254 9 ident_mat 0 4 3764 20 LMatrix3f::ident_mat 0 1 1372 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3255 17 set_translate_mat 0 4 3764 28 LMatrix3f::set_translate_mat 0 1 1373 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3256 14 set_rotate_mat 0 4 3764 25 LMatrix3f::set_rotate_mat 0 2 1374 1375 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3257 13 set_scale_mat 0 4 3764 24 LMatrix3f::set_scale_mat 0 2 1376 1377 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3258 13 translate_mat 0 4 3764 24 LMatrix3f::translate_mat 0 2 1378 1379 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3259 10 rotate_mat 0 4 3764 21 LMatrix3f::rotate_mat 0 2 1380 1381 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3260 9 scale_mat 0 4 3764 20 LMatrix3f::scale_mat 0 4 1382 1383 1384 1385 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3261 23 set_rotate_mat_normaxis 0 4 3764 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1386 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3262 19 rotate_mat_normaxis 0 4 3764 30 LMatrix3f::rotate_mat_normaxis 0 1 1387 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3263 13 set_shear_mat 0 4 3764 24 LMatrix3f::set_shear_mat 0 1 1388 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3264 9 shear_mat 0 4 3764 20 LMatrix3f::shear_mat 0 2 1389 1390 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3265 19 set_scale_shear_mat 0 4 3764 30 LMatrix3f::set_scale_shear_mat 0 1 1391 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3266 15 scale_shear_mat 0 4 3764 26 LMatrix3f::scale_shear_mat 0 2 1392 1393 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3267 11 convert_mat 0 4 3764 22 LMatrix3f::convert_mat 0 1 1394 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3268 12 almost_equal 0 4 3764 23 LMatrix3f::almost_equal 0 2 1395 1396 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3269 6 output 0 4 3764 17 LMatrix3f::output 0 1 1397 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3270 5 write 0 4 3764 16 LMatrix3f::write 0 1 1398 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3271 8 __repr__ 0 4 3764 19 LMatrix3f::__repr__ 0 1 1399 0
51
inline std::string LMatrix3f::__repr__(void) const;

3272 13 generate_hash 0 4 3764 24 LMatrix3f::generate_hash 0 2 1400 1401 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3273 20 write_datagram_fixed 0 4 3764 31 LMatrix3f::write_datagram_fixed 0 1 1402 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3274 19 read_datagram_fixed 0 4 3764 30 LMatrix3f::read_datagram_fixed 0 1 1403 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3275 14 write_datagram 0 4 3764 25 LMatrix3f::write_datagram 0 1 1404 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3276 13 read_datagram 0 4 3764 24 LMatrix3f::read_datagram 0 1 1405 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3277 14 get_class_type 0 4 3764 25 LMatrix3f::get_class_type 0 1 1406 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3278 10 ~LMatrix3f 0 4 3764 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3279 9 transpose 0 1 0 9 transpose 0 4 1985 1986 1987 1988 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3280 6 invert 0 1 0 6 invert 0 6 1989 1990 1991 1992 1993 1994 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3281 11 operator [] 0 4 3770 27 LMatrix4f::Row::operator [] 0 2 1530 1531 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3282 13 operator [] = 0 260 3770 29 LMatrix4f::Row::operator [] = 0 1 1532 0
67
void LMatrix4f::Row::operator [] =(int i, float const &assign_val);

3283 4 size 0 4 3770 20 LMatrix4f::Row::size 0 1 1533 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3284 17 operator typecast 0 132 3770 33 LMatrix4f::Row::operator typecast 0 1 1534 0
47
inline operator LVecBase4f const &(void) const;

3285 3 Row 0 4 3770 19 LMatrix4f::Row::Row 0 1 1529 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3286 4 ~Row 0 4 3770 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3287 11 operator [] 0 4 3771 28 LMatrix4f::CRow::operator [] 0 1 1536 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3288 4 size 0 4 3771 21 LMatrix4f::CRow::size 0 1 1537 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3289 17 operator typecast 0 132 3771 34 LMatrix4f::CRow::operator typecast 0 1 1538 0
47
inline operator LVecBase4f const &(void) const;

3290 4 CRow 0 4 3771 21 LMatrix4f::CRow::CRow 0 1 1535 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3291 5 ~CRow 0 4 3771 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3292 9 LMatrix4f 0 4 3768 20 LMatrix4f::LMatrix4f 0 7 1417 1418 1419 1420 1421 1422 1423 204
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
568
inline LMatrix4f::LMatrix4f(void) = default;
inline LMatrix4f::LMatrix4f(LMatrix4f const &other) = default;
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3293 10 operator = 0 4 3768 21 LMatrix4f::operator = 0 3 1424 1425 1426 22
/**
 *
 */

/**
 *
 */
189
inline void LMatrix4f::operator =(LMatrix4f const &other) = default;
inline void LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline void LMatrix4f::operator =(float fill_value);

3294 12 operator new 0 4 3768 23 LMatrix4f::operator new 0 1 1427 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3295 15 operator delete 0 4 3768 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3296 12 validate_ptr 0 4 3768 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3297 10 __reduce__ 0 4 3768 21 LMatrix4f::__reduce__ 0 1 1428 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3298 4 fill 0 4 3768 15 LMatrix4f::fill 0 1 1429 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3299 3 set 0 4 3768 14 LMatrix4f::set 0 1 1430 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3300 11 set_upper_3 0 4 3768 22 LMatrix4f::set_upper_3 0 1 1431 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3301 11 get_upper_3 0 4 3768 22 LMatrix4f::get_upper_3 0 1 1432 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3302 11 operator [] 0 4 3768 22 LMatrix4f::operator [] 0 2 1433 1434 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3303 4 size 0 4 3768 15 LMatrix4f::size 0 1 1435 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3304 7 set_row 0 4 3768 18 LMatrix4f::set_row 0 2 1436 1437 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3305 7 set_col 0 4 3768 18 LMatrix4f::set_col 0 2 1438 1439 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3306 7 get_row 0 4 3768 18 LMatrix4f::get_row 0 2 1440 1441 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3307 7 get_col 0 4 3768 18 LMatrix4f::get_col 0 1 1442 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3308 8 get_row3 0 4 3768 19 LMatrix4f::get_row3 0 2 1443 1444 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3309 8 get_col3 0 4 3768 19 LMatrix4f::get_col3 0 1 1445 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3310 11 operator () 0 4 3768 22 LMatrix4f::operator () 0 2 1446 1447 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3311 6 is_nan 0 4 3768 17 LMatrix4f::is_nan 0 1 1448 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3312 11 is_identity 0 4 3768 22 LMatrix4f::is_identity 0 1 1449 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3313 8 get_cell 0 4 3768 19 LMatrix4f::get_cell 0 1 1450 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3314 8 set_cell 0 4 3768 19 LMatrix4f::set_cell 0 1 1451 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3315 8 get_data 0 4 3768 19 LMatrix4f::get_data 0 1 1452 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3316 18 get_num_components 0 4 3768 29 LMatrix4f::get_num_components 0 1 1453 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3317 5 begin 0 4 3768 16 LMatrix4f::begin 0 2 1454 1455 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3318 3 end 0 4 3768 14 LMatrix4f::end 0 2 1456 1457 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3319 10 operator < 0 4 3768 21 LMatrix4f::operator < 0 1 1458 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3320 11 operator == 0 4 3768 22 LMatrix4f::operator == 0 1 1459 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3321 11 operator != 0 4 3768 22 LMatrix4f::operator != 0 1 1460 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3322 10 compare_to 0 4 3768 21 LMatrix4f::compare_to 0 2 1461 1462 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3323 8 get_hash 0 4 3768 19 LMatrix4f::get_hash 0 2 1463 1464 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3324 8 add_hash 0 4 3768 19 LMatrix4f::add_hash 0 2 1465 1466 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3325 5 xform 0 4 3768 16 LMatrix4f::xform 0 1 1467 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3326 11 xform_point 0 4 3768 22 LMatrix4f::xform_point 0 1 1468 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3327 19 xform_point_general 0 4 3768 30 LMatrix4f::xform_point_general 0 1 1469 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3328 9 xform_vec 0 4 3768 20 LMatrix4f::xform_vec 0 1 1470 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3329 17 xform_vec_general 0 4 3768 28 LMatrix4f::xform_vec_general 0 1 1471 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3330 14 xform_in_place 0 4 3768 25 LMatrix4f::xform_in_place 0 1 1472 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3331 20 xform_point_in_place 0 4 3768 31 LMatrix4f::xform_point_in_place 0 1 1473 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3332 28 xform_point_general_in_place 0 4 3768 39 LMatrix4f::xform_point_general_in_place 0 1 1474 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3333 18 xform_vec_in_place 0 4 3768 29 LMatrix4f::xform_vec_in_place 0 1 1475 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3334 26 xform_vec_general_in_place 0 4 3768 37 LMatrix4f::xform_vec_general_in_place 0 1 1476 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3335 8 multiply 0 4 3768 19 LMatrix4f::multiply 0 1 1477 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3336 10 operator * 0 4 3768 21 LMatrix4f::operator * 0 2 1478 1479 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3337 10 operator / 0 4 3768 21 LMatrix4f::operator / 0 1 1480 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3338 11 operator += 0 4 3768 22 LMatrix4f::operator += 0 1 1481 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3339 11 operator -= 0 4 3768 22 LMatrix4f::operator -= 0 1 1482 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3340 11 operator *= 0 4 3768 22 LMatrix4f::operator *= 0 2 1483 1484 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3341 11 operator /= 0 4 3768 22 LMatrix4f::operator /= 0 1 1485 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3342 8 __rmul__ 0 4 3768 19 LMatrix4f::__rmul__ 0 1 1486 0
57
inline LMatrix4f LMatrix4f::__rmul__(float scalar) const;

3343 18 componentwise_mult 0 4 3768 29 LMatrix4f::componentwise_mult 0 1 1487 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3344 14 transpose_from 0 4 3768 25 LMatrix4f::transpose_from 0 1 1488 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3345 18 transpose_in_place 0 4 3768 29 LMatrix4f::transpose_in_place 0 1 1489 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3346 11 invert_from 0 4 3768 22 LMatrix4f::invert_from 0 1 1490 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3347 18 invert_affine_from 0 4 3768 29 LMatrix4f::invert_affine_from 0 1 1491 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3348 15 invert_in_place 0 4 3768 26 LMatrix4f::invert_in_place 0 1 1492 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3349 10 accumulate 0 4 3768 21 LMatrix4f::accumulate 0 1 1493 48
/**
 * Computes `(*this) += other * weight`.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3350 9 ident_mat 0 4 3768 20 LMatrix4f::ident_mat 0 1 1494 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3351 8 ones_mat 0 4 3768 19 LMatrix4f::ones_mat 0 1 1495 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3352 9 zeros_mat 0 4 3768 20 LMatrix4f::zeros_mat 0 1 1496 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3353 17 set_translate_mat 0 4 3768 28 LMatrix4f::set_translate_mat 0 1 1497 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3354 14 set_rotate_mat 0 4 3768 25 LMatrix4f::set_rotate_mat 0 1 1498 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3355 23 set_rotate_mat_normaxis 0 4 3768 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1499 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3356 13 set_scale_mat 0 4 3768 24 LMatrix4f::set_scale_mat 0 1 1500 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3357 13 set_shear_mat 0 4 3768 24 LMatrix4f::set_shear_mat 0 1 1501 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3358 19 set_scale_shear_mat 0 4 3768 30 LMatrix4f::set_scale_shear_mat 0 1 1502 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3359 13 translate_mat 0 4 3768 24 LMatrix4f::translate_mat 0 2 1503 1504 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3360 10 rotate_mat 0 4 3768 21 LMatrix4f::rotate_mat 0 1 1505 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3361 19 rotate_mat_normaxis 0 4 3768 30 LMatrix4f::rotate_mat_normaxis 0 1 1506 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3362 9 scale_mat 0 4 3768 20 LMatrix4f::scale_mat 0 3 1507 1508 1509 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3363 9 shear_mat 0 4 3768 20 LMatrix4f::shear_mat 0 2 1510 1511 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3364 15 scale_shear_mat 0 4 3768 26 LMatrix4f::scale_shear_mat 0 2 1512 1513 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3365 13 y_to_z_up_mat 0 4 3768 24 LMatrix4f::y_to_z_up_mat 0 1 1514 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3366 13 z_to_y_up_mat 0 4 3768 24 LMatrix4f::z_to_y_up_mat 0 1 1515 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3367 11 convert_mat 0 4 3768 22 LMatrix4f::convert_mat 0 1 1516 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3368 12 almost_equal 0 4 3768 23 LMatrix4f::almost_equal 0 2 1517 1518 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3369 6 output 0 4 3768 17 LMatrix4f::output 0 1 1519 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3370 5 write 0 4 3768 16 LMatrix4f::write 0 1 1520 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3371 8 __repr__ 0 4 3768 19 LMatrix4f::__repr__ 0 1 1521 0
51
inline std::string LMatrix4f::__repr__(void) const;

3372 13 generate_hash 0 4 3768 24 LMatrix4f::generate_hash 0 2 1522 1523 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3373 20 write_datagram_fixed 0 4 3768 31 LMatrix4f::write_datagram_fixed 0 1 1524 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3374 19 read_datagram_fixed 0 4 3768 30 LMatrix4f::read_datagram_fixed 0 1 1525 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3375 14 write_datagram 0 4 3768 25 LMatrix4f::write_datagram 0 1 1526 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3376 13 read_datagram 0 4 3768 24 LMatrix4f::read_datagram 0 1 1527 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3377 14 get_class_type 0 4 3768 25 LMatrix4f::get_class_type 0 1 1528 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3378 10 ~LMatrix4f 0 4 3768 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3379 18 UnalignedLMatrix4f 0 4 3772 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1539 1540 1541 1542 22
/**
 *
 */

/**
 *
 */
444
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void) = default;
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy) = default;
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3380 10 operator = 0 4 3772 30 UnalignedLMatrix4f::operator = 0 2 1543 1544 10
/**
 *
 */
152
inline void UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy) = default;

3381 3 set 0 4 3772 23 UnalignedLMatrix4f::set 0 1 1545 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3382 11 operator () 0 4 3772 31 UnalignedLMatrix4f::operator () 0 2 1546 1547 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3383 8 get_data 0 4 3772 28 UnalignedLMatrix4f::get_data 0 1 1548 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3384 18 get_num_components 0 4 3772 38 UnalignedLMatrix4f::get_num_components 0 1 1549 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3385 11 operator == 0 4 3772 31 UnalignedLMatrix4f::operator == 0 1 1550 0
83
inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &other) const;

3386 11 operator != 0 4 3772 31 UnalignedLMatrix4f::operator != 0 1 1551 0
83
inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &other) const;

3387 14 get_class_type 0 4 3772 34 UnalignedLMatrix4f::get_class_type 0 1 1552 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3388 19 ~UnalignedLMatrix4f 0 4 3772 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3389 11 operator [] 0 4 3776 27 LMatrix3d::Row::operator [] 0 2 1656 1657 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3390 13 operator [] = 0 260 3776 29 LMatrix3d::Row::operator [] = 0 1 1658 0
68
void LMatrix3d::Row::operator [] =(int i, double const &assign_val);

3391 4 size 0 4 3776 20 LMatrix3d::Row::size 0 1 1659 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3392 17 operator typecast 0 132 3776 33 LMatrix3d::Row::operator typecast 0 1 1660 0
47
inline operator LVecBase3d const &(void) const;

3393 3 Row 0 4 3776 19 LMatrix3d::Row::Row 0 1 1655 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3394 4 ~Row 0 4 3776 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3395 11 operator [] 0 4 3777 28 LMatrix3d::CRow::operator [] 0 1 1662 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3396 4 size 0 4 3777 21 LMatrix3d::CRow::size 0 1 1663 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3397 17 operator typecast 0 132 3777 34 LMatrix3d::CRow::operator typecast 0 1 1664 0
47
inline operator LVecBase3d const &(void) const;

3398 4 CRow 0 4 3777 21 LMatrix3d::CRow::CRow 0 1 1661 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3399 5 ~CRow 0 4 3777 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3400 9 LMatrix3d 0 4 3774 20 LMatrix3d::LMatrix3d 0 4 1553 1554 1555 1556 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
306
inline LMatrix3d::LMatrix3d(void) = default;
inline LMatrix3d::LMatrix3d(LMatrix3d const &other) = default;
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3401 10 operator = 0 4 3774 21 LMatrix3d::operator = 0 2 1557 1558 10
/**
 *
 */
122
inline void LMatrix3d::operator =(LMatrix3d const &other) = default;
inline void LMatrix3d::operator =(double fill_value);

3402 12 operator new 0 4 3774 23 LMatrix3d::operator new 0 1 1559 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3403 15 operator delete 0 4 3774 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3404 12 validate_ptr 0 4 3774 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3405 10 __reduce__ 0 4 3774 21 LMatrix3d::__reduce__ 0 1 1560 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3406 4 fill 0 4 3774 15 LMatrix3d::fill 0 1 1561 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3407 3 set 0 4 3774 14 LMatrix3d::set 0 1 1562 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3408 11 operator [] 0 4 3774 22 LMatrix3d::operator [] 0 2 1563 1564 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3409 4 size 0 4 3774 15 LMatrix3d::size 0 1 1565 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3410 7 set_row 0 4 3774 18 LMatrix3d::set_row 0 2 1566 1567 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3411 7 set_col 0 4 3774 18 LMatrix3d::set_col 0 2 1568 1569 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3412 7 get_row 0 4 3774 18 LMatrix3d::get_row 0 2 1570 1571 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3413 7 get_col 0 4 3774 18 LMatrix3d::get_col 0 1 1572 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3414 8 get_row2 0 4 3774 19 LMatrix3d::get_row2 0 1 1573 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3415 8 get_col2 0 4 3774 19 LMatrix3d::get_col2 0 1 1574 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3416 11 operator () 0 4 3774 22 LMatrix3d::operator () 0 2 1575 1576 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3417 6 is_nan 0 4 3774 17 LMatrix3d::is_nan 0 1 1577 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3418 11 is_identity 0 4 3774 22 LMatrix3d::is_identity 0 1 1578 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3419 8 get_cell 0 4 3774 19 LMatrix3d::get_cell 0 1 1579 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3420 8 set_cell 0 4 3774 19 LMatrix3d::set_cell 0 1 1580 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3421 8 get_data 0 4 3774 19 LMatrix3d::get_data 0 1 1581 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3422 18 get_num_components 0 4 3774 29 LMatrix3d::get_num_components 0 1 1582 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3423 10 operator < 0 4 3774 21 LMatrix3d::operator < 0 1 1583 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3424 11 operator == 0 4 3774 22 LMatrix3d::operator == 0 1 1584 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3425 11 operator != 0 4 3774 22 LMatrix3d::operator != 0 1 1585 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3426 10 compare_to 0 4 3774 21 LMatrix3d::compare_to 0 2 1586 1587 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3427 8 get_hash 0 4 3774 19 LMatrix3d::get_hash 0 2 1588 1589 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3428 8 add_hash 0 4 3774 19 LMatrix3d::add_hash 0 2 1590 1591 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3429 5 xform 0 4 3774 16 LMatrix3d::xform 0 1 1592 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3430 11 xform_point 0 4 3774 22 LMatrix3d::xform_point 0 1 1593 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3431 9 xform_vec 0 4 3774 20 LMatrix3d::xform_vec 0 2 1594 1595 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3432 17 xform_vec_general 0 4 3774 28 LMatrix3d::xform_vec_general 0 1 1596 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3433 14 xform_in_place 0 4 3774 25 LMatrix3d::xform_in_place 0 1 1597 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3434 20 xform_point_in_place 0 4 3774 31 LMatrix3d::xform_point_in_place 0 1 1598 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3435 18 xform_vec_in_place 0 4 3774 29 LMatrix3d::xform_vec_in_place 0 2 1599 1600 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3436 26 xform_vec_general_in_place 0 4 3774 37 LMatrix3d::xform_vec_general_in_place 0 1 1601 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3437 8 multiply 0 4 3774 19 LMatrix3d::multiply 0 1 1602 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3438 10 operator * 0 4 3774 21 LMatrix3d::operator * 0 2 1603 1604 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3439 10 operator / 0 4 3774 21 LMatrix3d::operator / 0 1 1605 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3440 11 operator += 0 4 3774 22 LMatrix3d::operator += 0 1 1606 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3441 11 operator -= 0 4 3774 22 LMatrix3d::operator -= 0 1 1607 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3442 11 operator *= 0 4 3774 22 LMatrix3d::operator *= 0 2 1608 1609 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3443 11 operator /= 0 4 3774 22 LMatrix3d::operator /= 0 1 1610 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3444 8 __rmul__ 0 4 3774 19 LMatrix3d::__rmul__ 0 1 1611 0
58
inline LMatrix3d LMatrix3d::__rmul__(double scalar) const;

3445 18 componentwise_mult 0 4 3774 29 LMatrix3d::componentwise_mult 0 1 1612 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3446 11 determinant 0 4 3774 22 LMatrix3d::determinant 0 1 1613 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3447 14 transpose_from 0 4 3774 25 LMatrix3d::transpose_from 0 1 1614 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3448 18 transpose_in_place 0 4 3774 29 LMatrix3d::transpose_in_place 0 1 1615 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3449 11 invert_from 0 4 3774 22 LMatrix3d::invert_from 0 1 1616 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3450 15 invert_in_place 0 4 3774 26 LMatrix3d::invert_in_place 0 1 1617 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3451 21 invert_transpose_from 0 4 3774 32 LMatrix3d::invert_transpose_from 0 2 1618 1619 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3452 9 ident_mat 0 4 3774 20 LMatrix3d::ident_mat 0 1 1620 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3453 17 set_translate_mat 0 4 3774 28 LMatrix3d::set_translate_mat 0 1 1621 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3454 14 set_rotate_mat 0 4 3774 25 LMatrix3d::set_rotate_mat 0 2 1622 1623 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3455 13 set_scale_mat 0 4 3774 24 LMatrix3d::set_scale_mat 0 2 1624 1625 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3456 13 translate_mat 0 4 3774 24 LMatrix3d::translate_mat 0 2 1626 1627 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3457 10 rotate_mat 0 4 3774 21 LMatrix3d::rotate_mat 0 2 1628 1629 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3458 9 scale_mat 0 4 3774 20 LMatrix3d::scale_mat 0 4 1630 1631 1632 1633 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3459 23 set_rotate_mat_normaxis 0 4 3774 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1634 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3460 19 rotate_mat_normaxis 0 4 3774 30 LMatrix3d::rotate_mat_normaxis 0 1 1635 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3461 13 set_shear_mat 0 4 3774 24 LMatrix3d::set_shear_mat 0 1 1636 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3462 9 shear_mat 0 4 3774 20 LMatrix3d::shear_mat 0 2 1637 1638 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3463 19 set_scale_shear_mat 0 4 3774 30 LMatrix3d::set_scale_shear_mat 0 1 1639 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3464 15 scale_shear_mat 0 4 3774 26 LMatrix3d::scale_shear_mat 0 2 1640 1641 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3465 11 convert_mat 0 4 3774 22 LMatrix3d::convert_mat 0 1 1642 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3466 12 almost_equal 0 4 3774 23 LMatrix3d::almost_equal 0 2 1643 1644 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3467 6 output 0 4 3774 17 LMatrix3d::output 0 1 1645 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3468 5 write 0 4 3774 16 LMatrix3d::write 0 1 1646 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3469 8 __repr__ 0 4 3774 19 LMatrix3d::__repr__ 0 1 1647 0
51
inline std::string LMatrix3d::__repr__(void) const;

3470 13 generate_hash 0 4 3774 24 LMatrix3d::generate_hash 0 2 1648 1649 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3471 20 write_datagram_fixed 0 4 3774 31 LMatrix3d::write_datagram_fixed 0 1 1650 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3472 19 read_datagram_fixed 0 4 3774 30 LMatrix3d::read_datagram_fixed 0 1 1651 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3473 14 write_datagram 0 4 3774 25 LMatrix3d::write_datagram 0 1 1652 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3474 13 read_datagram 0 4 3774 24 LMatrix3d::read_datagram 0 1 1653 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3475 14 get_class_type 0 4 3774 25 LMatrix3d::get_class_type 0 1 1654 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3476 10 ~LMatrix3d 0 4 3774 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3477 11 operator [] 0 4 3780 27 LMatrix4d::Row::operator [] 0 2 1778 1779 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3478 13 operator [] = 0 260 3780 29 LMatrix4d::Row::operator [] = 0 1 1780 0
68
void LMatrix4d::Row::operator [] =(int i, double const &assign_val);

3479 4 size 0 4 3780 20 LMatrix4d::Row::size 0 1 1781 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3480 17 operator typecast 0 132 3780 33 LMatrix4d::Row::operator typecast 0 1 1782 0
47
inline operator LVecBase4d const &(void) const;

3481 3 Row 0 4 3780 19 LMatrix4d::Row::Row 0 1 1777 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3482 4 ~Row 0 4 3780 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3483 11 operator [] 0 4 3781 28 LMatrix4d::CRow::operator [] 0 1 1784 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3484 4 size 0 4 3781 21 LMatrix4d::CRow::size 0 1 1785 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3485 17 operator typecast 0 132 3781 34 LMatrix4d::CRow::operator typecast 0 1 1786 0
47
inline operator LVecBase4d const &(void) const;

3486 4 CRow 0 4 3781 21 LMatrix4d::CRow::CRow 0 1 1783 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3487 5 ~CRow 0 4 3781 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3488 9 LMatrix4d 0 4 3778 20 LMatrix4d::LMatrix4d 0 7 1665 1666 1667 1668 1669 1670 1671 204
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
584
inline LMatrix4d::LMatrix4d(void) = default;
inline LMatrix4d::LMatrix4d(LMatrix4d const &other) = default;
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3489 10 operator = 0 4 3778 21 LMatrix4d::operator = 0 3 1672 1673 1674 22
/**
 *
 */

/**
 *
 */
190
inline void LMatrix4d::operator =(LMatrix4d const &other) = default;
inline void LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline void LMatrix4d::operator =(double fill_value);

3490 12 operator new 0 4 3778 23 LMatrix4d::operator new 0 1 1675 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3491 15 operator delete 0 4 3778 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3492 12 validate_ptr 0 4 3778 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3493 10 __reduce__ 0 4 3778 21 LMatrix4d::__reduce__ 0 1 1676 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3494 4 fill 0 4 3778 15 LMatrix4d::fill 0 1 1677 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3495 3 set 0 4 3778 14 LMatrix4d::set 0 1 1678 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3496 11 set_upper_3 0 4 3778 22 LMatrix4d::set_upper_3 0 1 1679 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3497 11 get_upper_3 0 4 3778 22 LMatrix4d::get_upper_3 0 1 1680 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3498 11 operator [] 0 4 3778 22 LMatrix4d::operator [] 0 2 1681 1682 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3499 4 size 0 4 3778 15 LMatrix4d::size 0 1 1683 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3500 7 set_row 0 4 3778 18 LMatrix4d::set_row 0 2 1684 1685 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3501 7 set_col 0 4 3778 18 LMatrix4d::set_col 0 2 1686 1687 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3502 7 get_row 0 4 3778 18 LMatrix4d::get_row 0 2 1688 1689 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3503 7 get_col 0 4 3778 18 LMatrix4d::get_col 0 1 1690 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3504 8 get_row3 0 4 3778 19 LMatrix4d::get_row3 0 2 1691 1692 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3505 8 get_col3 0 4 3778 19 LMatrix4d::get_col3 0 1 1693 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3506 11 operator () 0 4 3778 22 LMatrix4d::operator () 0 2 1694 1695 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3507 6 is_nan 0 4 3778 17 LMatrix4d::is_nan 0 1 1696 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3508 11 is_identity 0 4 3778 22 LMatrix4d::is_identity 0 1 1697 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3509 8 get_cell 0 4 3778 19 LMatrix4d::get_cell 0 1 1698 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3510 8 set_cell 0 4 3778 19 LMatrix4d::set_cell 0 1 1699 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3511 8 get_data 0 4 3778 19 LMatrix4d::get_data 0 1 1700 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3512 18 get_num_components 0 4 3778 29 LMatrix4d::get_num_components 0 1 1701 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3513 5 begin 0 4 3778 16 LMatrix4d::begin 0 2 1702 1703 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3514 3 end 0 4 3778 14 LMatrix4d::end 0 2 1704 1705 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3515 10 operator < 0 4 3778 21 LMatrix4d::operator < 0 1 1706 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3516 11 operator == 0 4 3778 22 LMatrix4d::operator == 0 1 1707 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3517 11 operator != 0 4 3778 22 LMatrix4d::operator != 0 1 1708 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3518 10 compare_to 0 4 3778 21 LMatrix4d::compare_to 0 2 1709 1710 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3519 8 get_hash 0 4 3778 19 LMatrix4d::get_hash 0 2 1711 1712 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3520 8 add_hash 0 4 3778 19 LMatrix4d::add_hash 0 2 1713 1714 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3521 5 xform 0 4 3778 16 LMatrix4d::xform 0 1 1715 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3522 11 xform_point 0 4 3778 22 LMatrix4d::xform_point 0 1 1716 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3523 19 xform_point_general 0 4 3778 30 LMatrix4d::xform_point_general 0 1 1717 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3524 9 xform_vec 0 4 3778 20 LMatrix4d::xform_vec 0 1 1718 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3525 17 xform_vec_general 0 4 3778 28 LMatrix4d::xform_vec_general 0 1 1719 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3526 14 xform_in_place 0 4 3778 25 LMatrix4d::xform_in_place 0 1 1720 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3527 20 xform_point_in_place 0 4 3778 31 LMatrix4d::xform_point_in_place 0 1 1721 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3528 28 xform_point_general_in_place 0 4 3778 39 LMatrix4d::xform_point_general_in_place 0 1 1722 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3529 18 xform_vec_in_place 0 4 3778 29 LMatrix4d::xform_vec_in_place 0 1 1723 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3530 26 xform_vec_general_in_place 0 4 3778 37 LMatrix4d::xform_vec_general_in_place 0 1 1724 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3531 8 multiply 0 4 3778 19 LMatrix4d::multiply 0 1 1725 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3532 10 operator * 0 4 3778 21 LMatrix4d::operator * 0 2 1726 1727 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3533 10 operator / 0 4 3778 21 LMatrix4d::operator / 0 1 1728 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3534 11 operator += 0 4 3778 22 LMatrix4d::operator += 0 1 1729 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3535 11 operator -= 0 4 3778 22 LMatrix4d::operator -= 0 1 1730 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3536 11 operator *= 0 4 3778 22 LMatrix4d::operator *= 0 2 1731 1732 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3537 11 operator /= 0 4 3778 22 LMatrix4d::operator /= 0 1 1733 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3538 8 __rmul__ 0 4 3778 19 LMatrix4d::__rmul__ 0 1 1734 0
58
inline LMatrix4d LMatrix4d::__rmul__(double scalar) const;

3539 18 componentwise_mult 0 4 3778 29 LMatrix4d::componentwise_mult 0 1 1735 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3540 14 transpose_from 0 4 3778 25 LMatrix4d::transpose_from 0 1 1736 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3541 18 transpose_in_place 0 4 3778 29 LMatrix4d::transpose_in_place 0 1 1737 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3542 11 invert_from 0 4 3778 22 LMatrix4d::invert_from 0 1 1738 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3543 18 invert_affine_from 0 4 3778 29 LMatrix4d::invert_affine_from 0 1 1739 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3544 15 invert_in_place 0 4 3778 26 LMatrix4d::invert_in_place 0 1 1740 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3545 10 accumulate 0 4 3778 21 LMatrix4d::accumulate 0 1 1741 48
/**
 * Computes `(*this) += other * weight`.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3546 9 ident_mat 0 4 3778 20 LMatrix4d::ident_mat 0 1 1742 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3547 8 ones_mat 0 4 3778 19 LMatrix4d::ones_mat 0 1 1743 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3548 9 zeros_mat 0 4 3778 20 LMatrix4d::zeros_mat 0 1 1744 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3549 17 set_translate_mat 0 4 3778 28 LMatrix4d::set_translate_mat 0 1 1745 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3550 14 set_rotate_mat 0 4 3778 25 LMatrix4d::set_rotate_mat 0 1 1746 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3551 23 set_rotate_mat_normaxis 0 4 3778 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1747 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3552 13 set_scale_mat 0 4 3778 24 LMatrix4d::set_scale_mat 0 1 1748 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3553 13 set_shear_mat 0 4 3778 24 LMatrix4d::set_shear_mat 0 1 1749 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3554 19 set_scale_shear_mat 0 4 3778 30 LMatrix4d::set_scale_shear_mat 0 1 1750 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3555 13 translate_mat 0 4 3778 24 LMatrix4d::translate_mat 0 2 1751 1752 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3556 10 rotate_mat 0 4 3778 21 LMatrix4d::rotate_mat 0 1 1753 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3557 19 rotate_mat_normaxis 0 4 3778 30 LMatrix4d::rotate_mat_normaxis 0 1 1754 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3558 9 scale_mat 0 4 3778 20 LMatrix4d::scale_mat 0 3 1755 1756 1757 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3559 9 shear_mat 0 4 3778 20 LMatrix4d::shear_mat 0 2 1758 1759 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3560 15 scale_shear_mat 0 4 3778 26 LMatrix4d::scale_shear_mat 0 2 1760 1761 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3561 13 y_to_z_up_mat 0 4 3778 24 LMatrix4d::y_to_z_up_mat 0 1 1762 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3562 13 z_to_y_up_mat 0 4 3778 24 LMatrix4d::z_to_y_up_mat 0 1 1763 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3563 11 convert_mat 0 4 3778 22 LMatrix4d::convert_mat 0 1 1764 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3564 12 almost_equal 0 4 3778 23 LMatrix4d::almost_equal 0 2 1765 1766 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3565 6 output 0 4 3778 17 LMatrix4d::output 0 1 1767 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3566 5 write 0 4 3778 16 LMatrix4d::write 0 1 1768 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3567 8 __repr__ 0 4 3778 19 LMatrix4d::__repr__ 0 1 1769 0
51
inline std::string LMatrix4d::__repr__(void) const;

3568 13 generate_hash 0 4 3778 24 LMatrix4d::generate_hash 0 2 1770 1771 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3569 20 write_datagram_fixed 0 4 3778 31 LMatrix4d::write_datagram_fixed 0 1 1772 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3570 19 read_datagram_fixed 0 4 3778 30 LMatrix4d::read_datagram_fixed 0 1 1773 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3571 14 write_datagram 0 4 3778 25 LMatrix4d::write_datagram 0 1 1774 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3572 13 read_datagram 0 4 3778 24 LMatrix4d::read_datagram 0 1 1775 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3573 14 get_class_type 0 4 3778 25 LMatrix4d::get_class_type 0 1 1776 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3574 10 ~LMatrix4d 0 4 3778 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3575 18 UnalignedLMatrix4d 0 4 3782 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1787 1788 1789 1790 22
/**
 *
 */

/**
 *
 */
460
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void) = default;
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy) = default;
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3576 10 operator = 0 4 3782 30 UnalignedLMatrix4d::operator = 0 2 1791 1792 10
/**
 *
 */
152
inline void UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy) = default;

3577 3 set 0 4 3782 23 UnalignedLMatrix4d::set 0 1 1793 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3578 11 operator () 0 4 3782 31 UnalignedLMatrix4d::operator () 0 2 1794 1795 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3579 8 get_data 0 4 3782 28 UnalignedLMatrix4d::get_data 0 1 1796 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3580 18 get_num_components 0 4 3782 38 UnalignedLMatrix4d::get_num_components 0 1 1797 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3581 11 operator == 0 4 3782 31 UnalignedLMatrix4d::operator == 0 1 1798 0
83
inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &other) const;

3582 11 operator != 0 4 3782 31 UnalignedLMatrix4d::operator != 0 1 1799 0
83
inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &other) const;

3583 14 get_class_type 0 4 3782 34 UnalignedLMatrix4d::get_class_type 0 1 1800 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3584 19 ~UnalignedLMatrix4d 0 4 3782 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3585 10 operator * 0 1 0 10 operator * 0 24 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3586 11 operator *= 0 1 0 11 operator *= 0 16 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3587 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 2035 2036 2037 2038 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3588 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 2039 2040 2041 2042 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3589 14 compose_matrix 0 1 0 14 compose_matrix 0 10 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3590 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3591 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 2063 2064 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3592 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 2065 2066 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3593 12 LQuaternionf 0 4 3784 26 LQuaternionf::LQuaternionf 0 5 1801 1802 1803 1804 1805 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3594 14 pure_imaginary 0 4 3784 28 LQuaternionf::pure_imaginary 0 1 1806 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3595 9 conjugate 0 4 3784 23 LQuaternionf::conjugate 0 1 1807 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3596 5 xform 0 4 3784 19 LQuaternionf::xform 0 2 1808 1809 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3597 8 multiply 0 4 3784 22 LQuaternionf::multiply 0 1 1810 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3598 10 operator - 0 68 3784 24 LQuaternionf::operator - 0 1 1811 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3599 10 operator + 0 4 3784 24 LQuaternionf::operator + 0 1 1812 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3600 10 operator - 0 4 3784 24 LQuaternionf::operator - 0 1 1813 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3601 9 angle_rad 0 4 3784 23 LQuaternionf::angle_rad 0 1 1814 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3602 9 angle_deg 0 4 3784 23 LQuaternionf::angle_deg 0 1 1815 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3603 10 operator * 0 4 3784 24 LQuaternionf::operator * 0 4 1816 1817 1818 1819 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3604 10 operator / 0 4 3784 24 LQuaternionf::operator / 0 1 1820 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3605 11 operator *= 0 4 3784 25 LQuaternionf::operator *= 0 1 1821 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3606 7 __pow__ 0 4 3784 21 LQuaternionf::__pow__ 0 1 1822 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3607 12 almost_equal 0 4 3784 26 LQuaternionf::almost_equal 0 2 1823 1824 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3608 17 is_same_direction 0 4 3784 31 LQuaternionf::is_same_direction 0 1 1825 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3609 21 almost_same_direction 0 4 3784 35 LQuaternionf::almost_same_direction 0 1 1826 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3610 6 output 0 4 3784 20 LQuaternionf::output 0 1 1827 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3611 17 extract_to_matrix 0 4 3784 31 LQuaternionf::extract_to_matrix 0 2 1828 1829 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3612 15 set_from_matrix 0 4 3784 29 LQuaternionf::set_from_matrix 0 2 1830 1831 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3613 7 set_hpr 0 4 3784 21 LQuaternionf::set_hpr 0 1 1832 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3614 7 get_hpr 0 4 3784 21 LQuaternionf::get_hpr 0 1 1833 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3615 8 get_axis 0 4 3784 22 LQuaternionf::get_axis 0 1 1834 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3616 19 get_axis_normalized 0 4 3784 33 LQuaternionf::get_axis_normalized 0 1 1835 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3617 13 get_angle_rad 0 4 3784 27 LQuaternionf::get_angle_rad 0 1 1836 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3618 9 get_angle 0 4 3784 23 LQuaternionf::get_angle 0 1 1837 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3619 23 set_from_axis_angle_rad 0 4 3784 37 LQuaternionf::set_from_axis_angle_rad 0 1 1838 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3620 19 set_from_axis_angle 0 4 3784 33 LQuaternionf::set_from_axis_angle 0 1 1839 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3621 6 get_up 0 4 3784 20 LQuaternionf::get_up 0 1 1840 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3622 9 get_right 0 4 3784 23 LQuaternionf::get_right 0 1 1841 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3623 11 get_forward 0 4 3784 25 LQuaternionf::get_forward 0 1 1842 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3624 5 get_r 0 4 3784 19 LQuaternionf::get_r 0 1 1843 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3625 5 get_i 0 4 3784 19 LQuaternionf::get_i 0 1 1844 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3626 5 get_j 0 4 3784 19 LQuaternionf::get_j 0 1 1845 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3627 5 get_k 0 4 3784 19 LQuaternionf::get_k 0 1 1846 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3628 5 set_r 0 4 3784 19 LQuaternionf::set_r 0 1 1847 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3629 5 set_i 0 4 3784 19 LQuaternionf::set_i 0 1 1848 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3630 5 set_j 0 4 3784 19 LQuaternionf::set_j 0 1 1849 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3631 5 set_k 0 4 3784 19 LQuaternionf::set_k 0 1 1850 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3632 9 normalize 0 4 3784 23 LQuaternionf::normalize 0 1 1851 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3633 14 conjugate_from 0 4 3784 28 LQuaternionf::conjugate_from 0 1 1852 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3634 18 conjugate_in_place 0 4 3784 32 LQuaternionf::conjugate_in_place 0 1 1853 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3635 11 invert_from 0 4 3784 25 LQuaternionf::invert_from 0 1 1854 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3636 15 invert_in_place 0 4 3784 29 LQuaternionf::invert_in_place 0 1 1855 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3637 11 is_identity 0 4 3784 25 LQuaternionf::is_identity 0 1 1856 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3638 18 is_almost_identity 0 4 3784 32 LQuaternionf::is_almost_identity 0 1 1857 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3639 10 ident_quat 0 4 3784 24 LQuaternionf::ident_quat 0 1 1858 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3640 14 get_class_type 0 4 3784 28 LQuaternionf::get_class_type 0 1 1859 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3641 13 ~LQuaternionf 0 4 3784 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3642 12 LQuaterniond 0 4 3785 26 LQuaterniond::LQuaterniond 0 5 1860 1861 1862 1863 1864 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3643 14 pure_imaginary 0 4 3785 28 LQuaterniond::pure_imaginary 0 1 1865 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3644 9 conjugate 0 4 3785 23 LQuaterniond::conjugate 0 1 1866 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3645 5 xform 0 4 3785 19 LQuaterniond::xform 0 2 1867 1868 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3646 8 multiply 0 4 3785 22 LQuaterniond::multiply 0 1 1869 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3647 10 operator - 0 68 3785 24 LQuaterniond::operator - 0 1 1870 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3648 10 operator + 0 4 3785 24 LQuaterniond::operator + 0 1 1871 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3649 10 operator - 0 4 3785 24 LQuaterniond::operator - 0 1 1872 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3650 9 angle_rad 0 4 3785 23 LQuaterniond::angle_rad 0 1 1873 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3651 9 angle_deg 0 4 3785 23 LQuaterniond::angle_deg 0 1 1874 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3652 10 operator * 0 4 3785 24 LQuaterniond::operator * 0 4 1875 1876 1877 1878 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3653 10 operator / 0 4 3785 24 LQuaterniond::operator / 0 1 1879 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3654 11 operator *= 0 4 3785 25 LQuaterniond::operator *= 0 1 1880 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3655 7 __pow__ 0 4 3785 21 LQuaterniond::__pow__ 0 1 1881 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3656 12 almost_equal 0 4 3785 26 LQuaterniond::almost_equal 0 2 1882 1883 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3657 17 is_same_direction 0 4 3785 31 LQuaterniond::is_same_direction 0 1 1884 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3658 21 almost_same_direction 0 4 3785 35 LQuaterniond::almost_same_direction 0 1 1885 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3659 6 output 0 4 3785 20 LQuaterniond::output 0 1 1886 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3660 17 extract_to_matrix 0 4 3785 31 LQuaterniond::extract_to_matrix 0 2 1887 1888 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3661 15 set_from_matrix 0 4 3785 29 LQuaterniond::set_from_matrix 0 2 1889 1890 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3662 7 set_hpr 0 4 3785 21 LQuaterniond::set_hpr 0 1 1891 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3663 7 get_hpr 0 4 3785 21 LQuaterniond::get_hpr 0 1 1892 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3664 8 get_axis 0 4 3785 22 LQuaterniond::get_axis 0 1 1893 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3665 19 get_axis_normalized 0 4 3785 33 LQuaterniond::get_axis_normalized 0 1 1894 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3666 13 get_angle_rad 0 4 3785 27 LQuaterniond::get_angle_rad 0 1 1895 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3667 9 get_angle 0 4 3785 23 LQuaterniond::get_angle 0 1 1896 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3668 23 set_from_axis_angle_rad 0 4 3785 37 LQuaterniond::set_from_axis_angle_rad 0 1 1897 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3669 19 set_from_axis_angle 0 4 3785 33 LQuaterniond::set_from_axis_angle 0 1 1898 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3670 6 get_up 0 4 3785 20 LQuaterniond::get_up 0 1 1899 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3671 9 get_right 0 4 3785 23 LQuaterniond::get_right 0 1 1900 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3672 11 get_forward 0 4 3785 25 LQuaterniond::get_forward 0 1 1901 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3673 5 get_r 0 4 3785 19 LQuaterniond::get_r 0 1 1902 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3674 5 get_i 0 4 3785 19 LQuaterniond::get_i 0 1 1903 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3675 5 get_j 0 4 3785 19 LQuaterniond::get_j 0 1 1904 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3676 5 get_k 0 4 3785 19 LQuaterniond::get_k 0 1 1905 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3677 5 set_r 0 4 3785 19 LQuaterniond::set_r 0 1 1906 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3678 5 set_i 0 4 3785 19 LQuaterniond::set_i 0 1 1907 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3679 5 set_j 0 4 3785 19 LQuaterniond::set_j 0 1 1908 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3680 5 set_k 0 4 3785 19 LQuaterniond::set_k 0 1 1909 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3681 9 normalize 0 4 3785 23 LQuaterniond::normalize 0 1 1910 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3682 14 conjugate_from 0 4 3785 28 LQuaterniond::conjugate_from 0 1 1911 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3683 18 conjugate_in_place 0 4 3785 32 LQuaterniond::conjugate_in_place 0 1 1912 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3684 11 invert_from 0 4 3785 25 LQuaterniond::invert_from 0 1 1913 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3685 15 invert_in_place 0 4 3785 29 LQuaterniond::invert_in_place 0 1 1914 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3686 11 is_identity 0 4 3785 25 LQuaterniond::is_identity 0 1 1915 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3687 18 is_almost_identity 0 4 3785 32 LQuaterniond::is_almost_identity 0 1 1916 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3688 10 ident_quat 0 4 3785 24 LQuaterniond::ident_quat 0 1 1917 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3689 14 get_class_type 0 4 3785 28 LQuaterniond::get_class_type 0 1 1918 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3690 13 ~LQuaterniond 0 4 3785 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3691 10 LRotationf 0 4 3786 22 LRotationf::LRotationf 0 9 1919 1920 1921 1922 1923 1924 1925 1926 1927 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3692 10 operator * 0 4 3786 22 LRotationf::operator * 0 3 1928 1929 1930 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3693 10 operator / 0 4 3786 22 LRotationf::operator / 0 1 1931 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3694 14 get_class_type 0 4 3786 26 LRotationf::get_class_type 0 1 1932 0
51
static TypeHandle LRotationf::get_class_type(void);

3695 11 ~LRotationf 0 4 3786 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3696 10 LRotationd 0 4 3787 22 LRotationd::LRotationd 0 9 1933 1934 1935 1936 1937 1938 1939 1940 1941 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3697 10 operator * 0 4 3787 22 LRotationd::operator * 0 3 1942 1943 1944 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3698 10 operator / 0 4 3787 22 LRotationd::operator / 0 1 1945 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3699 14 get_class_type 0 4 3787 26 LRotationd::get_class_type 0 1 1946 0
51
static TypeHandle LRotationd::get_class_type(void);

3700 11 ~LRotationd 0 4 3787 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3701 13 LOrientationf 0 4 3788 28 LOrientationf::LOrientationf 0 7 1947 1948 1949 1950 1951 1952 1953 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3702 10 operator * 0 4 3788 25 LOrientationf::operator * 0 2 1954 1955 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3703 14 get_class_type 0 4 3788 29 LOrientationf::get_class_type 0 1 1956 0
54
static TypeHandle LOrientationf::get_class_type(void);

3704 14 ~LOrientationf 0 4 3788 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3705 13 LOrientationd 0 4 3789 28 LOrientationd::LOrientationd 0 7 1957 1958 1959 1960 1961 1962 1963 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3706 10 operator * 0 4 3789 25 LOrientationd::operator * 0 2 1964 1965 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3707 14 get_class_type 0 4 3789 29 LOrientationd::get_class_type 0 1 1966 0
54
static TypeHandle LOrientationd::get_class_type(void);

3708 14 ~LOrientationd 0 4 3789 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3709 19 ConfigVariableColor 0 4 3860 40 ConfigVariableColor::ConfigVariableColor 0 4 1967 1968 1969 1970 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3710 10 operator = 0 4 3860 31 ConfigVariableColor::operator = 0 1 1971 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3711 17 operator typecast 0 132 3860 38 ConfigVariableColor::operator typecast 0 1 1976 0
43
inline operator LColor const &(void) const;

3712 11 operator [] 0 4 3860 32 ConfigVariableColor::operator [] 0 1 1972 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3713 9 set_value 0 4 3860 30 ConfigVariableColor::set_value 0 1 1973 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3714 9 get_value 0 4 3860 30 ConfigVariableColor::get_value 0 1 1974 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3715 17 get_default_value 0 4 3860 38 ConfigVariableColor::get_default_value 0 1 1975 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3716 20 ~ConfigVariableColor 0 4 3860 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

2066
1 0 0 7 2 3862 2068 0 0 0 
2 0 0 7 2 3862 2068 0 0 1 6 param0 0 3863  
3 0 0 7 8 3865 2141 0 0 0 
4 0 0 7 8 3865 2141 0 0 1 6 param0 0 3866  
5 0 0 7 8 3865 2141 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
6 0 0 7 8 3865 2141 0 10 /**
 *
 */ 2 1 x 1 3720  1 y 1 3720  
7 0 0 4 9 3870 0 0 0 2 4 this 3 3865  4 size 1 3868  
8 0 0 6 12 3865 0 0 0 2 4 this 3 3865  4 copy 1 3866  
9 0 0 6 12 3865 0 0 0 2 4 this 3 3865  10 fill_value 1 3720  
10 0 0 6 13 3866 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3866 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3866 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3871 0 0 0 1 4 this 3 3866  
14 0 0 6 17 3871 0 0 0 2 4 this 3 3866  9 attr_name 1 3874  
15 0 0 6 18 3726 0 0 0 3 4 this 3 3865  9 attr_name 1 3874  6 assign 1 3871  
16 0 0 4 19 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  1 i 1 3726  
17 0 0 6 19 3720 0 0 0 2 4 this 3 3866  1 i 1 3726  
18 0 0 4 20 3870 0 0 0 3 4 this 3 3865  1 i 1 3726  10 assign_val 1 3720  
19 0 0 6 21 3726 0 0 0 0 
20 0 0 6 22 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3866  
21 0 0 6 23 3720 0 0 10 /**
 *
 */ 2 4 this 3 3866  1 i 1 3726  
22 0 0 4 24 3870 0 0 10 /**
 *
 */ 3 4 this 3 3865  1 i 1 3726  5 value 1 3720  
23 0 0 6 25 3720 0 0 10 /**
 *
 */ 1 4 this 3 3866  
24 0 0 6 26 3720 0 0 10 /**
 *
 */ 1 4 this 3 3866  
25 0 0 4 27 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  5 value 1 3720  
26 0 0 4 28 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  5 value 1 3720  
27 0 0 4 32 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3865  1 i 1 3726  5 value 1 3720  
28 0 0 4 33 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  5 value 1 3720  
29 0 0 4 34 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  5 value 1 3720  
30 0 0 4 35 3870 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3866  
31 0 0 6 36 3726 0 0 0 0 
32 0 0 4 37 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3865  10 fill_value 1 3720  
33 0 0 4 38 3870 0 0 10 /**
 *
 */ 3 4 this 3 3865  1 x 1 3720  1 y 1 3720  
34 0 0 6 39 3720 0 0 10 /**
 *
 */ 2 4 this 3 3866  5 other 1 3866  
35 0 0 6 40 3720 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3866  
36 0 0 6 41 3720 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3866  
37 0 0 6 42 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3865  
38 0 0 7 43 3865 2141 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3866  
39 0 0 7 44 3865 2141 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3866  4 onto 1 3866  
40 0 0 6 45 3875 0 0 0 2 4 this 3 3866  5 other 1 3866  
41 0 0 6 46 3875 0 0 0 2 4 this 3 3866  5 other 1 3866  
42 0 0 6 47 3875 0 0 0 2 4 this 3 3866  5 other 1 3866  
43 0 0 6 48 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3866  5 other 1 3866  
44 0 0 6 48 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3720  
45 0 0 6 49 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3866  
46 0 0 6 49 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3866  9 threshold 1 3720  
47 0 0 6 50 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3866  4 hash 1 3868  
48 0 0 6 50 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3866  4 hash 1 3868  9 threshold 1 3720  
49 0 0 4 51 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3866  7 hashgen 1 3876  
50 0 0 4 51 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3866  7 hashgen 1 3876  9 threshold 1 3720  
51 0 0 7 52 3865 2141 0 0 1 4 this 3 3866  
52 0 0 7 53 3865 2141 0 0 2 4 this 3 3866  5 other 1 3866  
53 0 0 7 54 3865 2141 0 0 2 4 this 3 3866  5 other 1 3866  
54 0 0 7 55 3865 2141 0 0 2 4 this 3 3866  6 scalar 1 3720  
55 0 0 7 56 3865 2141 0 0 2 4 this 3 3866  6 scalar 1 3720  
56 0 0 6 57 3865 0 0 0 2 4 this 3 3865  5 other 1 3866  
57 0 0 6 58 3865 0 0 0 2 4 this 3 3865  5 other 1 3866  
58 0 0 6 59 3865 0 0 0 2 4 this 3 3865  6 scalar 1 3720  
59 0 0 6 60 3865 0 0 0 2 4 this 3 3865  6 scalar 1 3720  
60 0 0 4 61 3870 0 0 10 /**
 *
 */ 2 4 this 3 3865  5 other 1 3866  
61 0 0 6 62 3871 0 0 0 2 4 this 3 3866  6 scalar 1 3720  
62 0 0 6 63 3871 0 0 0 2 4 this 3 3866  6 scalar 1 3720  
63 0 0 6 64 3871 0 0 0 2 4 this 3 3865  6 scalar 1 3720  
64 0 0 6 65 3871 0 0 0 2 4 this 3 3866  8 exponent 1 3720  
65 0 0 6 66 3871 0 0 0 2 4 this 3 3865  8 exponent 1 3720  
66 0 0 6 67 3871 0 0 0 1 4 this 3 3865  
67 0 0 6 68 3871 0 0 0 1 4 this 3 3865  
68 0 0 6 69 3871 0 0 0 1 4 this 3 3865  
69 0 0 7 70 3865 2141 0 10 /**
 *
 */ 2 4 this 3 3866  5 other 1 3866  
70 0 0 7 71 3865 2141 0 10 /**
 *
 */ 2 4 this 3 3866  5 other 1 3866  
71 0 0 6 72 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3866  5 other 1 3866  
72 0 0 6 72 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3720  
73 0 0 4 73 3870 0 0 10 /**
 *
 */ 2 4 this 3 3866  3 out 1 3878  
74 0 0 6 74 3874 0 0 0 1 4 this 3 3866  
75 0 0 4 75 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3866  11 destination 1 3880  
76 0 0 4 76 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3865  6 source 1 3882  
77 0 0 4 77 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3866  11 destination 1 3880  
78 0 0 4 78 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3865  6 source 1 3882  
79 0 0 6 79 3726 0 0 0 3 4 this 3 3866  4 view 1 3884  5 flags 1 3726  
80 0 0 7 80 3888 0 0 0 0 
81 0 0 7 84 3889 2212 0 0 0 
82 0 0 7 84 3889 2212 0 0 1 6 param0 0 3890  
83 0 0 7 84 3889 2212 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
84 0 0 7 84 3889 2212 0 10 /**
 *
 */ 2 1 x 1 3723  1 y 1 3723  
85 0 0 4 85 3870 0 0 0 2 4 this 3 3889  4 size 1 3868  
86 0 0 6 88 3889 0 0 0 2 4 this 3 3889  4 copy 1 3890  
87 0 0 6 88 3889 0 0 0 2 4 this 3 3889  10 fill_value 1 3723  
88 0 0 6 89 3890 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
89 0 0 6 90 3890 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
90 0 0 6 91 3890 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
91 0 0 6 92 3871 0 0 0 1 4 this 3 3890  
92 0 0 6 93 3871 0 0 0 2 4 this 3 3890  9 attr_name 1 3874  
93 0 0 6 94 3726 0 0 0 3 4 this 3 3889  9 attr_name 1 3874  6 assign 1 3871  
94 0 0 4 95 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  1 i 1 3726  
95 0 0 6 95 3723 0 0 0 2 4 this 3 3890  1 i 1 3726  
96 0 0 4 96 3870 0 0 0 3 4 this 3 3889  1 i 1 3726  10 assign_val 1 3723  
97 0 0 6 97 3726 0 0 0 0 
98 0 0 6 98 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3890  
99 0 0 6 99 3723 0 0 10 /**
 *
 */ 2 4 this 3 3890  1 i 1 3726  
100 0 0 4 100 3870 0 0 10 /**
 *
 */ 3 4 this 3 3889  1 i 1 3726  5 value 1 3723  
101 0 0 6 101 3723 0 0 10 /**
 *
 */ 1 4 this 3 3890  
102 0 0 6 102 3723 0 0 10 /**
 *
 */ 1 4 this 3 3890  
103 0 0 4 103 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  5 value 1 3723  
104 0 0 4 104 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  5 value 1 3723  
105 0 0 4 108 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3889  1 i 1 3726  5 value 1 3723  
106 0 0 4 109 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  5 value 1 3723  
107 0 0 4 110 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  5 value 1 3723  
108 0 0 4 111 3870 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3890  
109 0 0 6 112 3726 0 0 0 0 
110 0 0 4 113 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3889  10 fill_value 1 3723  
111 0 0 4 114 3870 0 0 10 /**
 *
 */ 3 4 this 3 3889  1 x 1 3723  1 y 1 3723  
112 0 0 6 115 3723 0 0 10 /**
 *
 */ 2 4 this 3 3890  5 other 1 3890  
113 0 0 6 116 3723 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3890  
114 0 0 6 117 3723 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3890  
115 0 0 6 118 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3889  
116 0 0 7 119 3889 2212 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3890  
117 0 0 7 120 3889 2212 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3890  4 onto 1 3890  
118 0 0 6 121 3875 0 0 0 2 4 this 3 3890  5 other 1 3890  
119 0 0 6 122 3875 0 0 0 2 4 this 3 3890  5 other 1 3890  
120 0 0 6 123 3875 0 0 0 2 4 this 3 3890  5 other 1 3890  
121 0 0 6 124 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3890  5 other 1 3890  
122 0 0 6 124 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3890  5 other 1 3890  9 threshold 1 3723  
123 0 0 6 125 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3890  
124 0 0 6 125 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3890  9 threshold 1 3723  
125 0 0 6 126 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3890  4 hash 1 3868  
126 0 0 6 126 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3890  4 hash 1 3868  9 threshold 1 3723  
127 0 0 4 127 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3890  7 hashgen 1 3876  
128 0 0 4 127 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3890  7 hashgen 1 3876  9 threshold 1 3723  
129 0 0 7 128 3889 2212 0 0 1 4 this 3 3890  
130 0 0 7 129 3889 2212 0 0 2 4 this 3 3890  5 other 1 3890  
131 0 0 7 130 3889 2212 0 0 2 4 this 3 3890  5 other 1 3890  
132 0 0 7 131 3889 2212 0 0 2 4 this 3 3890  6 scalar 1 3723  
133 0 0 7 132 3889 2212 0 0 2 4 this 3 3890  6 scalar 1 3723  
134 0 0 6 133 3889 0 0 0 2 4 this 3 3889  5 other 1 3890  
135 0 0 6 134 3889 0 0 0 2 4 this 3 3889  5 other 1 3890  
136 0 0 6 135 3889 0 0 0 2 4 this 3 3889  6 scalar 1 3723  
137 0 0 6 136 3889 0 0 0 2 4 this 3 3889  6 scalar 1 3723  
138 0 0 4 137 3870 0 0 10 /**
 *
 */ 2 4 this 3 3889  5 other 1 3890  
139 0 0 6 138 3871 0 0 0 2 4 this 3 3890  6 scalar 1 3723  
140 0 0 6 139 3871 0 0 0 2 4 this 3 3890  6 scalar 1 3723  
141 0 0 6 140 3871 0 0 0 2 4 this 3 3889  6 scalar 1 3723  
142 0 0 6 141 3871 0 0 0 2 4 this 3 3890  8 exponent 1 3723  
143 0 0 6 142 3871 0 0 0 2 4 this 3 3889  8 exponent 1 3723  
144 0 0 6 143 3871 0 0 0 1 4 this 3 3889  
145 0 0 6 144 3871 0 0 0 1 4 this 3 3889  
146 0 0 6 145 3871 0 0 0 1 4 this 3 3889  
147 0 0 7 146 3889 2212 0 10 /**
 *
 */ 2 4 this 3 3890  5 other 1 3890  
148 0 0 7 147 3889 2212 0 10 /**
 *
 */ 2 4 this 3 3890  5 other 1 3890  
149 0 0 6 148 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3890  5 other 1 3890  
150 0 0 6 148 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3890  5 other 1 3890  9 threshold 1 3723  
151 0 0 4 149 3870 0 0 10 /**
 *
 */ 2 4 this 3 3890  3 out 1 3878  
152 0 0 6 150 3874 0 0 0 1 4 this 3 3890  
153 0 0 4 151 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3890  11 destination 1 3880  
154 0 0 4 152 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3889  6 source 1 3882  
155 0 0 4 153 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3890  11 destination 1 3880  
156 0 0 4 154 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3889  6 source 1 3882  
157 0 0 6 155 3726 0 0 0 3 4 this 3 3890  4 view 1 3884  5 flags 1 3726  
158 0 0 7 156 3888 0 0 0 0 
159 0 0 7 160 3892 2279 0 0 0 
160 0 0 7 160 3892 2279 0 0 1 6 param0 0 3893  
161 0 0 7 160 3892 2279 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
162 0 0 7 160 3892 2279 0 10 /**
 *
 */ 2 1 x 1 3726  1 y 1 3726  
163 0 0 4 161 3870 0 0 0 2 4 this 3 3892  4 size 1 3868  
164 0 0 6 164 3892 0 0 0 2 4 this 3 3892  4 copy 1 3893  
165 0 0 6 164 3892 0 0 0 2 4 this 3 3892  10 fill_value 1 3726  
166 0 0 6 165 3893 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
167 0 0 6 166 3893 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
168 0 0 6 167 3893 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
169 0 0 6 168 3871 0 0 0 1 4 this 3 3893  
170 0 0 6 169 3871 0 0 0 2 4 this 3 3893  9 attr_name 1 3874  
171 0 0 6 170 3726 0 0 0 3 4 this 3 3892  9 attr_name 1 3874  6 assign 1 3871  
172 0 0 4 171 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  1 i 1 3726  
173 0 0 6 171 3726 0 0 0 2 4 this 3 3893  1 i 1 3726  
174 0 0 4 172 3870 0 0 0 3 4 this 3 3892  1 i 1 3726  10 assign_val 1 3726  
175 0 0 6 173 3726 0 0 0 0 
176 0 0 6 174 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3893  
177 0 0 6 175 3726 0 0 10 /**
 *
 */ 2 4 this 3 3893  1 i 1 3726  
178 0 0 4 176 3870 0 0 10 /**
 *
 */ 3 4 this 3 3892  1 i 1 3726  5 value 1 3726  
179 0 0 6 177 3726 0 0 10 /**
 *
 */ 1 4 this 3 3893  
180 0 0 6 178 3726 0 0 10 /**
 *
 */ 1 4 this 3 3893  
181 0 0 4 179 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  5 value 1 3726  
182 0 0 4 180 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  5 value 1 3726  
183 0 0 4 184 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3892  1 i 1 3726  5 value 1 3726  
184 0 0 4 185 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  5 value 1 3726  
185 0 0 4 186 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  5 value 1 3726  
186 0 0 4 187 3870 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3893  
187 0 0 6 188 3726 0 0 0 0 
188 0 0 4 189 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3892  10 fill_value 1 3726  
189 0 0 4 190 3870 0 0 10 /**
 *
 */ 3 4 this 3 3892  1 x 1 3726  1 y 1 3726  
190 0 0 6 191 3726 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3893  
191 0 0 6 192 3726 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3893  
192 0 0 6 193 3875 0 0 0 2 4 this 3 3893  5 other 1 3893  
193 0 0 6 194 3875 0 0 0 2 4 this 3 3893  5 other 1 3893  
194 0 0 6 195 3875 0 0 0 2 4 this 3 3893  5 other 1 3893  
195 0 0 6 196 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3893  5 other 1 3893  
196 0 0 6 197 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3893  
197 0 0 6 198 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3893  4 hash 1 3868  
198 0 0 4 199 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3893  7 hashgen 1 3876  
199 0 0 7 200 3892 2279 0 0 1 4 this 3 3893  
200 0 0 7 201 3892 2279 0 0 2 4 this 3 3893  5 other 1 3893  
201 0 0 7 202 3892 2279 0 0 2 4 this 3 3893  5 other 1 3893  
202 0 0 7 203 3892 2279 0 0 2 4 this 3 3893  6 scalar 1 3726  
203 0 0 7 204 3892 2279 0 0 2 4 this 3 3893  6 scalar 1 3726  
204 0 0 6 205 3892 0 0 0 2 4 this 3 3892  5 other 1 3893  
205 0 0 6 206 3892 0 0 0 2 4 this 3 3892  5 other 1 3893  
206 0 0 6 207 3892 0 0 0 2 4 this 3 3892  6 scalar 1 3726  
207 0 0 6 208 3892 0 0 0 2 4 this 3 3892  6 scalar 1 3726  
208 0 0 4 209 3870 0 0 10 /**
 *
 */ 2 4 this 3 3892  5 other 1 3893  
209 0 0 6 210 3871 0 0 0 2 4 this 3 3893  6 scalar 1 3726  
210 0 0 6 211 3871 0 0 0 2 4 this 3 3893  6 scalar 1 3726  
211 0 0 6 212 3871 0 0 0 2 4 this 3 3892  6 scalar 1 3726  
212 0 0 6 213 3871 0 0 0 2 4 this 3 3893  8 exponent 1 3726  
213 0 0 6 214 3871 0 0 0 2 4 this 3 3892  8 exponent 1 3726  
214 0 0 6 215 3871 0 0 0 1 4 this 3 3892  
215 0 0 6 216 3871 0 0 0 1 4 this 3 3892  
216 0 0 6 217 3871 0 0 0 1 4 this 3 3892  
217 0 0 7 218 3892 2279 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3893  
218 0 0 7 219 3892 2279 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3893  
219 0 0 6 220 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3893  5 other 1 3893  
220 0 0 6 220 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3893  5 other 1 3893  9 threshold 1 3726  
221 0 0 4 221 3870 0 0 10 /**
 *
 */ 2 4 this 3 3893  3 out 1 3878  
222 0 0 6 222 3874 0 0 0 1 4 this 3 3893  
223 0 0 4 223 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3893  11 destination 1 3880  
224 0 0 4 224 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3892  6 source 1 3882  
225 0 0 4 225 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3893  11 destination 1 3880  
226 0 0 4 226 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3892  6 source 1 3882  
227 0 0 6 227 3726 0 0 0 3 4 this 3 3893  4 view 1 3884  5 flags 1 3726  
228 0 0 7 228 3888 0 0 0 0 
229 0 0 7 231 3895 2298 0 0 0 
230 0 0 7 231 3895 2298 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3866  
231 0 0 7 231 3895 2298 0 0 1 6 param0 0 3896  
232 0 0 7 231 3895 2298 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3720  
233 0 0 7 231 3895 2298 0 10 /**
 *
 */ 2 1 x 1 3720  1 y 1 3720  
234 0 0 6 232 3871 0 0 0 2 4 this 3 3896  9 attr_name 1 3874  
235 0 0 6 233 3726 0 0 0 3 4 this 3 3895  9 attr_name 1 3874  6 assign 1 3871  
236 0 0 6 234 3896 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
237 0 0 6 235 3896 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
238 0 0 6 236 3896 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
239 0 0 7 237 3895 2298 0 0 1 4 this 3 3896  
240 0 0 7 238 3865 2141 0 0 2 4 this 3 3896  5 other 1 3866  
241 0 0 7 238 3895 2298 0 0 2 4 this 3 3896  5 other 1 3896  
242 0 0 7 239 3865 2141 0 0 2 4 this 3 3896  5 other 1 3866  
243 0 0 7 239 3895 2298 0 0 2 4 this 3 3896  5 other 1 3896  
244 0 0 7 240 3895 2298 0 0 2 4 this 3 3896  6 scalar 1 3720  
245 0 0 7 241 3895 2298 0 0 2 4 this 3 3896  6 scalar 1 3720  
246 0 0 7 242 3895 2298 0 0 2 4 this 3 3896  6 scalar 1 3720  
247 0 0 7 243 3895 2298 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3896  
248 0 0 7 244 3895 2298 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3896  4 onto 1 3866  
249 0 0 6 245 3720 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3896  5 other 1 3896  
250 0 0 6 246 3720 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3896  5 other 1 3896  
251 0 0 6 247 3874 0 0 0 1 4 this 3 3896  
252 0 0 7 248 3888 0 0 0 0 
253 0 0 7 251 3898 2317 0 0 0 
254 0 0 7 251 3898 2317 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3890  
255 0 0 7 251 3898 2317 0 0 1 6 param0 0 3899  
256 0 0 7 251 3898 2317 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3723  
257 0 0 7 251 3898 2317 0 10 /**
 *
 */ 2 1 x 1 3723  1 y 1 3723  
258 0 0 6 252 3871 0 0 0 2 4 this 3 3899  9 attr_name 1 3874  
259 0 0 6 253 3726 0 0 0 3 4 this 3 3898  9 attr_name 1 3874  6 assign 1 3871  
260 0 0 6 254 3899 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
261 0 0 6 255 3899 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
262 0 0 6 256 3899 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
263 0 0 7 257 3898 2317 0 0 1 4 this 3 3899  
264 0 0 7 258 3889 2212 0 0 2 4 this 3 3899  5 other 1 3890  
265 0 0 7 258 3898 2317 0 0 2 4 this 3 3899  5 other 1 3899  
266 0 0 7 259 3889 2212 0 0 2 4 this 3 3899  5 other 1 3890  
267 0 0 7 259 3898 2317 0 0 2 4 this 3 3899  5 other 1 3899  
268 0 0 7 260 3898 2317 0 0 2 4 this 3 3899  6 scalar 1 3723  
269 0 0 7 261 3898 2317 0 0 2 4 this 3 3899  6 scalar 1 3723  
270 0 0 7 262 3898 2317 0 0 2 4 this 3 3899  6 scalar 1 3723  
271 0 0 7 263 3898 2317 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3899  
272 0 0 7 264 3898 2317 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3899  4 onto 1 3890  
273 0 0 6 265 3723 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3899  5 other 1 3899  
274 0 0 6 266 3723 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3899  5 other 1 3899  
275 0 0 6 267 3874 0 0 0 1 4 this 3 3899  
276 0 0 7 268 3888 0 0 0 0 
277 0 0 7 271 3901 2332 0 0 0 
278 0 0 7 271 3901 2332 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3893  
279 0 0 7 271 3901 2332 0 0 1 6 param0 0 3902  
280 0 0 7 271 3901 2332 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3726  
281 0 0 7 271 3901 2332 0 10 /**
 *
 */ 2 1 x 1 3726  1 y 1 3726  
282 0 0 6 272 3871 0 0 0 2 4 this 3 3902  9 attr_name 1 3874  
283 0 0 6 273 3726 0 0 0 3 4 this 3 3901  9 attr_name 1 3874  6 assign 1 3871  
284 0 0 6 274 3902 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
285 0 0 6 275 3902 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
286 0 0 6 276 3902 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
287 0 0 7 277 3901 2332 0 0 1 4 this 3 3902  
288 0 0 7 278 3892 2279 0 0 2 4 this 3 3902  5 other 1 3893  
289 0 0 7 278 3901 2332 0 0 2 4 this 3 3902  5 other 1 3902  
290 0 0 7 279 3892 2279 0 0 2 4 this 3 3902  5 other 1 3893  
291 0 0 7 279 3901 2332 0 0 2 4 this 3 3902  5 other 1 3902  
292 0 0 7 280 3901 2332 0 0 2 4 this 3 3902  6 scalar 1 3726  
293 0 0 7 281 3901 2332 0 0 2 4 this 3 3902  6 scalar 1 3726  
294 0 0 7 282 3901 2332 0 0 2 4 this 3 3902  6 scalar 1 3726  
295 0 0 6 283 3874 0 0 0 1 4 this 3 3902  
296 0 0 7 284 3888 0 0 0 0 
297 0 0 7 287 3904 2349 0 0 0 
298 0 0 7 287 3904 2349 0 0 1 6 param0 0 3905  
299 0 0 7 287 3904 2349 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3866  
300 0 0 7 287 3904 2349 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3720  
301 0 0 7 287 3904 2349 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3720  1 y 1 3720  
302 0 0 6 288 3871 0 0 0 2 4 this 3 3905  9 attr_name 1 3874  
303 0 0 6 289 3726 0 0 0 3 4 this 3 3904  9 attr_name 1 3874  6 assign 1 3871  
304 0 0 6 290 3905 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
305 0 0 6 291 3905 0 0 34 /**
 * Returns a unit X point.
 */ 0 
306 0 0 6 292 3905 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
307 0 0 7 293 3904 2349 0 0 1 4 this 3 3905  
308 0 0 7 294 3865 2141 0 0 2 4 this 3 3905  5 other 1 3866  
309 0 0 7 294 3904 2349 0 0 2 4 this 3 3905  5 other 1 3896  
310 0 0 7 295 3895 2298 0 0 2 4 this 3 3905  5 other 1 3905  
311 0 0 7 295 3865 2141 0 0 2 4 this 3 3905  5 other 1 3866  
312 0 0 7 295 3904 2349 0 0 2 4 this 3 3905  5 other 1 3896  
313 0 0 7 296 3904 2349 0 0 2 4 this 3 3905  6 scalar 1 3720  
314 0 0 7 297 3904 2349 0 0 2 4 this 3 3905  6 scalar 1 3720  
315 0 0 7 298 3904 2349 0 0 2 4 this 3 3905  6 scalar 1 3720  
316 0 0 7 299 3904 2349 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3905  
317 0 0 7 300 3904 2349 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3905  4 onto 1 3866  
318 0 0 6 301 3874 0 0 0 1 4 this 3 3905  
319 0 0 7 302 3888 0 0 0 0 
320 0 0 7 305 3907 2366 0 0 0 
321 0 0 7 305 3907 2366 0 0 1 6 param0 0 3908  
322 0 0 7 305 3907 2366 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3890  
323 0 0 7 305 3907 2366 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3723  
324 0 0 7 305 3907 2366 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3723  1 y 1 3723  
325 0 0 6 306 3871 0 0 0 2 4 this 3 3908  9 attr_name 1 3874  
326 0 0 6 307 3726 0 0 0 3 4 this 3 3907  9 attr_name 1 3874  6 assign 1 3871  
327 0 0 6 308 3908 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
328 0 0 6 309 3908 0 0 34 /**
 * Returns a unit X point.
 */ 0 
329 0 0 6 310 3908 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
330 0 0 7 311 3907 2366 0 0 1 4 this 3 3908  
331 0 0 7 312 3889 2212 0 0 2 4 this 3 3908  5 other 1 3890  
332 0 0 7 312 3907 2366 0 0 2 4 this 3 3908  5 other 1 3899  
333 0 0 7 313 3898 2317 0 0 2 4 this 3 3908  5 other 1 3908  
334 0 0 7 313 3889 2212 0 0 2 4 this 3 3908  5 other 1 3890  
335 0 0 7 313 3907 2366 0 0 2 4 this 3 3908  5 other 1 3899  
336 0 0 7 314 3907 2366 0 0 2 4 this 3 3908  6 scalar 1 3723  
337 0 0 7 315 3907 2366 0 0 2 4 this 3 3908  6 scalar 1 3723  
338 0 0 7 316 3907 2366 0 0 2 4 this 3 3908  6 scalar 1 3723  
339 0 0 7 317 3907 2366 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3908  
340 0 0 7 318 3907 2366 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3908  4 onto 1 3890  
341 0 0 6 319 3874 0 0 0 1 4 this 3 3908  
342 0 0 7 320 3888 0 0 0 0 
343 0 0 7 323 3910 2381 0 0 0 
344 0 0 7 323 3910 2381 0 0 1 6 param0 0 3911  
345 0 0 7 323 3910 2381 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3893  
346 0 0 7 323 3910 2381 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3726  
347 0 0 7 323 3910 2381 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3726  1 y 1 3726  
348 0 0 6 324 3871 0 0 0 2 4 this 3 3911  9 attr_name 1 3874  
349 0 0 6 325 3726 0 0 0 3 4 this 3 3910  9 attr_name 1 3874  6 assign 1 3871  
350 0 0 6 326 3911 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
351 0 0 6 327 3911 0 0 34 /**
 * Returns a unit X point.
 */ 0 
352 0 0 6 328 3911 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
353 0 0 7 329 3910 2381 0 0 1 4 this 3 3911  
354 0 0 7 330 3892 2279 0 0 2 4 this 3 3911  5 other 1 3893  
355 0 0 7 330 3910 2381 0 0 2 4 this 3 3911  5 other 1 3902  
356 0 0 7 331 3901 2332 0 0 2 4 this 3 3911  5 other 1 3911  
357 0 0 7 331 3892 2279 0 0 2 4 this 3 3911  5 other 1 3893  
358 0 0 7 331 3910 2381 0 0 2 4 this 3 3911  5 other 1 3902  
359 0 0 7 332 3910 2381 0 0 2 4 this 3 3911  6 scalar 1 3726  
360 0 0 7 333 3910 2381 0 0 2 4 this 3 3911  6 scalar 1 3726  
361 0 0 7 334 3910 2381 0 0 2 4 this 3 3911  6 scalar 1 3726  
362 0 0 6 335 3874 0 0 0 1 4 this 3 3911  
363 0 0 7 336 3888 0 0 0 0 
364 0 0 7 340 3913 2462 0 0 0 
365 0 0 7 340 3913 2462 0 10 /**
 *
 */ 2 4 copy 1 3866  1 z 1 3720  
366 0 0 7 340 3913 2462 0 0 1 6 param0 0 3914  
367 0 0 7 340 3913 2462 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
368 0 0 7 340 3913 2462 0 10 /**
 *
 */ 3 1 x 1 3720  1 y 1 3720  1 z 1 3720  
369 0 0 4 341 3870 0 0 0 2 4 this 3 3913  4 size 1 3868  
370 0 0 6 344 3913 0 0 0 2 4 this 3 3913  4 copy 1 3914  
371 0 0 6 344 3913 0 0 0 2 4 this 3 3913  10 fill_value 1 3720  
372 0 0 6 345 3914 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
373 0 0 6 346 3914 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
374 0 0 6 347 3914 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
375 0 0 6 348 3914 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
376 0 0 6 349 3871 0 0 0 1 4 this 3 3914  
377 0 0 6 350 3871 0 0 0 2 4 this 3 3914  9 attr_name 1 3874  
378 0 0 6 351 3726 0 0 0 3 4 this 3 3913  9 attr_name 1 3874  6 assign 1 3871  
379 0 0 4 352 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  1 i 1 3726  
380 0 0 6 352 3720 0 0 0 2 4 this 3 3914  1 i 1 3726  
381 0 0 4 353 3870 0 0 0 3 4 this 3 3913  1 i 1 3726  10 assign_val 1 3720  
382 0 0 6 354 3726 0 0 0 0 
383 0 0 6 355 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3914  
384 0 0 6 356 3720 0 0 10 /**
 *
 */ 2 4 this 3 3914  1 i 1 3726  
385 0 0 6 357 3720 0 0 10 /**
 *
 */ 1 4 this 3 3914  
386 0 0 6 358 3720 0 0 10 /**
 *
 */ 1 4 this 3 3914  
387 0 0 6 359 3720 0 0 10 /**
 *
 */ 1 4 this 3 3914  
388 0 0 4 360 3870 0 0 10 /**
 *
 */ 3 4 this 3 3913  1 i 1 3726  5 value 1 3720  
389 0 0 4 361 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
390 0 0 4 362 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
391 0 0 4 363 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
392 0 0 7 364 3865 2141 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3914  
393 0 0 7 365 3865 2141 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3914  
394 0 0 7 366 3865 2141 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3914  
395 0 0 4 373 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3913  1 i 1 3726  5 value 1 3720  
396 0 0 4 374 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
397 0 0 4 375 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
398 0 0 4 376 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 value 1 3720  
399 0 0 4 377 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3914  
400 0 0 6 378 3726 0 0 0 0 
401 0 0 4 379 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3913  10 fill_value 1 3720  
402 0 0 4 380 3870 0 0 10 /**
 *
 */ 4 4 this 3 3913  1 x 1 3720  1 y 1 3720  1 z 1 3720  
403 0 0 6 381 3720 0 0 10 /**
 *
 */ 2 4 this 3 3914  5 other 1 3914  
404 0 0 6 382 3720 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3914  
405 0 0 6 383 3720 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3914  
406 0 0 6 384 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3913  
407 0 0 7 385 3913 2462 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3914  
408 0 0 7 386 3913 2462 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3914  4 onto 1 3914  
409 0 0 7 387 3913 2462 0 10 /**
 *
 */ 2 4 this 3 3914  5 other 1 3914  
410 0 0 6 388 3875 0 0 0 2 4 this 3 3914  5 other 1 3914  
411 0 0 6 389 3875 0 0 0 2 4 this 3 3914  5 other 1 3914  
412 0 0 6 390 3875 0 0 0 2 4 this 3 3914  5 other 1 3914  
413 0 0 7 391 3913 2462 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3914  
414 0 0 6 392 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3914  5 other 1 3914  
415 0 0 6 392 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3914  5 other 1 3914  9 threshold 1 3720  
416 0 0 6 393 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3914  
417 0 0 6 393 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3914  9 threshold 1 3720  
418 0 0 6 394 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3914  4 hash 1 3868  
419 0 0 6 394 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3914  4 hash 1 3868  9 threshold 1 3720  
420 0 0 4 395 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3914  7 hashgen 1 3876  
421 0 0 4 395 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3914  7 hashgen 1 3876  9 threshold 1 3720  
422 0 0 7 396 3913 2462 0 0 1 4 this 3 3914  
423 0 0 7 397 3913 2462 0 0 2 4 this 3 3914  5 other 1 3914  
424 0 0 7 398 3913 2462 0 0 2 4 this 3 3914  5 other 1 3914  
425 0 0 7 399 3913 2462 0 0 2 4 this 3 3914  6 scalar 1 3720  
426 0 0 7 400 3913 2462 0 0 2 4 this 3 3914  6 scalar 1 3720  
427 0 0 6 401 3913 0 0 0 2 4 this 3 3913  5 other 1 3914  
428 0 0 6 402 3913 0 0 0 2 4 this 3 3913  5 other 1 3914  
429 0 0 6 403 3913 0 0 0 2 4 this 3 3913  6 scalar 1 3720  
430 0 0 6 404 3913 0 0 0 2 4 this 3 3913  6 scalar 1 3720  
431 0 0 4 405 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 other 1 3914  
432 0 0 6 406 3871 0 0 0 2 4 this 3 3914  6 scalar 1 3720  
433 0 0 6 407 3871 0 0 0 2 4 this 3 3914  6 scalar 1 3720  
434 0 0 6 408 3871 0 0 0 2 4 this 3 3913  6 scalar 1 3720  
435 0 0 6 409 3871 0 0 0 2 4 this 3 3914  8 exponent 1 3720  
436 0 0 6 410 3871 0 0 0 2 4 this 3 3913  8 exponent 1 3720  
437 0 0 6 411 3871 0 0 0 1 4 this 3 3913  
438 0 0 6 412 3871 0 0 0 1 4 this 3 3913  
439 0 0 6 413 3871 0 0 0 1 4 this 3 3913  
440 0 0 7 414 3913 2462 0 10 /**
 *
 */ 2 4 this 3 3914  5 other 1 3914  
441 0 0 7 415 3913 2462 0 10 /**
 *
 */ 2 4 this 3 3914  5 other 1 3914  
442 0 0 4 416 3870 0 0 10 /**
 *
 */ 2 4 this 3 3913  5 other 1 3914  
443 0 0 6 417 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3914  5 other 1 3914  
444 0 0 6 417 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3914  5 other 1 3914  9 threshold 1 3720  
445 0 0 4 418 3870 0 0 10 /**
 *
 */ 2 4 this 3 3914  3 out 1 3878  
446 0 0 6 419 3874 0 0 0 1 4 this 3 3914  
447 0 0 4 420 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3914  11 destination 1 3880  
448 0 0 4 421 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3913  6 source 1 3882  
449 0 0 4 422 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3914  11 destination 1 3880  
450 0 0 4 423 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3913  6 source 1 3882  
451 0 0 6 424 3726 0 0 0 3 4 this 3 3914  4 view 1 3884  5 flags 1 3726  
452 0 0 7 425 3888 0 0 0 0 
453 0 0 7 429 3916 2543 0 0 0 
454 0 0 7 429 3916 2543 0 10 /**
 *
 */ 2 4 copy 1 3890  1 z 1 3723  
455 0 0 7 429 3916 2543 0 0 1 6 param0 0 3917  
456 0 0 7 429 3916 2543 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
457 0 0 7 429 3916 2543 0 10 /**
 *
 */ 3 1 x 1 3723  1 y 1 3723  1 z 1 3723  
458 0 0 4 430 3870 0 0 0 2 4 this 3 3916  4 size 1 3868  
459 0 0 6 433 3916 0 0 0 2 4 this 3 3916  4 copy 1 3917  
460 0 0 6 433 3916 0 0 0 2 4 this 3 3916  10 fill_value 1 3723  
461 0 0 6 434 3917 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
462 0 0 6 435 3917 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
463 0 0 6 436 3917 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
464 0 0 6 437 3917 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
465 0 0 6 438 3871 0 0 0 1 4 this 3 3917  
466 0 0 6 439 3871 0 0 0 2 4 this 3 3917  9 attr_name 1 3874  
467 0 0 6 440 3726 0 0 0 3 4 this 3 3916  9 attr_name 1 3874  6 assign 1 3871  
468 0 0 4 441 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  1 i 1 3726  
469 0 0 6 441 3723 0 0 0 2 4 this 3 3917  1 i 1 3726  
470 0 0 4 442 3870 0 0 0 3 4 this 3 3916  1 i 1 3726  10 assign_val 1 3723  
471 0 0 6 443 3726 0 0 0 0 
472 0 0 6 444 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3917  
473 0 0 6 445 3723 0 0 10 /**
 *
 */ 2 4 this 3 3917  1 i 1 3726  
474 0 0 6 446 3723 0 0 10 /**
 *
 */ 1 4 this 3 3917  
475 0 0 6 447 3723 0 0 10 /**
 *
 */ 1 4 this 3 3917  
476 0 0 6 448 3723 0 0 10 /**
 *
 */ 1 4 this 3 3917  
477 0 0 4 449 3870 0 0 10 /**
 *
 */ 3 4 this 3 3916  1 i 1 3726  5 value 1 3723  
478 0 0 4 450 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
479 0 0 4 451 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
480 0 0 4 452 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
481 0 0 7 453 3889 2212 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3917  
482 0 0 7 454 3889 2212 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3917  
483 0 0 7 455 3889 2212 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3917  
484 0 0 4 462 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3916  1 i 1 3726  5 value 1 3723  
485 0 0 4 463 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
486 0 0 4 464 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
487 0 0 4 465 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 value 1 3723  
488 0 0 4 466 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3917  
489 0 0 6 467 3726 0 0 0 0 
490 0 0 4 468 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3916  10 fill_value 1 3723  
491 0 0 4 469 3870 0 0 10 /**
 *
 */ 4 4 this 3 3916  1 x 1 3723  1 y 1 3723  1 z 1 3723  
492 0 0 6 470 3723 0 0 10 /**
 *
 */ 2 4 this 3 3917  5 other 1 3917  
493 0 0 6 471 3723 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3917  
494 0 0 6 472 3723 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3917  
495 0 0 6 473 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3916  
496 0 0 7 474 3916 2543 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3917  
497 0 0 7 475 3916 2543 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3917  4 onto 1 3917  
498 0 0 7 476 3916 2543 0 10 /**
 *
 */ 2 4 this 3 3917  5 other 1 3917  
499 0 0 6 477 3875 0 0 0 2 4 this 3 3917  5 other 1 3917  
500 0 0 6 478 3875 0 0 0 2 4 this 3 3917  5 other 1 3917  
501 0 0 6 479 3875 0 0 0 2 4 this 3 3917  5 other 1 3917  
502 0 0 7 480 3916 2543 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3917  
503 0 0 6 481 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3917  5 other 1 3917  
504 0 0 6 481 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3917  5 other 1 3917  9 threshold 1 3723  
505 0 0 6 482 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3917  
506 0 0 6 482 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3917  9 threshold 1 3723  
507 0 0 6 483 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3917  4 hash 1 3868  
508 0 0 6 483 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3917  4 hash 1 3868  9 threshold 1 3723  
509 0 0 4 484 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3917  7 hashgen 1 3876  
510 0 0 4 484 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3917  7 hashgen 1 3876  9 threshold 1 3723  
511 0 0 7 485 3916 2543 0 0 1 4 this 3 3917  
512 0 0 7 486 3916 2543 0 0 2 4 this 3 3917  5 other 1 3917  
513 0 0 7 487 3916 2543 0 0 2 4 this 3 3917  5 other 1 3917  
514 0 0 7 488 3916 2543 0 0 2 4 this 3 3917  6 scalar 1 3723  
515 0 0 7 489 3916 2543 0 0 2 4 this 3 3917  6 scalar 1 3723  
516 0 0 6 490 3916 0 0 0 2 4 this 3 3916  5 other 1 3917  
517 0 0 6 491 3916 0 0 0 2 4 this 3 3916  5 other 1 3917  
518 0 0 6 492 3916 0 0 0 2 4 this 3 3916  6 scalar 1 3723  
519 0 0 6 493 3916 0 0 0 2 4 this 3 3916  6 scalar 1 3723  
520 0 0 4 494 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 other 1 3917  
521 0 0 6 495 3871 0 0 0 2 4 this 3 3917  6 scalar 1 3723  
522 0 0 6 496 3871 0 0 0 2 4 this 3 3917  6 scalar 1 3723  
523 0 0 6 497 3871 0 0 0 2 4 this 3 3916  6 scalar 1 3723  
524 0 0 6 498 3871 0 0 0 2 4 this 3 3917  8 exponent 1 3723  
525 0 0 6 499 3871 0 0 0 2 4 this 3 3916  8 exponent 1 3723  
526 0 0 6 500 3871 0 0 0 1 4 this 3 3916  
527 0 0 6 501 3871 0 0 0 1 4 this 3 3916  
528 0 0 6 502 3871 0 0 0 1 4 this 3 3916  
529 0 0 7 503 3916 2543 0 10 /**
 *
 */ 2 4 this 3 3917  5 other 1 3917  
530 0 0 7 504 3916 2543 0 10 /**
 *
 */ 2 4 this 3 3917  5 other 1 3917  
531 0 0 4 505 3870 0 0 10 /**
 *
 */ 2 4 this 3 3916  5 other 1 3917  
532 0 0 6 506 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3917  5 other 1 3917  
533 0 0 6 506 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3917  5 other 1 3917  9 threshold 1 3723  
534 0 0 4 507 3870 0 0 10 /**
 *
 */ 2 4 this 3 3917  3 out 1 3878  
535 0 0 6 508 3874 0 0 0 1 4 this 3 3917  
536 0 0 4 509 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3917  11 destination 1 3880  
537 0 0 4 510 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3916  6 source 1 3882  
538 0 0 4 511 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3917  11 destination 1 3880  
539 0 0 4 512 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3916  6 source 1 3882  
540 0 0 6 513 3726 0 0 0 3 4 this 3 3917  4 view 1 3884  5 flags 1 3726  
541 0 0 7 514 3888 0 0 0 0 
542 0 0 7 518 3919 2619 0 0 0 
543 0 0 7 518 3919 2619 0 10 /**
 *
 */ 2 4 copy 1 3893  1 z 1 3726  
544 0 0 7 518 3919 2619 0 0 1 6 param0 0 3920  
545 0 0 7 518 3919 2619 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
546 0 0 7 518 3919 2619 0 10 /**
 *
 */ 3 1 x 1 3726  1 y 1 3726  1 z 1 3726  
547 0 0 4 519 3870 0 0 0 2 4 this 3 3919  4 size 1 3868  
548 0 0 6 522 3919 0 0 0 2 4 this 3 3919  4 copy 1 3920  
549 0 0 6 522 3919 0 0 0 2 4 this 3 3919  10 fill_value 1 3726  
550 0 0 6 523 3920 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
551 0 0 6 524 3920 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
552 0 0 6 525 3920 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
553 0 0 6 526 3920 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
554 0 0 6 527 3871 0 0 0 1 4 this 3 3920  
555 0 0 6 528 3871 0 0 0 2 4 this 3 3920  9 attr_name 1 3874  
556 0 0 6 529 3726 0 0 0 3 4 this 3 3919  9 attr_name 1 3874  6 assign 1 3871  
557 0 0 4 530 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  1 i 1 3726  
558 0 0 6 530 3726 0 0 0 2 4 this 3 3920  1 i 1 3726  
559 0 0 4 531 3870 0 0 0 3 4 this 3 3919  1 i 1 3726  10 assign_val 1 3726  
560 0 0 6 532 3726 0 0 0 0 
561 0 0 6 533 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3920  
562 0 0 6 534 3726 0 0 10 /**
 *
 */ 2 4 this 3 3920  1 i 1 3726  
563 0 0 6 535 3726 0 0 10 /**
 *
 */ 1 4 this 3 3920  
564 0 0 6 536 3726 0 0 10 /**
 *
 */ 1 4 this 3 3920  
565 0 0 6 537 3726 0 0 10 /**
 *
 */ 1 4 this 3 3920  
566 0 0 4 538 3870 0 0 10 /**
 *
 */ 3 4 this 3 3919  1 i 1 3726  5 value 1 3726  
567 0 0 4 539 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
568 0 0 4 540 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
569 0 0 4 541 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
570 0 0 7 542 3892 2279 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3920  
571 0 0 7 543 3892 2279 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3920  
572 0 0 7 544 3892 2279 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3920  
573 0 0 4 551 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3919  1 i 1 3726  5 value 1 3726  
574 0 0 4 552 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
575 0 0 4 553 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
576 0 0 4 554 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 value 1 3726  
577 0 0 4 555 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3920  
578 0 0 6 556 3726 0 0 0 0 
579 0 0 4 557 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3919  10 fill_value 1 3726  
580 0 0 4 558 3870 0 0 10 /**
 *
 */ 4 4 this 3 3919  1 x 1 3726  1 y 1 3726  1 z 1 3726  
581 0 0 6 559 3726 0 0 10 /**
 *
 */ 2 4 this 3 3920  5 other 1 3920  
582 0 0 6 560 3726 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3920  
583 0 0 7 561 3919 2619 0 10 /**
 *
 */ 2 4 this 3 3920  5 other 1 3920  
584 0 0 6 562 3875 0 0 0 2 4 this 3 3920  5 other 1 3920  
585 0 0 6 563 3875 0 0 0 2 4 this 3 3920  5 other 1 3920  
586 0 0 6 564 3875 0 0 0 2 4 this 3 3920  5 other 1 3920  
587 0 0 6 565 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3920  5 other 1 3920  
588 0 0 6 566 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3920  
589 0 0 6 567 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3920  4 hash 1 3868  
590 0 0 4 568 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3920  7 hashgen 1 3876  
591 0 0 7 569 3919 2619 0 0 1 4 this 3 3920  
592 0 0 7 570 3919 2619 0 0 2 4 this 3 3920  5 other 1 3920  
593 0 0 7 571 3919 2619 0 0 2 4 this 3 3920  5 other 1 3920  
594 0 0 7 572 3919 2619 0 0 2 4 this 3 3920  6 scalar 1 3726  
595 0 0 7 573 3919 2619 0 0 2 4 this 3 3920  6 scalar 1 3726  
596 0 0 6 574 3919 0 0 0 2 4 this 3 3919  5 other 1 3920  
597 0 0 6 575 3919 0 0 0 2 4 this 3 3919  5 other 1 3920  
598 0 0 6 576 3919 0 0 0 2 4 this 3 3919  6 scalar 1 3726  
599 0 0 6 577 3919 0 0 0 2 4 this 3 3919  6 scalar 1 3726  
600 0 0 4 578 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 other 1 3920  
601 0 0 6 579 3871 0 0 0 2 4 this 3 3920  6 scalar 1 3726  
602 0 0 6 580 3871 0 0 0 2 4 this 3 3920  6 scalar 1 3726  
603 0 0 6 581 3871 0 0 0 2 4 this 3 3919  6 scalar 1 3726  
604 0 0 6 582 3871 0 0 0 2 4 this 3 3920  8 exponent 1 3726  
605 0 0 6 583 3871 0 0 0 2 4 this 3 3919  8 exponent 1 3726  
606 0 0 6 584 3871 0 0 0 1 4 this 3 3919  
607 0 0 6 585 3871 0 0 0 1 4 this 3 3919  
608 0 0 6 586 3871 0 0 0 1 4 this 3 3919  
609 0 0 7 587 3919 2619 0 10 /**
 *
 */ 2 4 this 3 3920  5 other 1 3920  
610 0 0 7 588 3919 2619 0 10 /**
 *
 */ 2 4 this 3 3920  5 other 1 3920  
611 0 0 4 589 3870 0 0 10 /**
 *
 */ 2 4 this 3 3919  5 other 1 3920  
612 0 0 6 590 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3920  5 other 1 3920  
613 0 0 6 590 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3920  5 other 1 3920  9 threshold 1 3726  
614 0 0 4 591 3870 0 0 10 /**
 *
 */ 2 4 this 3 3920  3 out 1 3878  
615 0 0 6 592 3874 0 0 0 1 4 this 3 3920  
616 0 0 4 593 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3920  11 destination 1 3880  
617 0 0 4 594 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3919  6 source 1 3882  
618 0 0 4 595 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3920  11 destination 1 3880  
619 0 0 4 596 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3919  6 source 1 3882  
620 0 0 6 597 3726 0 0 0 3 4 this 3 3920  4 view 1 3884  5 flags 1 3726  
621 0 0 7 598 3888 0 0 0 0 
622 0 0 7 606 3922 2658 0 0 0 
623 0 0 7 606 3922 2658 0 10 /**
 *
 */ 2 4 copy 1 3866  1 z 1 3720  
624 0 0 7 606 3922 2658 0 10 /**
 *
 */ 1 4 copy 1 3914  
625 0 0 7 606 3922 2658 0 0 1 6 param0 0 3923  
626 0 0 7 606 3922 2658 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
627 0 0 7 606 3922 2658 0 10 /**
 *
 */ 3 1 x 1 3720  1 y 1 3720  1 z 1 3720  
628 0 0 6 607 3871 0 0 0 2 4 this 3 3923  9 attr_name 1 3874  
629 0 0 6 608 3726 0 0 0 3 4 this 3 3922  9 attr_name 1 3874  6 assign 1 3871  
630 0 0 6 609 3923 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
631 0 0 6 610 3923 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
632 0 0 6 611 3923 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
633 0 0 6 612 3923 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
634 0 0 7 613 3895 2298 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3923  
635 0 0 7 614 3895 2298 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3923  
636 0 0 7 615 3895 2298 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3923  
637 0 0 7 619 3922 2658 0 0 1 4 this 3 3923  
638 0 0 7 620 3913 2462 0 0 2 4 this 3 3923  5 other 1 3914  
639 0 0 7 620 3922 2658 0 0 2 4 this 3 3923  5 other 1 3923  
640 0 0 7 621 3913 2462 0 0 2 4 this 3 3923  5 other 1 3914  
641 0 0 7 621 3922 2658 0 0 2 4 this 3 3923  5 other 1 3923  
642 0 0 7 622 3922 2658 0 10 /**
 *
 */ 2 4 this 3 3923  5 other 1 3914  
643 0 0 7 623 3922 2658 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3923  
644 0 0 7 624 3922 2658 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3923  4 onto 1 3914  
645 0 0 6 625 3720 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3923  5 other 1 3923  
646 0 0 6 626 3720 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3923  5 other 1 3923  
647 0 0 6 627 3720 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3923  5 other 1 3923  3 ref 1 3923  
648 0 0 6 628 3720 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3923  5 other 1 3923  3 ref 1 3923  
649 0 0 6 629 3720 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3923  5 other 1 3923  
650 0 0 6 630 3720 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3923  5 other 1 3923  
651 0 0 7 631 3922 2658 0 0 2 4 this 3 3923  6 scalar 1 3720  
652 0 0 7 632 3922 2658 0 0 2 4 this 3 3923  6 scalar 1 3720  
653 0 0 7 633 3922 2658 0 0 2 4 this 3 3923  6 scalar 1 3720  
654 0 0 7 634 3922 2658 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3739  
655 0 0 7 635 3922 2658 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3739  
656 0 0 7 636 3922 2658 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3739  
657 0 0 7 637 3922 2658 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3739  
658 0 0 7 638 3922 2658 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3739  
659 0 0 7 639 3922 2658 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3739  
660 0 0 7 640 3922 2658 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3720  3 fwd 1 3720  2 up 1 3720  2 cs 1 3739  
661 0 0 6 641 3874 0 0 0 1 4 this 3 3923  
662 0 0 7 642 3888 0 0 0 0 
663 0 0 7 645 3925 2693 0 0 0 
664 0 0 7 645 3925 2693 0 10 /**
 *
 */ 2 4 copy 1 3890  1 z 1 3723  
665 0 0 7 645 3925 2693 0 10 /**
 *
 */ 1 4 copy 1 3917  
666 0 0 7 645 3925 2693 0 0 1 6 param0 0 3926  
667 0 0 7 645 3925 2693 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
668 0 0 7 645 3925 2693 0 10 /**
 *
 */ 3 1 x 1 3723  1 y 1 3723  1 z 1 3723  
669 0 0 6 646 3871 0 0 0 2 4 this 3 3926  9 attr_name 1 3874  
670 0 0 6 647 3726 0 0 0 3 4 this 3 3925  9 attr_name 1 3874  6 assign 1 3871  
671 0 0 6 648 3926 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
672 0 0 6 649 3926 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
673 0 0 6 650 3926 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
674 0 0 6 651 3926 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
675 0 0 7 652 3898 2317 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3926  
676 0 0 7 653 3898 2317 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3926  
677 0 0 7 654 3898 2317 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3926  
678 0 0 7 658 3925 2693 0 0 1 4 this 3 3926  
679 0 0 7 659 3916 2543 0 0 2 4 this 3 3926  5 other 1 3917  
680 0 0 7 659 3925 2693 0 0 2 4 this 3 3926  5 other 1 3926  
681 0 0 7 660 3916 2543 0 0 2 4 this 3 3926  5 other 1 3917  
682 0 0 7 660 3925 2693 0 0 2 4 this 3 3926  5 other 1 3926  
683 0 0 7 661 3925 2693 0 10 /**
 *
 */ 2 4 this 3 3926  5 other 1 3917  
684 0 0 7 662 3925 2693 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3926  
685 0 0 7 663 3925 2693 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3926  4 onto 1 3917  
686 0 0 6 664 3723 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3926  5 other 1 3926  
687 0 0 6 665 3723 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3926  5 other 1 3926  
688 0 0 6 666 3723 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3926  5 other 1 3926  3 ref 1 3926  
689 0 0 6 667 3723 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3926  5 other 1 3926  3 ref 1 3926  
690 0 0 6 668 3723 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3926  5 other 1 3926  
691 0 0 6 669 3723 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3926  5 other 1 3926  
692 0 0 7 670 3925 2693 0 0 2 4 this 3 3926  6 scalar 1 3723  
693 0 0 7 671 3925 2693 0 0 2 4 this 3 3926  6 scalar 1 3723  
694 0 0 7 672 3925 2693 0 0 2 4 this 3 3926  6 scalar 1 3723  
695 0 0 7 673 3925 2693 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3739  
696 0 0 7 674 3925 2693 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3739  
697 0 0 7 675 3925 2693 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3739  
698 0 0 7 676 3925 2693 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3739  
699 0 0 7 677 3925 2693 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3739  
700 0 0 7 678 3925 2693 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3739  
701 0 0 7 679 3925 2693 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3723  3 fwd 1 3723  2 up 1 3723  2 cs 1 3739  
702 0 0 6 680 3874 0 0 0 1 4 this 3 3926  
703 0 0 7 681 3888 0 0 0 0 
704 0 0 7 684 3928 2720 0 0 0 
705 0 0 7 684 3928 2720 0 10 /**
 *
 */ 2 4 copy 1 3893  1 z 1 3726  
706 0 0 7 684 3928 2720 0 10 /**
 *
 */ 1 4 copy 1 3920  
707 0 0 7 684 3928 2720 0 0 1 6 param0 0 3929  
708 0 0 7 684 3928 2720 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
709 0 0 7 684 3928 2720 0 10 /**
 *
 */ 3 1 x 1 3726  1 y 1 3726  1 z 1 3726  
710 0 0 6 685 3871 0 0 0 2 4 this 3 3929  9 attr_name 1 3874  
711 0 0 6 686 3726 0 0 0 3 4 this 3 3928  9 attr_name 1 3874  6 assign 1 3871  
712 0 0 6 687 3929 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
713 0 0 6 688 3929 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
714 0 0 6 689 3929 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
715 0 0 6 690 3929 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
716 0 0 7 691 3901 2332 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3929  
717 0 0 7 692 3901 2332 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3929  
718 0 0 7 693 3901 2332 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3929  
719 0 0 7 697 3928 2720 0 0 1 4 this 3 3929  
720 0 0 7 698 3919 2619 0 0 2 4 this 3 3929  5 other 1 3920  
721 0 0 7 698 3928 2720 0 0 2 4 this 3 3929  5 other 1 3929  
722 0 0 7 699 3919 2619 0 0 2 4 this 3 3929  5 other 1 3920  
723 0 0 7 699 3928 2720 0 0 2 4 this 3 3929  5 other 1 3929  
724 0 0 7 700 3928 2720 0 10 /**
 *
 */ 2 4 this 3 3929  5 other 1 3920  
725 0 0 7 701 3928 2720 0 0 2 4 this 3 3929  6 scalar 1 3726  
726 0 0 7 702 3928 2720 0 0 2 4 this 3 3929  6 scalar 1 3726  
727 0 0 7 703 3928 2720 0 0 2 4 this 3 3929  6 scalar 1 3726  
728 0 0 7 704 3928 2720 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3739  
729 0 0 7 705 3928 2720 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3739  
730 0 0 7 706 3928 2720 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3739  
731 0 0 7 707 3928 2720 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3739  
732 0 0 7 708 3928 2720 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3739  
733 0 0 7 709 3928 2720 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3739  
734 0 0 7 710 3928 2720 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3726  3 fwd 1 3726  2 up 1 3726  2 cs 1 3739  
735 0 0 6 711 3874 0 0 0 1 4 this 3 3929  
736 0 0 7 712 3888 0 0 0 0 
737 0 0 7 715 3931 2744 0 0 0 
738 0 0 7 715 3931 2744 0 0 1 6 param0 0 3932  
739 0 0 7 715 3931 2744 0 10 /**
 *
 */ 2 4 copy 1 3866  1 z 1 3720  
740 0 0 7 715 3931 2744 0 10 /**
 *
 */ 1 4 copy 1 3914  
741 0 0 7 715 3931 2744 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
742 0 0 7 715 3931 2744 0 10 /**
 *
 */ 3 1 x 1 3720  1 y 1 3720  1 z 1 3720  
743 0 0 6 716 3871 0 0 0 2 4 this 3 3932  9 attr_name 1 3874  
744 0 0 6 717 3726 0 0 0 3 4 this 3 3931  9 attr_name 1 3874  6 assign 1 3871  
745 0 0 6 718 3932 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
746 0 0 6 719 3932 0 0 34 /**
 * Returns a unit X point.
 */ 0 
747 0 0 6 720 3932 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
748 0 0 6 721 3932 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
749 0 0 7 722 3904 2349 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3932  
750 0 0 7 723 3904 2349 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3932  
751 0 0 7 724 3904 2349 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3932  
752 0 0 7 728 3931 2744 0 0 1 4 this 3 3932  
753 0 0 7 729 3913 2462 0 0 2 4 this 3 3932  5 other 1 3914  
754 0 0 7 729 3931 2744 0 0 2 4 this 3 3932  5 other 1 3923  
755 0 0 7 730 3922 2658 0 0 2 4 this 3 3932  5 other 1 3932  
756 0 0 7 730 3913 2462 0 0 2 4 this 3 3932  5 other 1 3914  
757 0 0 7 730 3931 2744 0 0 2 4 this 3 3932  5 other 1 3923  
758 0 0 7 731 3931 2744 0 10 /**
 *
 */ 2 4 this 3 3932  5 other 1 3914  
759 0 0 7 732 3931 2744 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3932  
760 0 0 7 733 3931 2744 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3932  4 onto 1 3914  
761 0 0 7 734 3931 2744 0 0 2 4 this 3 3932  6 scalar 1 3720  
762 0 0 7 735 3931 2744 0 0 2 4 this 3 3932  6 scalar 1 3720  
763 0 0 7 736 3931 2744 0 0 2 4 this 3 3932  6 scalar 1 3720  
764 0 0 6 737 3932 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3739  
765 0 0 7 738 3931 2744 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3720  3 fwd 1 3720  2 up 1 3720  2 cs 1 3739  
766 0 0 6 739 3874 0 0 0 1 4 this 3 3932  
767 0 0 7 740 3888 0 0 0 0 
768 0 0 7 743 3934 2768 0 0 0 
769 0 0 7 743 3934 2768 0 0 1 6 param0 0 3935  
770 0 0 7 743 3934 2768 0 10 /**
 *
 */ 2 4 copy 1 3890  1 z 1 3723  
771 0 0 7 743 3934 2768 0 10 /**
 *
 */ 1 4 copy 1 3917  
772 0 0 7 743 3934 2768 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
773 0 0 7 743 3934 2768 0 10 /**
 *
 */ 3 1 x 1 3723  1 y 1 3723  1 z 1 3723  
774 0 0 6 744 3871 0 0 0 2 4 this 3 3935  9 attr_name 1 3874  
775 0 0 6 745 3726 0 0 0 3 4 this 3 3934  9 attr_name 1 3874  6 assign 1 3871  
776 0 0 6 746 3935 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
777 0 0 6 747 3935 0 0 34 /**
 * Returns a unit X point.
 */ 0 
778 0 0 6 748 3935 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
779 0 0 6 749 3935 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
780 0 0 7 750 3907 2366 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3935  
781 0 0 7 751 3907 2366 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3935  
782 0 0 7 752 3907 2366 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3935  
783 0 0 7 756 3934 2768 0 0 1 4 this 3 3935  
784 0 0 7 757 3916 2543 0 0 2 4 this 3 3935  5 other 1 3917  
785 0 0 7 757 3934 2768 0 0 2 4 this 3 3935  5 other 1 3926  
786 0 0 7 758 3925 2693 0 0 2 4 this 3 3935  5 other 1 3935  
787 0 0 7 758 3916 2543 0 0 2 4 this 3 3935  5 other 1 3917  
788 0 0 7 758 3934 2768 0 0 2 4 this 3 3935  5 other 1 3926  
789 0 0 7 759 3934 2768 0 10 /**
 *
 */ 2 4 this 3 3935  5 other 1 3917  
790 0 0 7 760 3934 2768 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3935  
791 0 0 7 761 3934 2768 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3935  4 onto 1 3917  
792 0 0 7 762 3934 2768 0 0 2 4 this 3 3935  6 scalar 1 3723  
793 0 0 7 763 3934 2768 0 0 2 4 this 3 3935  6 scalar 1 3723  
794 0 0 7 764 3934 2768 0 0 2 4 this 3 3935  6 scalar 1 3723  
795 0 0 6 765 3935 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3739  
796 0 0 7 766 3934 2768 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3723  3 fwd 1 3723  2 up 1 3723  2 cs 1 3739  
797 0 0 6 767 3874 0 0 0 1 4 this 3 3935  
798 0 0 7 768 3888 0 0 0 0 
799 0 0 7 771 3937 2790 0 0 0 
800 0 0 7 771 3937 2790 0 0 1 6 param0 0 3938  
801 0 0 7 771 3937 2790 0 10 /**
 *
 */ 2 4 copy 1 3893  1 z 1 3726  
802 0 0 7 771 3937 2790 0 10 /**
 *
 */ 1 4 copy 1 3920  
803 0 0 7 771 3937 2790 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
804 0 0 7 771 3937 2790 0 10 /**
 *
 */ 3 1 x 1 3726  1 y 1 3726  1 z 1 3726  
805 0 0 6 772 3871 0 0 0 2 4 this 3 3938  9 attr_name 1 3874  
806 0 0 6 773 3726 0 0 0 3 4 this 3 3937  9 attr_name 1 3874  6 assign 1 3871  
807 0 0 6 774 3938 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
808 0 0 6 775 3938 0 0 34 /**
 * Returns a unit X point.
 */ 0 
809 0 0 6 776 3938 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
810 0 0 6 777 3938 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
811 0 0 7 778 3910 2381 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3938  
812 0 0 7 779 3910 2381 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3938  
813 0 0 7 780 3910 2381 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3938  
814 0 0 7 784 3937 2790 0 0 1 4 this 3 3938  
815 0 0 7 785 3919 2619 0 0 2 4 this 3 3938  5 other 1 3920  
816 0 0 7 785 3937 2790 0 0 2 4 this 3 3938  5 other 1 3929  
817 0 0 7 786 3928 2720 0 0 2 4 this 3 3938  5 other 1 3938  
818 0 0 7 786 3919 2619 0 0 2 4 this 3 3938  5 other 1 3920  
819 0 0 7 786 3937 2790 0 0 2 4 this 3 3938  5 other 1 3929  
820 0 0 7 787 3937 2790 0 10 /**
 *
 */ 2 4 this 3 3938  5 other 1 3920  
821 0 0 7 788 3937 2790 0 0 2 4 this 3 3938  6 scalar 1 3726  
822 0 0 7 789 3937 2790 0 0 2 4 this 3 3938  6 scalar 1 3726  
823 0 0 7 790 3937 2790 0 0 2 4 this 3 3938  6 scalar 1 3726  
824 0 0 6 791 3938 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3739  
825 0 0 7 792 3937 2790 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3726  3 fwd 1 3726  2 up 1 3726  2 cs 1 3739  
826 0 0 6 793 3874 0 0 0 1 4 this 3 3938  
827 0 0 7 794 3888 0 0 0 0 
828 0 0 7 798 3940 2872 0 0 0 
829 0 0 7 798 3940 2872 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3932  
830 0 0 7 798 3940 2872 0 10 /**
 *
 */ 2 4 copy 1 3914  1 w 1 3720  
831 0 0 7 798 3940 2872 0 0 1 6 param0 0 3941  
832 0 0 7 798 3940 2872 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3923  
833 0 0 7 798 3940 2872 0 10 /**
 *
 */ 1 4 copy 1 3943  
834 0 0 7 798 3940 2872 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
835 0 0 7 798 3940 2872 0 10 /**
 *
 */ 4 1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
836 0 0 4 799 3870 0 0 0 2 4 this 3 3940  4 size 1 3868  
837 0 0 6 802 3940 0 0 0 2 4 this 3 3940  4 copy 1 3941  
838 0 0 6 802 3940 0 0 0 2 4 this 3 3940  10 fill_value 1 3720  
839 0 0 6 803 3941 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
840 0 0 6 804 3941 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
841 0 0 6 805 3941 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
842 0 0 6 806 3941 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
843 0 0 6 807 3941 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
844 0 0 6 808 3871 0 0 0 1 4 this 3 3941  
845 0 0 6 809 3871 0 0 0 2 4 this 3 3941  9 attr_name 1 3874  
846 0 0 6 810 3726 0 0 0 3 4 this 3 3940  9 attr_name 1 3874  6 assign 1 3871  
847 0 0 4 811 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  1 i 1 3726  
848 0 0 6 811 3720 0 0 0 2 4 this 3 3941  1 i 1 3726  
849 0 0 4 812 3870 0 0 0 3 4 this 3 3940  1 i 1 3726  10 assign_val 1 3720  
850 0 0 6 813 3726 0 0 0 0 
851 0 0 6 814 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3941  
852 0 0 6 815 3720 0 0 10 /**
 *
 */ 2 4 this 3 3941  1 i 1 3726  
853 0 0 4 816 3870 0 0 10 /**
 *
 */ 3 4 this 3 3940  1 i 1 3726  5 value 1 3720  
854 0 0 6 817 3720 0 0 10 /**
 *
 */ 1 4 this 3 3941  
855 0 0 6 818 3720 0 0 10 /**
 *
 */ 1 4 this 3 3941  
856 0 0 6 819 3720 0 0 10 /**
 *
 */ 1 4 this 3 3941  
857 0 0 6 820 3720 0 0 10 /**
 *
 */ 1 4 this 3 3941  
858 0 0 7 821 3913 2462 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3941  
859 0 0 7 822 3865 2141 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3941  
860 0 0 4 823 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
861 0 0 4 824 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
862 0 0 4 825 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
863 0 0 4 826 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
864 0 0 4 832 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3940  1 i 1 3726  5 value 1 3720  
865 0 0 4 833 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
866 0 0 4 834 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
867 0 0 4 835 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
868 0 0 4 836 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 value 1 3720  
869 0 0 4 837 3870 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3941  
870 0 0 6 838 3726 0 0 0 0 
871 0 0 4 840 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3940  10 fill_value 1 3720  
872 0 0 4 841 3870 0 0 10 /**
 *
 */ 5 4 this 3 3940  1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
873 0 0 6 842 3720 0 0 10 /**
 *
 */ 2 4 this 3 3941  5 other 1 3941  
874 0 0 6 843 3720 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3941  
875 0 0 6 844 3720 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3941  
876 0 0 6 845 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3940  
877 0 0 7 846 3940 2872 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3941  
878 0 0 7 847 3940 2872 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3941  4 onto 1 3941  
879 0 0 6 848 3875 0 0 0 2 4 this 3 3941  5 other 1 3941  
880 0 0 6 849 3875 0 0 0 2 4 this 3 3941  5 other 1 3941  
881 0 0 6 850 3875 0 0 0 2 4 this 3 3941  5 other 1 3941  
882 0 0 6 851 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3941  5 other 1 3941  
883 0 0 6 851 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3941  5 other 1 3941  9 threshold 1 3720  
884 0 0 6 852 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3941  
885 0 0 6 852 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3941  9 threshold 1 3720  
886 0 0 6 853 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3941  4 hash 1 3868  
887 0 0 6 853 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3941  4 hash 1 3868  9 threshold 1 3720  
888 0 0 4 854 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3941  7 hashgen 1 3876  
889 0 0 4 854 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3941  7 hashgen 1 3876  9 threshold 1 3720  
890 0 0 7 855 3940 2872 0 0 1 4 this 3 3941  
891 0 0 7 856 3940 2872 0 0 2 4 this 3 3941  5 other 1 3941  
892 0 0 7 857 3940 2872 0 0 2 4 this 3 3941  5 other 1 3941  
893 0 0 7 858 3940 2872 0 0 2 4 this 3 3941  6 scalar 1 3720  
894 0 0 7 859 3940 2872 0 0 2 4 this 3 3941  6 scalar 1 3720  
895 0 0 6 860 3940 0 0 0 2 4 this 3 3940  5 other 1 3941  
896 0 0 6 861 3940 0 0 0 2 4 this 3 3940  5 other 1 3941  
897 0 0 6 862 3940 0 0 0 2 4 this 3 3940  6 scalar 1 3720  
898 0 0 6 863 3940 0 0 0 2 4 this 3 3940  6 scalar 1 3720  
899 0 0 4 864 3870 0 0 10 /**
 *
 */ 2 4 this 3 3940  5 other 1 3941  
900 0 0 6 865 3871 0 0 0 2 4 this 3 3941  6 scalar 1 3720  
901 0 0 6 866 3871 0 0 0 2 4 this 3 3941  6 scalar 1 3720  
902 0 0 6 867 3871 0 0 0 2 4 this 3 3940  6 scalar 1 3720  
903 0 0 6 868 3871 0 0 0 2 4 this 3 3941  8 exponent 1 3720  
904 0 0 6 869 3871 0 0 0 2 4 this 3 3940  8 exponent 1 3720  
905 0 0 6 870 3871 0 0 0 1 4 this 3 3940  
906 0 0 6 871 3871 0 0 0 1 4 this 3 3940  
907 0 0 6 872 3871 0 0 0 1 4 this 3 3940  
908 0 0 7 873 3940 2872 0 10 /**
 *
 */ 2 4 this 3 3941  5 other 1 3941  
909 0 0 7 874 3940 2872 0 10 /**
 *
 */ 2 4 this 3 3941  5 other 1 3941  
910 0 0 6 875 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3941  5 other 1 3941  
911 0 0 6 875 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3941  5 other 1 3941  9 threshold 1 3720  
912 0 0 4 876 3870 0 0 10 /**
 *
 */ 2 4 this 3 3941  3 out 1 3878  
913 0 0 6 877 3874 0 0 0 1 4 this 3 3941  
914 0 0 4 878 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3941  11 destination 1 3880  
915 0 0 4 879 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3940  6 source 1 3882  
916 0 0 4 880 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3941  11 destination 1 3880  
917 0 0 4 881 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3940  6 source 1 3882  
918 0 0 6 882 3726 0 0 0 3 4 this 3 3941  4 view 1 3884  5 flags 1 3726  
919 0 0 7 883 3888 0 0 0 0 
920 0 0 7 887 3945 2884 0 0 0 
921 0 0 7 887 3945 2884 0 10 /**
 *
 */ 1 4 copy 1 3941  
922 0 0 7 887 3945 2884 0 0 1 6 param0 0 3943  
923 0 0 7 887 3945 2884 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
924 0 0 7 887 3945 2884 0 10 /**
 *
 */ 4 1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
925 0 0 4 888 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3945  10 fill_value 1 3720  
926 0 0 4 889 3870 0 0 10 /**
 *
 */ 5 4 this 3 3945  1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
927 0 0 4 890 3870 0 0 10 /**
 *
 */ 2 4 this 3 3945  1 i 1 3726  
928 0 0 6 890 3720 0 0 0 2 4 this 3 3943  1 i 1 3726  
929 0 0 4 891 3870 0 0 0 3 4 this 3 3945  1 i 1 3726  10 assign_val 1 3720  
930 0 0 6 892 3726 0 0 0 0 
931 0 0 4 893 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3943  
932 0 0 6 894 3726 0 0 0 0 
933 0 0 6 895 3875 0 0 0 2 4 this 3 3943  5 other 1 3943  
934 0 0 6 896 3875 0 0 0 2 4 this 3 3943  5 other 1 3943  
935 0 0 7 897 3888 0 0 0 0 
936 0 0 7 901 3946 2966 0 0 0 
937 0 0 7 901 3946 2966 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3935  
938 0 0 7 901 3946 2966 0 10 /**
 *
 */ 2 4 copy 1 3917  1 w 1 3723  
939 0 0 7 901 3946 2966 0 0 1 6 param0 0 3947  
940 0 0 7 901 3946 2966 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3926  
941 0 0 7 901 3946 2966 0 10 /**
 *
 */ 1 4 copy 1 3949  
942 0 0 7 901 3946 2966 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
943 0 0 7 901 3946 2966 0 10 /**
 *
 */ 4 1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
944 0 0 4 902 3870 0 0 0 2 4 this 3 3946  4 size 1 3868  
945 0 0 6 905 3946 0 0 0 2 4 this 3 3946  4 copy 1 3947  
946 0 0 6 905 3946 0 0 0 2 4 this 3 3946  10 fill_value 1 3723  
947 0 0 6 906 3947 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
948 0 0 6 907 3947 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
949 0 0 6 908 3947 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
950 0 0 6 909 3947 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
951 0 0 6 910 3947 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
952 0 0 6 911 3871 0 0 0 1 4 this 3 3947  
953 0 0 6 912 3871 0 0 0 2 4 this 3 3947  9 attr_name 1 3874  
954 0 0 6 913 3726 0 0 0 3 4 this 3 3946  9 attr_name 1 3874  6 assign 1 3871  
955 0 0 4 914 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  1 i 1 3726  
956 0 0 6 914 3723 0 0 0 2 4 this 3 3947  1 i 1 3726  
957 0 0 4 915 3870 0 0 0 3 4 this 3 3946  1 i 1 3726  10 assign_val 1 3723  
958 0 0 6 916 3726 0 0 0 0 
959 0 0 6 917 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3947  
960 0 0 6 918 3723 0 0 10 /**
 *
 */ 2 4 this 3 3947  1 i 1 3726  
961 0 0 4 919 3870 0 0 10 /**
 *
 */ 3 4 this 3 3946  1 i 1 3726  5 value 1 3723  
962 0 0 6 920 3723 0 0 10 /**
 *
 */ 1 4 this 3 3947  
963 0 0 6 921 3723 0 0 10 /**
 *
 */ 1 4 this 3 3947  
964 0 0 6 922 3723 0 0 10 /**
 *
 */ 1 4 this 3 3947  
965 0 0 6 923 3723 0 0 10 /**
 *
 */ 1 4 this 3 3947  
966 0 0 7 924 3916 2543 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3947  
967 0 0 7 925 3889 2212 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3947  
968 0 0 4 926 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
969 0 0 4 927 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
970 0 0 4 928 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
971 0 0 4 929 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
972 0 0 4 935 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3946  1 i 1 3726  5 value 1 3723  
973 0 0 4 936 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
974 0 0 4 937 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
975 0 0 4 938 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
976 0 0 4 939 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 value 1 3723  
977 0 0 4 940 3870 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3947  
978 0 0 6 941 3726 0 0 0 0 
979 0 0 4 943 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3946  10 fill_value 1 3723  
980 0 0 4 944 3870 0 0 10 /**
 *
 */ 5 4 this 3 3946  1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
981 0 0 6 945 3723 0 0 10 /**
 *
 */ 2 4 this 3 3947  5 other 1 3947  
982 0 0 6 946 3723 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3947  
983 0 0 6 947 3723 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3947  
984 0 0 6 948 3875 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3946  
985 0 0 7 949 3946 2966 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3947  
986 0 0 7 950 3946 2966 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3947  4 onto 1 3947  
987 0 0 6 951 3875 0 0 0 2 4 this 3 3947  5 other 1 3947  
988 0 0 6 952 3875 0 0 0 2 4 this 3 3947  5 other 1 3947  
989 0 0 6 953 3875 0 0 0 2 4 this 3 3947  5 other 1 3947  
990 0 0 6 954 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3947  5 other 1 3947  
991 0 0 6 954 3726 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3947  5 other 1 3947  9 threshold 1 3723  
992 0 0 6 955 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3947  
993 0 0 6 955 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3947  9 threshold 1 3723  
994 0 0 6 956 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3947  4 hash 1 3868  
995 0 0 6 956 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3947  4 hash 1 3868  9 threshold 1 3723  
996 0 0 4 957 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3947  7 hashgen 1 3876  
997 0 0 4 957 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3947  7 hashgen 1 3876  9 threshold 1 3723  
998 0 0 7 958 3946 2966 0 0 1 4 this 3 3947  
999 0 0 7 959 3946 2966 0 0 2 4 this 3 3947  5 other 1 3947  
1000 0 0 7 960 3946 2966 0 0 2 4 this 3 3947  5 other 1 3947  
1001 0 0 7 961 3946 2966 0 0 2 4 this 3 3947  6 scalar 1 3723  
1002 0 0 7 962 3946 2966 0 0 2 4 this 3 3947  6 scalar 1 3723  
1003 0 0 6 963 3946 0 0 0 2 4 this 3 3946  5 other 1 3947  
1004 0 0 6 964 3946 0 0 0 2 4 this 3 3946  5 other 1 3947  
1005 0 0 6 965 3946 0 0 0 2 4 this 3 3946  6 scalar 1 3723  
1006 0 0 6 966 3946 0 0 0 2 4 this 3 3946  6 scalar 1 3723  
1007 0 0 4 967 3870 0 0 10 /**
 *
 */ 2 4 this 3 3946  5 other 1 3947  
1008 0 0 6 968 3871 0 0 0 2 4 this 3 3947  6 scalar 1 3723  
1009 0 0 6 969 3871 0 0 0 2 4 this 3 3947  6 scalar 1 3723  
1010 0 0 6 970 3871 0 0 0 2 4 this 3 3946  6 scalar 1 3723  
1011 0 0 6 971 3871 0 0 0 2 4 this 3 3947  8 exponent 1 3723  
1012 0 0 6 972 3871 0 0 0 2 4 this 3 3946  8 exponent 1 3723  
1013 0 0 6 973 3871 0 0 0 1 4 this 3 3946  
1014 0 0 6 974 3871 0 0 0 1 4 this 3 3946  
1015 0 0 6 975 3871 0 0 0 1 4 this 3 3946  
1016 0 0 7 976 3946 2966 0 10 /**
 *
 */ 2 4 this 3 3947  5 other 1 3947  
1017 0 0 7 977 3946 2966 0 10 /**
 *
 */ 2 4 this 3 3947  5 other 1 3947  
1018 0 0 6 978 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3947  5 other 1 3947  
1019 0 0 6 978 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3947  5 other 1 3947  9 threshold 1 3723  
1020 0 0 4 979 3870 0 0 10 /**
 *
 */ 2 4 this 3 3947  3 out 1 3878  
1021 0 0 6 980 3874 0 0 0 1 4 this 3 3947  
1022 0 0 4 981 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3947  11 destination 1 3880  
1023 0 0 4 982 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3946  6 source 1 3882  
1024 0 0 4 983 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3947  11 destination 1 3880  
1025 0 0 4 984 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3946  6 source 1 3882  
1026 0 0 6 985 3726 0 0 0 3 4 this 3 3947  4 view 1 3884  5 flags 1 3726  
1027 0 0 7 986 3888 0 0 0 0 
1028 0 0 7 990 3951 2978 0 0 0 
1029 0 0 7 990 3951 2978 0 10 /**
 *
 */ 1 4 copy 1 3947  
1030 0 0 7 990 3951 2978 0 0 1 6 param0 0 3949  
1031 0 0 7 990 3951 2978 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
1032 0 0 7 990 3951 2978 0 10 /**
 *
 */ 4 1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
1033 0 0 4 991 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3951  10 fill_value 1 3723  
1034 0 0 4 992 3870 0 0 10 /**
 *
 */ 5 4 this 3 3951  1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
1035 0 0 4 993 3870 0 0 10 /**
 *
 */ 2 4 this 3 3951  1 i 1 3726  
1036 0 0 6 993 3723 0 0 0 2 4 this 3 3949  1 i 1 3726  
1037 0 0 4 994 3870 0 0 0 3 4 this 3 3951  1 i 1 3726  10 assign_val 1 3723  
1038 0 0 6 995 3726 0 0 0 0 
1039 0 0 4 996 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3949  
1040 0 0 6 997 3726 0 0 0 0 
1041 0 0 6 998 3875 0 0 0 2 4 this 3 3949  5 other 1 3949  
1042 0 0 6 999 3875 0 0 0 2 4 this 3 3949  5 other 1 3949  
1043 0 0 7 1000 3888 0 0 0 0 
1044 0 0 7 1004 3952 3056 0 0 0 
1045 0 0 7 1004 3952 3056 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3938  
1046 0 0 7 1004 3952 3056 0 10 /**
 *
 */ 2 4 copy 1 3920  1 w 1 3726  
1047 0 0 7 1004 3952 3056 0 0 1 6 param0 0 3953  
1048 0 0 7 1004 3952 3056 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3929  
1049 0 0 7 1004 3952 3056 0 10 /**
 *
 */ 1 4 copy 1 3955  
1050 0 0 7 1004 3952 3056 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
1051 0 0 7 1004 3952 3056 0 10 /**
 *
 */ 4 1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1052 0 0 4 1005 3870 0 0 0 2 4 this 3 3952  4 size 1 3868  
1053 0 0 6 1008 3952 0 0 0 2 4 this 3 3952  4 copy 1 3953  
1054 0 0 6 1008 3952 0 0 0 2 4 this 3 3952  10 fill_value 1 3726  
1055 0 0 6 1009 3953 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1056 0 0 6 1010 3953 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1057 0 0 6 1011 3953 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1058 0 0 6 1012 3953 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1059 0 0 6 1013 3953 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1060 0 0 6 1014 3871 0 0 0 1 4 this 3 3953  
1061 0 0 6 1015 3871 0 0 0 2 4 this 3 3953  9 attr_name 1 3874  
1062 0 0 6 1016 3726 0 0 0 3 4 this 3 3952  9 attr_name 1 3874  6 assign 1 3871  
1063 0 0 4 1017 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  1 i 1 3726  
1064 0 0 6 1017 3726 0 0 0 2 4 this 3 3953  1 i 1 3726  
1065 0 0 4 1018 3870 0 0 0 3 4 this 3 3952  1 i 1 3726  10 assign_val 1 3726  
1066 0 0 6 1019 3726 0 0 0 0 
1067 0 0 6 1020 3875 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3953  
1068 0 0 6 1021 3726 0 0 10 /**
 *
 */ 2 4 this 3 3953  1 i 1 3726  
1069 0 0 4 1022 3870 0 0 10 /**
 *
 */ 3 4 this 3 3952  1 i 1 3726  5 value 1 3726  
1070 0 0 6 1023 3726 0 0 10 /**
 *
 */ 1 4 this 3 3953  
1071 0 0 6 1024 3726 0 0 10 /**
 *
 */ 1 4 this 3 3953  
1072 0 0 6 1025 3726 0 0 10 /**
 *
 */ 1 4 this 3 3953  
1073 0 0 6 1026 3726 0 0 10 /**
 *
 */ 1 4 this 3 3953  
1074 0 0 7 1027 3919 2619 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3953  
1075 0 0 7 1028 3892 2279 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3953  
1076 0 0 4 1029 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1077 0 0 4 1030 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1078 0 0 4 1031 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1079 0 0 4 1032 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1080 0 0 4 1038 3870 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3952  1 i 1 3726  5 value 1 3726  
1081 0 0 4 1039 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1082 0 0 4 1040 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1083 0 0 4 1041 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1084 0 0 4 1042 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 value 1 3726  
1085 0 0 4 1043 3870 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3953  
1086 0 0 6 1044 3726 0 0 0 0 
1087 0 0 4 1046 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3952  10 fill_value 1 3726  
1088 0 0 4 1047 3870 0 0 10 /**
 *
 */ 5 4 this 3 3952  1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1089 0 0 6 1048 3726 0 0 10 /**
 *
 */ 2 4 this 3 3953  5 other 1 3953  
1090 0 0 6 1049 3726 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3953  
1091 0 0 6 1050 3875 0 0 0 2 4 this 3 3953  5 other 1 3953  
1092 0 0 6 1051 3875 0 0 0 2 4 this 3 3953  5 other 1 3953  
1093 0 0 6 1052 3875 0 0 0 2 4 this 3 3953  5 other 1 3953  
1094 0 0 6 1053 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3953  5 other 1 3953  
1095 0 0 6 1054 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3953  
1096 0 0 6 1055 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3953  4 hash 1 3868  
1097 0 0 4 1056 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3953  7 hashgen 1 3876  
1098 0 0 7 1057 3952 3056 0 0 1 4 this 3 3953  
1099 0 0 7 1058 3952 3056 0 0 2 4 this 3 3953  5 other 1 3953  
1100 0 0 7 1059 3952 3056 0 0 2 4 this 3 3953  5 other 1 3953  
1101 0 0 7 1060 3952 3056 0 0 2 4 this 3 3953  6 scalar 1 3726  
1102 0 0 7 1061 3952 3056 0 0 2 4 this 3 3953  6 scalar 1 3726  
1103 0 0 6 1062 3952 0 0 0 2 4 this 3 3952  5 other 1 3953  
1104 0 0 6 1063 3952 0 0 0 2 4 this 3 3952  5 other 1 3953  
1105 0 0 6 1064 3952 0 0 0 2 4 this 3 3952  6 scalar 1 3726  
1106 0 0 6 1065 3952 0 0 0 2 4 this 3 3952  6 scalar 1 3726  
1107 0 0 4 1066 3870 0 0 10 /**
 *
 */ 2 4 this 3 3952  5 other 1 3953  
1108 0 0 6 1067 3871 0 0 0 2 4 this 3 3953  6 scalar 1 3726  
1109 0 0 6 1068 3871 0 0 0 2 4 this 3 3953  6 scalar 1 3726  
1110 0 0 6 1069 3871 0 0 0 2 4 this 3 3952  6 scalar 1 3726  
1111 0 0 6 1070 3871 0 0 0 2 4 this 3 3953  8 exponent 1 3726  
1112 0 0 6 1071 3871 0 0 0 2 4 this 3 3952  8 exponent 1 3726  
1113 0 0 6 1072 3871 0 0 0 1 4 this 3 3952  
1114 0 0 6 1073 3871 0 0 0 1 4 this 3 3952  
1115 0 0 6 1074 3871 0 0 0 1 4 this 3 3952  
1116 0 0 7 1075 3952 3056 0 10 /**
 *
 */ 2 4 this 3 3953  5 other 1 3953  
1117 0 0 7 1076 3952 3056 0 10 /**
 *
 */ 2 4 this 3 3953  5 other 1 3953  
1118 0 0 6 1077 3875 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3953  5 other 1 3953  
1119 0 0 6 1077 3875 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3953  5 other 1 3953  9 threshold 1 3726  
1120 0 0 4 1078 3870 0 0 10 /**
 *
 */ 2 4 this 3 3953  3 out 1 3878  
1121 0 0 6 1079 3874 0 0 0 1 4 this 3 3953  
1122 0 0 4 1080 3870 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3953  11 destination 1 3880  
1123 0 0 4 1081 3870 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3952  6 source 1 3882  
1124 0 0 4 1082 3870 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3953  11 destination 1 3880  
1125 0 0 4 1083 3870 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3952  6 source 1 3882  
1126 0 0 6 1084 3726 0 0 0 3 4 this 3 3953  4 view 1 3884  5 flags 1 3726  
1127 0 0 7 1085 3888 0 0 0 0 
1128 0 0 7 1089 3957 3068 0 0 0 
1129 0 0 7 1089 3957 3068 0 10 /**
 *
 */ 1 4 copy 1 3953  
1130 0 0 7 1089 3957 3068 0 0 1 6 param0 0 3955  
1131 0 0 7 1089 3957 3068 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
1132 0 0 7 1089 3957 3068 0 10 /**
 *
 */ 4 1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1133 0 0 4 1090 3870 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3957  10 fill_value 1 3726  
1134 0 0 4 1091 3870 0 0 10 /**
 *
 */ 5 4 this 3 3957  1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1135 0 0 4 1092 3870 0 0 10 /**
 *
 */ 2 4 this 3 3957  1 i 1 3726  
1136 0 0 6 1092 3726 0 0 0 2 4 this 3 3955  1 i 1 3726  
1137 0 0 4 1093 3870 0 0 0 3 4 this 3 3957  1 i 1 3726  10 assign_val 1 3726  
1138 0 0 6 1094 3726 0 0 0 0 
1139 0 0 4 1095 3870 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3955  
1140 0 0 6 1096 3726 0 0 0 0 
1141 0 0 6 1097 3875 0 0 0 2 4 this 3 3955  5 other 1 3955  
1142 0 0 6 1098 3875 0 0 0 2 4 this 3 3955  5 other 1 3955  
1143 0 0 7 1099 3888 0 0 0 0 
1144 0 0 7 1102 3958 3089 0 0 0 
1145 0 0 7 1102 3958 3089 0 10 /**
 *
 */ 2 4 copy 1 3914  1 w 1 3720  
1146 0 0 7 1102 3958 3089 0 10 /**
 *
 */ 1 4 copy 1 3941  
1147 0 0 7 1102 3958 3089 0 0 1 6 param0 0 3959  
1148 0 0 7 1102 3958 3089 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
1149 0 0 7 1102 3958 3089 0 10 /**
 *
 */ 4 1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
1150 0 0 6 1103 3871 0 0 0 2 4 this 3 3959  9 attr_name 1 3874  
1151 0 0 6 1104 3726 0 0 0 3 4 this 3 3958  9 attr_name 1 3874  6 assign 1 3871  
1152 0 0 6 1105 3959 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1153 0 0 6 1106 3959 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1154 0 0 6 1107 3959 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1155 0 0 6 1108 3959 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1156 0 0 6 1109 3959 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1157 0 0 7 1110 3922 2658 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3959  
1158 0 0 7 1111 3895 2298 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3959  
1159 0 0 7 1114 3958 3089 0 0 1 4 this 3 3959  
1160 0 0 7 1115 3940 2872 0 0 2 4 this 3 3959  5 other 1 3941  
1161 0 0 7 1115 3958 3089 0 0 2 4 this 3 3959  5 other 1 3959  
1162 0 0 7 1116 3940 2872 0 0 2 4 this 3 3959  5 other 1 3941  
1163 0 0 7 1116 3958 3089 0 0 2 4 this 3 3959  5 other 1 3959  
1164 0 0 7 1117 3958 3089 0 0 2 4 this 3 3959  6 scalar 1 3720  
1165 0 0 7 1118 3958 3089 0 0 2 4 this 3 3959  6 scalar 1 3720  
1166 0 0 7 1119 3958 3089 0 0 2 4 this 3 3959  6 scalar 1 3720  
1167 0 0 7 1120 3958 3089 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3959  
1168 0 0 7 1121 3958 3089 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3959  4 onto 1 3941  
1169 0 0 6 1122 3874 0 0 0 1 4 this 3 3959  
1170 0 0 7 1123 3888 0 0 0 0 
1171 0 0 7 1126 3961 3110 0 0 0 
1172 0 0 7 1126 3961 3110 0 10 /**
 *
 */ 2 4 copy 1 3917  1 w 1 3723  
1173 0 0 7 1126 3961 3110 0 10 /**
 *
 */ 1 4 copy 1 3947  
1174 0 0 7 1126 3961 3110 0 0 1 6 param0 0 3962  
1175 0 0 7 1126 3961 3110 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
1176 0 0 7 1126 3961 3110 0 10 /**
 *
 */ 4 1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
1177 0 0 6 1127 3871 0 0 0 2 4 this 3 3962  9 attr_name 1 3874  
1178 0 0 6 1128 3726 0 0 0 3 4 this 3 3961  9 attr_name 1 3874  6 assign 1 3871  
1179 0 0 6 1129 3962 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1180 0 0 6 1130 3962 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1181 0 0 6 1131 3962 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1182 0 0 6 1132 3962 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1183 0 0 6 1133 3962 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1184 0 0 7 1134 3925 2693 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3962  
1185 0 0 7 1135 3898 2317 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3962  
1186 0 0 7 1138 3961 3110 0 0 1 4 this 3 3962  
1187 0 0 7 1139 3946 2966 0 0 2 4 this 3 3962  5 other 1 3947  
1188 0 0 7 1139 3961 3110 0 0 2 4 this 3 3962  5 other 1 3962  
1189 0 0 7 1140 3946 2966 0 0 2 4 this 3 3962  5 other 1 3947  
1190 0 0 7 1140 3961 3110 0 0 2 4 this 3 3962  5 other 1 3962  
1191 0 0 7 1141 3961 3110 0 0 2 4 this 3 3962  6 scalar 1 3723  
1192 0 0 7 1142 3961 3110 0 0 2 4 this 3 3962  6 scalar 1 3723  
1193 0 0 7 1143 3961 3110 0 0 2 4 this 3 3962  6 scalar 1 3723  
1194 0 0 7 1144 3961 3110 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3962  
1195 0 0 7 1145 3961 3110 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3962  4 onto 1 3947  
1196 0 0 6 1146 3874 0 0 0 1 4 this 3 3962  
1197 0 0 7 1147 3888 0 0 0 0 
1198 0 0 7 1150 3964 3129 0 0 0 
1199 0 0 7 1150 3964 3129 0 10 /**
 *
 */ 2 4 copy 1 3920  1 w 1 3726  
1200 0 0 7 1150 3964 3129 0 10 /**
 *
 */ 1 4 copy 1 3953  
1201 0 0 7 1150 3964 3129 0 0 1 6 param0 0 3965  
1202 0 0 7 1150 3964 3129 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
1203 0 0 7 1150 3964 3129 0 10 /**
 *
 */ 4 1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1204 0 0 6 1151 3871 0 0 0 2 4 this 3 3965  9 attr_name 1 3874  
1205 0 0 6 1152 3726 0 0 0 3 4 this 3 3964  9 attr_name 1 3874  6 assign 1 3871  
1206 0 0 6 1153 3965 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1207 0 0 6 1154 3965 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1208 0 0 6 1155 3965 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1209 0 0 6 1156 3965 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1210 0 0 6 1157 3965 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1211 0 0 7 1158 3928 2720 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3965  
1212 0 0 7 1159 3901 2332 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3965  
1213 0 0 7 1162 3964 3129 0 0 1 4 this 3 3965  
1214 0 0 7 1163 3952 3056 0 0 2 4 this 3 3965  5 other 1 3953  
1215 0 0 7 1163 3964 3129 0 0 2 4 this 3 3965  5 other 1 3965  
1216 0 0 7 1164 3952 3056 0 0 2 4 this 3 3965  5 other 1 3953  
1217 0 0 7 1164 3964 3129 0 0 2 4 this 3 3965  5 other 1 3965  
1218 0 0 7 1165 3964 3129 0 0 2 4 this 3 3965  6 scalar 1 3726  
1219 0 0 7 1166 3964 3129 0 0 2 4 this 3 3965  6 scalar 1 3726  
1220 0 0 7 1167 3964 3129 0 0 2 4 this 3 3965  6 scalar 1 3726  
1221 0 0 6 1168 3874 0 0 0 1 4 this 3 3965  
1222 0 0 7 1169 3888 0 0 0 0 
1223 0 0 7 1172 3967 3150 0 0 0 
1224 0 0 7 1172 3967 3150 0 0 1 6 param0 0 3968  
1225 0 0 7 1172 3967 3150 0 10 /**
 *
 */ 2 4 copy 1 3914  1 w 1 3720  
1226 0 0 7 1172 3967 3150 0 10 /**
 *
 */ 1 4 copy 1 3941  
1227 0 0 7 1172 3967 3150 0 10 /**
 *
 */ 1 10 fill_value 1 3720  
1228 0 0 7 1172 3967 3150 0 10 /**
 *
 */ 4 1 x 1 3720  1 y 1 3720  1 z 1 3720  1 w 1 3720  
1229 0 0 6 1173 3871 0 0 0 2 4 this 3 3968  9 attr_name 1 3874  
1230 0 0 6 1174 3726 0 0 0 3 4 this 3 3967  9 attr_name 1 3874  6 assign 1 3871  
1231 0 0 6 1175 3968 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1232 0 0 6 1176 3968 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1233 0 0 6 1177 3968 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1234 0 0 6 1178 3968 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1235 0 0 6 1179 3968 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1236 0 0 7 1180 3931 2744 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3968  
1237 0 0 7 1181 3904 2349 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3968  
1238 0 0 7 1184 3967 3150 0 0 1 4 this 3 3968  
1239 0 0 7 1185 3940 2872 0 0 2 4 this 3 3968  5 other 1 3941  
1240 0 0 7 1185 3967 3150 0 0 2 4 this 3 3968  5 other 1 3959  
1241 0 0 7 1186 3958 3089 0 0 2 4 this 3 3968  5 other 1 3968  
1242 0 0 7 1186 3940 2872 0 0 2 4 this 3 3968  5 other 1 3941  
1243 0 0 7 1186 3967 3150 0 0 2 4 this 3 3968  5 other 1 3959  
1244 0 0 7 1187 3967 3150 0 0 2 4 this 3 3968  6 scalar 1 3720  
1245 0 0 7 1188 3967 3150 0 0 2 4 this 3 3968  6 scalar 1 3720  
1246 0 0 7 1189 3967 3150 0 0 2 4 this 3 3968  6 scalar 1 3720  
1247 0 0 7 1190 3967 3150 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3968  
1248 0 0 7 1191 3967 3150 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3968  4 onto 1 3941  
1249 0 0 6 1192 3874 0 0 0 1 4 this 3 3968  
1250 0 0 7 1193 3888 0 0 0 0 
1251 0 0 7 1196 3970 3171 0 0 0 
1252 0 0 7 1196 3970 3171 0 0 1 6 param0 0 3971  
1253 0 0 7 1196 3970 3171 0 10 /**
 *
 */ 2 4 copy 1 3917  1 w 1 3723  
1254 0 0 7 1196 3970 3171 0 10 /**
 *
 */ 1 4 copy 1 3947  
1255 0 0 7 1196 3970 3171 0 10 /**
 *
 */ 1 10 fill_value 1 3723  
1256 0 0 7 1196 3970 3171 0 10 /**
 *
 */ 4 1 x 1 3723  1 y 1 3723  1 z 1 3723  1 w 1 3723  
1257 0 0 6 1197 3871 0 0 0 2 4 this 3 3971  9 attr_name 1 3874  
1258 0 0 6 1198 3726 0 0 0 3 4 this 3 3970  9 attr_name 1 3874  6 assign 1 3871  
1259 0 0 6 1199 3971 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1260 0 0 6 1200 3971 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1261 0 0 6 1201 3971 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1262 0 0 6 1202 3971 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1263 0 0 6 1203 3971 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1264 0 0 7 1204 3934 2768 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3971  
1265 0 0 7 1205 3907 2366 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3971  
1266 0 0 7 1208 3970 3171 0 0 1 4 this 3 3971  
1267 0 0 7 1209 3946 2966 0 0 2 4 this 3 3971  5 other 1 3947  
1268 0 0 7 1209 3970 3171 0 0 2 4 this 3 3971  5 other 1 3962  
1269 0 0 7 1210 3961 3110 0 0 2 4 this 3 3971  5 other 1 3971  
1270 0 0 7 1210 3946 2966 0 0 2 4 this 3 3971  5 other 1 3947  
1271 0 0 7 1210 3970 3171 0 0 2 4 this 3 3971  5 other 1 3962  
1272 0 0 7 1211 3970 3171 0 0 2 4 this 3 3971  6 scalar 1 3723  
1273 0 0 7 1212 3970 3171 0 0 2 4 this 3 3971  6 scalar 1 3723  
1274 0 0 7 1213 3970 3171 0 0 2 4 this 3 3971  6 scalar 1 3723  
1275 0 0 7 1214 3970 3171 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3971  
1276 0 0 7 1215 3970 3171 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3971  4 onto 1 3947  
1277 0 0 6 1216 3874 0 0 0 1 4 this 3 3971  
1278 0 0 7 1217 3888 0 0 0 0 
1279 0 0 7 1220 3973 3190 0 0 0 
1280 0 0 7 1220 3973 3190 0 0 1 6 param0 0 3974  
1281 0 0 7 1220 3973 3190 0 10 /**
 *
 */ 2 4 copy 1 3920  1 w 1 3726  
1282 0 0 7 1220 3973 3190 0 10 /**
 *
 */ 1 4 copy 1 3953  
1283 0 0 7 1220 3973 3190 0 10 /**
 *
 */ 1 10 fill_value 1 3726  
1284 0 0 7 1220 3973 3190 0 10 /**
 *
 */ 4 1 x 1 3726  1 y 1 3726  1 z 1 3726  1 w 1 3726  
1285 0 0 6 1221 3871 0 0 0 2 4 this 3 3974  9 attr_name 1 3874  
1286 0 0 6 1222 3726 0 0 0 3 4 this 3 3973  9 attr_name 1 3874  6 assign 1 3871  
1287 0 0 6 1223 3974 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1288 0 0 6 1224 3974 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1289 0 0 6 1225 3974 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1290 0 0 6 1226 3974 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1291 0 0 6 1227 3974 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1292 0 0 7 1228 3937 2790 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3974  
1293 0 0 7 1229 3910 2381 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3974  
1294 0 0 7 1232 3973 3190 0 0 1 4 this 3 3974  
1295 0 0 7 1233 3952 3056 0 0 2 4 this 3 3974  5 other 1 3953  
1296 0 0 7 1233 3973 3190 0 0 2 4 this 3 3974  5 other 1 3965  
1297 0 0 7 1234 3964 3129 0 0 2 4 this 3 3974  5 other 1 3974  
1298 0 0 7 1234 3952 3056 0 0 2 4 this 3 3974  5 other 1 3953  
1299 0 0 7 1234 3973 3190 0 0 2 4 this 3 3974  5 other 1 3965  
1300 0 0 7 1235 3973 3190 0 0 2 4 this 3 3974  6 scalar 1 3726  
1301 0 0 7 1236 3973 3190 0 0 2 4 this 3 3974  6 scalar 1 3726  
1302 0 0 7 1237 3973 3190 0 0 2 4 this 3 3974  6 scalar 1 3726  
1303 0 0 6 1238 3874 0 0 0 1 4 this 3 3974  
1304 0 0 7 1239 3888 0 0 0 0 
1305 0 0 7 1256 3976 3278 0 0 0 
1306 0 0 7 1256 3976 3278 0 0 1 5 other 1 3977  
1307 0 0 7 1256 3976 3278 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3914  6 param1 0 3914  6 param2 0 3914  
1308 0 0 7 1256 3976 3278 0 10 /**
 *
 */ 9 6 param0 0 3720  6 param1 0 3720  6 param2 0 3720  6 param3 0 3720  6 param4 0 3720  6 param5 0 3720  6 param6 0 3720  6 param7 0 3720  6 param8 0 3720  
1309 0 0 6 1257 3976 0 0 0 2 4 this 3 3976  5 other 1 3977  
1310 0 0 6 1257 3976 0 0 10 /**
 *
 */ 2 4 this 3 3976  10 fill_value 1 3720  
1311 0 0 4 1258 3870 0 0 0 2 4 this 3 3976  4 size 1 3868  
1312 0 0 6 1261 3871 0 0 0 1 4 this 3 3977  
1313 0 0 4 1262 3870 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3976  10 fill_value 1 3720  
1314 0 0 4 1263 3870 0 0 10 /**
 *
 */ 10 4 this 3 3976  3 e00 1 3720  3 e01 1 3720  3 e02 1 3720  3 e10 1 3720  3 e11 1 3720  3 e12 1 3720  3 e20 1 3720  3 e21 1 3720  3 e22 1 3720  
1315 0 0 7 1264 3979 3196 0 0 2 4 this 3 3976  1 i 1 3726  
1316 0 0 7 1264 3980 3201 0 0 2 4 this 3 3977  1 i 1 3726  
1317 0 0 6 1265 3726 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1318 0 0 4 1266 3870 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3976  3 row 1 3726  1 v 1 3866  
1319 0 0 4 1266 3870 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3976  3 row 1 3726  1 v 1 3914  
1320 0 0 4 1267 3870 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3976  3 col 1 3726  1 v 1 3866  
1321 0 0 4 1267 3870 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3976  3 col 1 3726  1 v 1 3914  
1322 0 0 4 1268 3870 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3977  10 result_vec 1 3913  3 row 1 3726  
1323 0 0 7 1268 3913 2462 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3977  3 row 1 3726  
1324 0 0 7 1269 3913 2462 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3977  3 col 1 3726  
1325 0 0 7 1274 3865 2141 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3977  3 row 1 3726  
1326 0 0 7 1275 3865 2141 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3977  3 col 1 3726  
1327 0 0 4 1278 3870 0 0 10 /**
 *
 */ 3 4 this 3 3976  3 row 1 3726  3 col 1 3726  
1328 0 0 6 1278 3720 0 0 0 3 4 this 3 3977  3 row 1 3726  3 col 1 3726  
1329 0 0 6 1279 3875 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3977  
1330 0 0 6 1280 3875 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3977  
1331 0 0 6 1281 3720 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3977  3 row 1 3726  3 col 1 3726  
1332 0 0 4 1282 3870 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3976  3 row 1 3726  3 col 1 3726  5 value 1 3720  
1333 0 0 4 1283 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3977  
1334 0 0 6 1284 3726 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3977  
1335 0 0 6 1285 3875 0 0 0 2 4 this 3 3977  5 other 1 3977  
1336 0 0 6 1286 3875 0 0 0 2 4 this 3 3977  5 other 1 3977  
1337 0 0 6 1287 3875 0 0 0 2 4 this 3 3977  5 other 1 3977  
1338 0 0 6 1288 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3977  5 other 1 3977  
1339 0 0 6 1288 3726 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3977  5 other 1 3977  9 threshold 1 3720  
1340 0 0 6 1289 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3977  
1341 0 0 6 1289 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3977  9 threshold 1 3720  
1342 0 0 6 1290 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3977  4 hash 1 3868  
1343 0 0 6 1290 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3977  4 hash 1 3868  9 threshold 1 3720  
1344 0 0 7 1291 3913 2462 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3977  1 v 1 3914  
1345 0 0 7 1292 3865 2141 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3977  1 v 1 3866  
1346 0 0 7 1293 3865 2141 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3977  1 v 1 3866  
1347 0 0 7 1293 3913 2462 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3977  1 v 1 3914  
1348 0 0 7 1294 3913 2462 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3977  1 v 1 3914  
1349 0 0 4 1295 3870 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3977  1 v 1 3913  
1350 0 0 4 1296 3870 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3977  1 v 1 3865  
1351 0 0 4 1297 3870 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3977  1 v 1 3865  
1352 0 0 4 1297 3870 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3977  1 v 1 3913  
1353 0 0 4 1298 3870 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3977  1 v 1 3913  
1354 0 0 4 1299 3870 0 0 25 // this = other1 * other2 3 4 this 3 3976  6 other1 1 3977  6 other2 1 3977  
1355 0 0 7 1300 3976 3278 0 0 2 4 this 3 3977  5 other 1 3977  
1356 0 0 7 1300 3976 3278 0 0 2 4 this 3 3977  6 scalar 1 3720  
1357 0 0 7 1301 3976 3278 0 0 2 4 this 3 3977  6 scalar 1 3720  
1358 0 0 6 1302 3976 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3976  5 other 1 3977  
1359 0 0 6 1303 3976 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3976  5 other 1 3977  
1360 0 0 6 1304 3976 0 0 10 /**
 *
 */ 2 4 this 3 3976  5 other 1 3977  
1361 0 0 6 1304 3976 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3976  6 scalar 1 3720  
1362 0 0 6 1305 3976 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3976  6 scalar 1 3720  
1363 0 0 7 1306 3976 3278 0 0 2 4 this 3 3977  6 scalar 1 3720  
1364 0 0 4 1307 3870 0 0 10 /**
 *
 */ 2 4 this 3 3976  5 other 1 3977  
1365 0 0 6 1308 3720 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3977  
1366 0 0 4 1309 3870 0 0 10 /**
 *
 */ 2 4 this 3 3976  5 other 1 3977  
1367 0 0 4 1310 3870 0 0 10 /**
 *
 */ 1 4 this 3 3976  
1368 0 0 6 1311 3875 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3976  5 other 1 3977  
1369 0 0 6 1312 3875 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3976  
1370 0 0 6 1313 3875 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3976  5 other 1 3977  
1371 0 0 6 1313 3875 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3976  5 other 1 3981  
1372 0 0 6 1314 3977 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1373 0 0 4 1315 3870 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3976  5 trans 1 3866  
1374 0 0 4 1316 3870 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3976  5 angle 1 3720  
1375 0 0 4 1316 3870 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3976  5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1376 0 0 4 1317 3870 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3976  5 scale 1 3866  
1377 0 0 4 1317 3870 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3976  5 scale 1 3914  
1378 0 0 7 1318 3976 3278 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3866  
1379 0 0 7 1318 3976 3278 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3720  2 ty 1 3720  
1380 0 0 7 1319 3976 3278 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3720  
1381 0 0 7 1319 3976 3278 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1382 0 0 7 1320 3976 3278 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3866  
1383 0 0 7 1320 3976 3278 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3914  
1384 0 0 7 1320 3976 3278 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3720  2 sy 1 3720  
1385 0 0 7 1320 3976 3278 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3720  2 sy 1 3720  2 sz 1 3720  
1386 0 0 4 1321 3870 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3976  5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1387 0 0 7 1322 3976 3278 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1388 0 0 4 1323 3870 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3976  5 shear 1 3914  2 cs 1 3739  
1389 0 0 7 1324 3976 3278 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3914  2 cs 1 3739  
1390 0 0 7 1324 3976 3278 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3720  4 shxz 1 3720  4 shyz 1 3720  2 cs 1 3739  
1391 0 0 4 1325 3870 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3976  5 scale 1 3914  5 shear 1 3914  2 cs 1 3739  
1392 0 0 7 1326 3976 3278 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3914  5 shear 1 3914  2 cs 1 3739  
1393 0 0 7 1326 3976 3278 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3720  2 sy 1 3720  2 sz 1 3720  4 shxy 1 3720  4 shxz 1 3720  4 shyz 1 3720  2 cs 1 3739  
1394 0 0 6 1327 3977 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3739  2 to 1 3739  
1395 0 0 6 1328 3875 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3977  5 other 1 3977  
1396 0 0 6 1328 3875 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3977  5 other 1 3977  9 threshold 1 3720  
1397 0 0 4 1329 3870 0 0 10 /**
 *
 */ 2 4 this 3 3977  3 out 1 3878  
1398 0 0 4 1330 3870 0 0 10 /**
 *
 */ 3 4 this 3 3977  3 out 1 3878  12 indent_level 1 3726  
1399 0 0 6 1331 3874 0 0 0 1 4 this 3 3977  
1400 0 0 4 1332 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3977  7 hashgen 1 3876  
1401 0 0 4 1332 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3977  7 hashgen 1 3876  9 threshold 1 3720  
1402 0 0 4 1333 3870 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3977  11 destination 1 3880  
1403 0 0 4 1334 3870 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3976  4 scan 1 3882  
1404 0 0 4 1335 3870 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3977  11 destination 1 3880  
1405 0 0 4 1336 3870 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3976  6 source 1 3882  
1406 0 0 7 1337 3888 0 0 0 0 
1407 0 0 7 1248 3979 3196 0 0 1 6 param0 0 3983  
1408 0 0 4 1244 3870 0 0 10 /**
 *
 */ 2 4 this 3 3979  1 i 1 3726  
1409 0 0 6 1244 3720 0 0 0 2 4 this 3 3983  1 i 1 3726  
1410 0 0 4 1245 3870 0 0 0 3 4 this 3 3979  1 i 1 3726  10 assign_val 1 3720  
1411 0 0 6 1246 3726 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1412 0 0 6 1247 3914 0 0 0 1 4 this 3 3983  
1413 0 0 7 1254 3980 3201 0 0 1 6 param0 0 3985  
1414 0 0 6 1251 3720 0 0 0 2 4 this 3 3985  1 i 1 3726  
1415 0 0 6 1252 3726 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1416 0 0 6 1253 3914 0 0 0 1 4 this 3 3985  
1417 0 0 7 1356 3987 3378 0 0 0 
1418 0 0 7 1356 3987 3378 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3977  
1419 0 0 7 1356 3987 3378 0 10 /**
 *
 */ 2 6 upper3 1 3977  5 trans 1 3914  
1420 0 0 7 1356 3987 3378 0 0 1 5 other 1 3981  
1421 0 0 7 1356 3987 3378 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3941  6 param1 0 3941  6 param2 0 3941  6 param3 0 3941  
1422 0 0 7 1356 3987 3378 0 10 /**
 *
 */ 1 5 other 1 3988  
1423 0 0 7 1356 3987 3378 0 10 /**
 *
 */ 16 6 param0 0 3720  6 param1 0 3720  6 param2 0 3720  6 param3 0 3720  6 param4 0 3720  6 param5 0 3720  6 param6 0 3720  6 param7 0 3720  6 param8 0 3720  6 param9 0 3720  7 param10 0 3720  7 param11 0 3720  7 param12 0 3720  7 param13 0 3720  7 param14 0 3720  7 param15 0 3720  
1424 0 0 6 1357 3987 0 0 0 2 4 this 3 3987  5 other 1 3981  
1425 0 0 6 1357 3987 0 0 10 /**
 *
 */ 2 4 this 3 3987  5 other 1 3988  
1426 0 0 6 1357 3987 0 0 10 /**
 *
 */ 2 4 this 3 3987  10 fill_value 1 3720  
1427 0 0 4 1358 3870 0 0 0 2 4 this 3 3987  4 size 1 3868  
1428 0 0 6 1361 3871 0 0 0 1 4 this 3 3981  
1429 0 0 4 1362 3870 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3987  10 fill_value 1 3720  
1430 0 0 4 1363 3870 0 0 10 /**
 *
 */ 17 4 this 3 3987  3 e00 1 3720  3 e01 1 3720  3 e02 1 3720  3 e03 1 3720  3 e10 1 3720  3 e11 1 3720  3 e12 1 3720  3 e13 1 3720  3 e20 1 3720  3 e21 1 3720  3 e22 1 3720  3 e23 1 3720  3 e30 1 3720  3 e31 1 3720  3 e32 1 3720  3 e33 1 3720  
1431 0 0 4 1364 3870 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3987  6 upper3 1 3977  
1432 0 0 7 1365 3976 3278 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3981  
1433 0 0 7 1366 3990 3286 0 0 2 4 this 3 3987  1 i 1 3726  
1434 0 0 7 1366 3991 3291 0 0 2 4 this 3 3981  1 i 1 3726  
1435 0 0 6 1367 3726 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1436 0 0 4 1368 3870 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3987  3 row 1 3726  1 v 1 3914  
1437 0 0 4 1368 3870 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3987  3 row 1 3726  1 v 1 3941  
1438 0 0 4 1369 3870 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3987  3 col 1 3726  1 v 1 3914  
1439 0 0 4 1369 3870 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3987  3 col 1 3726  1 v 1 3941  
1440 0 0 4 1370 3870 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3981  10 result_vec 1 3940  3 row 1 3726  
1441 0 0 7 1370 3940 2872 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3981  3 row 1 3726  
1442 0 0 7 1371 3940 2872 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3981  3 col 1 3726  
1443 0 0 4 1372 3870 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3981  10 result_vec 1 3913  3 row 1 3726  
1444 0 0 7 1372 3913 2462 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3981  3 row 1 3726  
1445 0 0 7 1378 3913 2462 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3981  3 col 1 3726  
1446 0 0 4 1379 3870 0 0 10 /**
 *
 */ 3 4 this 3 3987  3 row 1 3726  3 col 1 3726  
1447 0 0 6 1379 3720 0 0 0 3 4 this 3 3981  3 row 1 3726  3 col 1 3726  
1448 0 0 6 1380 3875 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3981  
1449 0 0 6 1381 3875 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3981  
1450 0 0 6 1382 3720 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3981  3 row 1 3726  3 col 1 3726  
1451 0 0 4 1383 3870 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3987  3 row 1 3726  3 col 1 3726  5 value 1 3720  
1452 0 0 4 1384 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3981  
1453 0 0 6 1385 3726 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3981  
1454 0 0 4 1386 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3987  
1455 0 0 4 1386 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3981  
1456 0 0 4 1387 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3987  
1457 0 0 4 1387 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3981  
1458 0 0 6 1388 3875 0 0 0 2 4 this 3 3981  5 other 1 3981  
1459 0 0 6 1389 3875 0 0 0 2 4 this 3 3981  5 other 1 3981  
1460 0 0 6 1390 3875 0 0 0 2 4 this 3 3981  5 other 1 3981  
1461 0 0 6 1391 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3981  5 other 1 3981  
1462 0 0 6 1391 3726 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3981  5 other 1 3981  9 threshold 1 3720  
1463 0 0 6 1392 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3981  
1464 0 0 6 1392 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3981  9 threshold 1 3720  
1465 0 0 6 1393 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3981  4 hash 1 3868  
1466 0 0 6 1393 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3981  4 hash 1 3868  9 threshold 1 3720  
1467 0 0 7 1394 3940 2872 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3981  1 v 1 3941  
1468 0 0 7 1395 3913 2462 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3981  1 v 1 3914  
1469 0 0 7 1396 3913 2462 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3981  1 v 1 3914  
1470 0 0 7 1397 3913 2462 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3981  1 v 1 3914  
1471 0 0 7 1398 3913 2462 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3981  1 v 1 3914  
1472 0 0 4 1399 3870 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3981  1 v 1 3940  
1473 0 0 4 1400 3870 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3981  1 v 1 3913  
1474 0 0 4 1401 3870 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3981  1 v 1 3913  
1475 0 0 4 1402 3870 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3981  1 v 1 3913  
1476 0 0 4 1403 3870 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3981  1 v 1 3913  
1477 0 0 4 1404 3870 0 0 25 // this = other1 * other2 3 4 this 3 3987  6 other1 1 3981  6 other2 1 3981  
1478 0 0 7 1405 3987 3378 0 0 2 4 this 3 3981  5 other 1 3981  
1479 0 0 7 1405 3987 3378 0 0 2 4 this 3 3981  6 scalar 1 3720  
1480 0 0 7 1406 3987 3378 0 0 2 4 this 3 3981  6 scalar 1 3720  
1481 0 0 6 1407 3987 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3987  5 other 1 3981  
1482 0 0 6 1408 3987 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3987  5 other 1 3981  
1483 0 0 6 1409 3987 0 0 10 /**
 *
 */ 2 4 this 3 3987  5 other 1 3981  
1484 0 0 6 1409 3987 0 0 10 /**
 *
 */ 2 4 this 3 3987  6 scalar 1 3720  
1485 0 0 6 1410 3987 0 0 10 /**
 *
 */ 2 4 this 3 3987  6 scalar 1 3720  
1486 0 0 7 1411 3987 3378 0 0 2 4 this 3 3981  6 scalar 1 3720  
1487 0 0 4 1412 3870 0 0 10 /**
 *
 */ 2 4 this 3 3987  5 other 1 3981  
1488 0 0 4 1413 3870 0 0 10 /**
 *
 */ 2 4 this 3 3987  5 other 1 3981  
1489 0 0 4 1414 3870 0 0 10 /**
 *
 */ 1 4 this 3 3987  
1490 0 0 6 1415 3875 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3987  5 other 1 3981  
1491 0 0 6 1416 3875 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3987  5 other 1 3981  
1492 0 0 6 1417 3875 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3987  
1493 0 0 4 1418 3870 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3987  5 other 1 3981  6 weight 1 3720  
1494 0 0 6 1419 3981 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1495 0 0 6 1420 3981 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1496 0 0 6 1421 3981 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1497 0 0 4 1422 3870 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3987  5 trans 1 3914  
1498 0 0 4 1423 3870 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3987  5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1499 0 0 4 1424 3870 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3987  5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1500 0 0 4 1425 3870 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3987  5 scale 1 3914  
1501 0 0 4 1426 3870 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3987  5 shear 1 3914  2 cs 1 3739  
1502 0 0 4 1427 3870 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3987  5 scale 1 3914  5 shear 1 3914  2 cs 1 3739  
1503 0 0 7 1428 3987 3378 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3914  
1504 0 0 7 1428 3987 3378 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3720  2 ty 1 3720  2 tz 1 3720  
1505 0 0 7 1429 3987 3378 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1506 0 0 7 1430 3987 3378 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3720  4 axis 1 3914  2 cs 1 3739  
1507 0 0 7 1431 3987 3378 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3914  
1508 0 0 7 1431 3987 3378 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3720  
1509 0 0 7 1431 3987 3378 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3720  2 sy 1 3720  2 sz 1 3720  
1510 0 0 7 1432 3987 3378 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3914  2 cs 1 3739  
1511 0 0 7 1432 3987 3378 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3720  4 shxz 1 3720  4 shyz 1 3720  2 cs 1 3739  
1512 0 0 7 1433 3987 3378 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3914  5 shear 1 3914  2 cs 1 3739  
1513 0 0 7 1433 3987 3378 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3720  2 sy 1 3720  2 sz 1 3720  4 shxy 1 3720  4 shxz 1 3720  4 shyz 1 3720  2 cs 1 3739  
1514 0 0 6 1434 3981 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1515 0 0 6 1435 3981 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1516 0 0 6 1436 3981 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3739  2 to 1 3739  
1517 0 0 6 1437 3875 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3981  5 other 1 3981  
1518 0 0 6 1437 3875 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3981  5 other 1 3981  9 threshold 1 3720  
1519 0 0 4 1438 3870 0 0 10 /**
 *
 */ 2 4 this 3 3981  3 out 1 3878  
1520 0 0 4 1439 3870 0 0 10 /**
 *
 */ 3 4 this 3 3981  3 out 1 3878  12 indent_level 1 3726  
1521 0 0 6 1440 3874 0 0 0 1 4 this 3 3981  
1522 0 0 4 1441 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3981  7 hashgen 1 3876  
1523 0 0 4 1441 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3981  7 hashgen 1 3876  5 scale 1 3720  
1524 0 0 4 1442 3870 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3981  11 destination 1 3880  
1525 0 0 4 1443 3870 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3987  4 scan 1 3882  
1526 0 0 4 1444 3870 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3981  11 destination 1 3880  
1527 0 0 4 1445 3870 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3987  6 source 1 3882  
1528 0 0 7 1446 3888 0 0 0 0 
1529 0 0 7 1348 3990 3286 0 0 1 6 param0 0 3992  
1530 0 0 4 1344 3870 0 0 10 /**
 *
 */ 2 4 this 3 3990  1 i 1 3726  
1531 0 0 6 1344 3720 0 0 0 2 4 this 3 3992  1 i 1 3726  
1532 0 0 4 1345 3870 0 0 0 3 4 this 3 3990  1 i 1 3726  10 assign_val 1 3720  
1533 0 0 6 1346 3726 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1534 0 0 6 1347 3941 0 0 0 1 4 this 3 3992  
1535 0 0 7 1354 3991 3291 0 0 1 6 param0 0 3994  
1536 0 0 6 1351 3720 0 0 0 2 4 this 3 3994  1 i 1 3726  
1537 0 0 6 1352 3726 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1538 0 0 6 1353 3941 0 0 0 1 4 this 3 3994  
1539 0 0 7 1450 3996 3388 0 0 0 
1540 0 0 7 1450 3996 3388 0 10 /**
 *
 */ 1 4 copy 1 3981  
1541 0 0 7 1450 3996 3388 0 0 1 4 copy 1 3988  
1542 0 0 7 1450 3996 3388 0 10 /**
 *
 */ 16 3 e00 1 3720  3 e01 1 3720  3 e02 1 3720  3 e03 1 3720  3 e10 1 3720  3 e11 1 3720  3 e12 1 3720  3 e13 1 3720  3 e20 1 3720  3 e21 1 3720  3 e22 1 3720  3 e23 1 3720  3 e30 1 3720  3 e31 1 3720  3 e32 1 3720  3 e33 1 3720  
1543 0 0 6 1451 3996 0 0 10 /**
 *
 */ 2 4 this 3 3996  4 copy 1 3981  
1544 0 0 6 1451 3996 0 0 0 2 4 this 3 3996  4 copy 1 3988  
1545 0 0 4 1452 3870 0 0 10 /**
 *
 */ 17 4 this 3 3996  3 e00 1 3720  3 e01 1 3720  3 e02 1 3720  3 e03 1 3720  3 e10 1 3720  3 e11 1 3720  3 e12 1 3720  3 e13 1 3720  3 e20 1 3720  3 e21 1 3720  3 e22 1 3720  3 e23 1 3720  3 e30 1 3720  3 e31 1 3720  3 e32 1 3720  3 e33 1 3720  
1546 0 0 4 1453 3870 0 0 10 /**
 *
 */ 3 4 this 3 3996  3 row 1 3726  3 col 1 3726  
1547 0 0 6 1453 3720 0 0 0 3 4 this 3 3988  3 row 1 3726  3 col 1 3726  
1548 0 0 4 1454 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3988  
1549 0 0 6 1455 3726 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3988  
1550 0 0 6 1456 3875 0 0 0 2 4 this 3 3988  5 other 1 3988  
1551 0 0 6 1457 3875 0 0 0 2 4 this 3 3988  5 other 1 3988  
1552 0 0 7 1458 3888 0 0 0 0 
1553 0 0 7 1475 3997 3476 0 0 0 
1554 0 0 7 1475 3997 3476 0 0 1 5 other 1 3998  
1555 0 0 7 1475 3997 3476 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3917  6 param1 0 3917  6 param2 0 3917  
1556 0 0 7 1475 3997 3476 0 10 /**
 *
 */ 9 6 param0 0 3723  6 param1 0 3723  6 param2 0 3723  6 param3 0 3723  6 param4 0 3723  6 param5 0 3723  6 param6 0 3723  6 param7 0 3723  6 param8 0 3723  
1557 0 0 6 1476 3997 0 0 0 2 4 this 3 3997  5 other 1 3998  
1558 0 0 6 1476 3997 0 0 10 /**
 *
 */ 2 4 this 3 3997  10 fill_value 1 3723  
1559 0 0 4 1477 3870 0 0 0 2 4 this 3 3997  4 size 1 3868  
1560 0 0 6 1480 3871 0 0 0 1 4 this 3 3998  
1561 0 0 4 1481 3870 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3997  10 fill_value 1 3723  
1562 0 0 4 1482 3870 0 0 10 /**
 *
 */ 10 4 this 3 3997  3 e00 1 3723  3 e01 1 3723  3 e02 1 3723  3 e10 1 3723  3 e11 1 3723  3 e12 1 3723  3 e20 1 3723  3 e21 1 3723  3 e22 1 3723  
1563 0 0 7 1483 4000 3394 0 0 2 4 this 3 3997  1 i 1 3726  
1564 0 0 7 1483 4001 3399 0 0 2 4 this 3 3998  1 i 1 3726  
1565 0 0 6 1484 3726 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1566 0 0 4 1485 3870 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3997  3 row 1 3726  1 v 1 3890  
1567 0 0 4 1485 3870 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3997  3 row 1 3726  1 v 1 3917  
1568 0 0 4 1486 3870 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3997  3 col 1 3726  1 v 1 3890  
1569 0 0 4 1486 3870 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3997  3 col 1 3726  1 v 1 3917  
1570 0 0 4 1487 3870 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3998  10 result_vec 1 3916  3 row 1 3726  
1571 0 0 7 1487 3916 2543 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3998  3 row 1 3726  
1572 0 0 7 1488 3916 2543 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3998  3 col 1 3726  
1573 0 0 7 1493 3889 2212 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3998  3 row 1 3726  
1574 0 0 7 1494 3889 2212 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3998  3 col 1 3726  
1575 0 0 4 1497 3870 0 0 10 /**
 *
 */ 3 4 this 3 3997  3 row 1 3726  3 col 1 3726  
1576 0 0 6 1497 3723 0 0 0 3 4 this 3 3998  3 row 1 3726  3 col 1 3726  
1577 0 0 6 1498 3875 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3998  
1578 0 0 6 1499 3875 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3998  
1579 0 0 6 1500 3723 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3998  3 row 1 3726  3 col 1 3726  
1580 0 0 4 1501 3870 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3997  3 row 1 3726  3 col 1 3726  5 value 1 3723  
1581 0 0 4 1502 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3998  
1582 0 0 6 1503 3726 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3998  
1583 0 0 6 1504 3875 0 0 0 2 4 this 3 3998  5 other 1 3998  
1584 0 0 6 1505 3875 0 0 0 2 4 this 3 3998  5 other 1 3998  
1585 0 0 6 1506 3875 0 0 0 2 4 this 3 3998  5 other 1 3998  
1586 0 0 6 1507 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3998  5 other 1 3998  
1587 0 0 6 1507 3726 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3998  5 other 1 3998  9 threshold 1 3723  
1588 0 0 6 1508 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3998  
1589 0 0 6 1508 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3998  9 threshold 1 3723  
1590 0 0 6 1509 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3998  4 hash 1 3868  
1591 0 0 6 1509 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3998  4 hash 1 3868  9 threshold 1 3723  
1592 0 0 7 1510 3916 2543 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3998  1 v 1 3917  
1593 0 0 7 1511 3889 2212 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3998  1 v 1 3890  
1594 0 0 7 1512 3889 2212 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3998  1 v 1 3890  
1595 0 0 7 1512 3916 2543 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3998  1 v 1 3917  
1596 0 0 7 1513 3916 2543 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3998  1 v 1 3917  
1597 0 0 4 1514 3870 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3998  1 v 1 3916  
1598 0 0 4 1515 3870 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3998  1 v 1 3889  
1599 0 0 4 1516 3870 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3998  1 v 1 3889  
1600 0 0 4 1516 3870 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3998  1 v 1 3916  
1601 0 0 4 1517 3870 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3998  1 v 1 3916  
1602 0 0 4 1518 3870 0 0 25 // this = other1 * other2 3 4 this 3 3997  6 other1 1 3998  6 other2 1 3998  
1603 0 0 7 1519 3997 3476 0 0 2 4 this 3 3998  5 other 1 3998  
1604 0 0 7 1519 3997 3476 0 0 2 4 this 3 3998  6 scalar 1 3723  
1605 0 0 7 1520 3997 3476 0 0 2 4 this 3 3998  6 scalar 1 3723  
1606 0 0 6 1521 3997 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3997  5 other 1 3998  
1607 0 0 6 1522 3997 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3997  5 other 1 3998  
1608 0 0 6 1523 3997 0 0 10 /**
 *
 */ 2 4 this 3 3997  5 other 1 3998  
1609 0 0 6 1523 3997 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3997  6 scalar 1 3723  
1610 0 0 6 1524 3997 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3997  6 scalar 1 3723  
1611 0 0 7 1525 3997 3476 0 0 2 4 this 3 3998  6 scalar 1 3723  
1612 0 0 4 1526 3870 0 0 10 /**
 *
 */ 2 4 this 3 3997  5 other 1 3998  
1613 0 0 6 1527 3723 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3998  
1614 0 0 4 1528 3870 0 0 10 /**
 *
 */ 2 4 this 3 3997  5 other 1 3998  
1615 0 0 4 1529 3870 0 0 10 /**
 *
 */ 1 4 this 3 3997  
1616 0 0 6 1530 3875 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3997  5 other 1 3998  
1617 0 0 6 1531 3875 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3997  
1618 0 0 6 1532 3875 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3997  5 other 1 3998  
1619 0 0 6 1532 3875 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3997  5 other 1 4002  
1620 0 0 6 1533 3998 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1621 0 0 4 1534 3870 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3997  5 trans 1 3890  
1622 0 0 4 1535 3870 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3997  5 angle 1 3723  
1623 0 0 4 1535 3870 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3997  5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1624 0 0 4 1536 3870 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3997  5 scale 1 3890  
1625 0 0 4 1536 3870 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3997  5 scale 1 3917  
1626 0 0 7 1537 3997 3476 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3890  
1627 0 0 7 1537 3997 3476 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3723  2 ty 1 3723  
1628 0 0 7 1538 3997 3476 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3723  
1629 0 0 7 1538 3997 3476 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1630 0 0 7 1539 3997 3476 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3890  
1631 0 0 7 1539 3997 3476 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3917  
1632 0 0 7 1539 3997 3476 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3723  2 sy 1 3723  
1633 0 0 7 1539 3997 3476 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3723  2 sy 1 3723  2 sz 1 3723  
1634 0 0 4 1540 3870 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3997  5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1635 0 0 7 1541 3997 3476 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1636 0 0 4 1542 3870 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3997  5 shear 1 3917  2 cs 1 3739  
1637 0 0 7 1543 3997 3476 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3917  2 cs 1 3739  
1638 0 0 7 1543 3997 3476 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3723  4 shxz 1 3723  4 shyz 1 3723  2 cs 1 3739  
1639 0 0 4 1544 3870 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3997  5 scale 1 3917  5 shear 1 3917  2 cs 1 3739  
1640 0 0 7 1545 3997 3476 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3917  5 shear 1 3917  2 cs 1 3739  
1641 0 0 7 1545 3997 3476 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3723  2 sy 1 3723  2 sz 1 3723  4 shxy 1 3723  4 shxz 1 3723  4 shyz 1 3723  2 cs 1 3739  
1642 0 0 6 1546 3998 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3739  2 to 1 3739  
1643 0 0 6 1547 3875 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3998  5 other 1 3998  
1644 0 0 6 1547 3875 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3998  5 other 1 3998  9 threshold 1 3723  
1645 0 0 4 1548 3870 0 0 10 /**
 *
 */ 2 4 this 3 3998  3 out 1 3878  
1646 0 0 4 1549 3870 0 0 10 /**
 *
 */ 3 4 this 3 3998  3 out 1 3878  12 indent_level 1 3726  
1647 0 0 6 1550 3874 0 0 0 1 4 this 3 3998  
1648 0 0 4 1551 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3998  7 hashgen 1 3876  
1649 0 0 4 1551 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3998  7 hashgen 1 3876  9 threshold 1 3723  
1650 0 0 4 1552 3870 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3998  11 destination 1 3880  
1651 0 0 4 1553 3870 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3997  4 scan 1 3882  
1652 0 0 4 1554 3870 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3998  11 destination 1 3880  
1653 0 0 4 1555 3870 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3997  6 source 1 3882  
1654 0 0 7 1556 3888 0 0 0 0 
1655 0 0 7 1467 4000 3394 0 0 1 6 param0 0 4004  
1656 0 0 4 1463 3870 0 0 10 /**
 *
 */ 2 4 this 3 4000  1 i 1 3726  
1657 0 0 6 1463 3723 0 0 0 2 4 this 3 4004  1 i 1 3726  
1658 0 0 4 1464 3870 0 0 0 3 4 this 3 4000  1 i 1 3726  10 assign_val 1 3723  
1659 0 0 6 1465 3726 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1660 0 0 6 1466 3917 0 0 0 1 4 this 3 4004  
1661 0 0 7 1473 4001 3399 0 0 1 6 param0 0 4006  
1662 0 0 6 1470 3723 0 0 0 2 4 this 3 4006  1 i 1 3726  
1663 0 0 6 1471 3726 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1664 0 0 6 1472 3917 0 0 0 1 4 this 3 4006  
1665 0 0 7 1573 4008 3574 0 0 0 
1666 0 0 7 1573 4008 3574 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3998  
1667 0 0 7 1573 4008 3574 0 10 /**
 *
 */ 2 6 upper3 1 3998  5 trans 1 3917  
1668 0 0 7 1573 4008 3574 0 0 1 5 other 1 4002  
1669 0 0 7 1573 4008 3574 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3947  6 param1 0 3947  6 param2 0 3947  6 param3 0 3947  
1670 0 0 7 1573 4008 3574 0 10 /**
 *
 */ 1 5 other 1 4009  
1671 0 0 7 1573 4008 3574 0 10 /**
 *
 */ 16 6 param0 0 3723  6 param1 0 3723  6 param2 0 3723  6 param3 0 3723  6 param4 0 3723  6 param5 0 3723  6 param6 0 3723  6 param7 0 3723  6 param8 0 3723  6 param9 0 3723  7 param10 0 3723  7 param11 0 3723  7 param12 0 3723  7 param13 0 3723  7 param14 0 3723  7 param15 0 3723  
1672 0 0 6 1574 4008 0 0 0 2 4 this 3 4008  5 other 1 4002  
1673 0 0 6 1574 4008 0 0 10 /**
 *
 */ 2 4 this 3 4008  5 other 1 4009  
1674 0 0 6 1574 4008 0 0 10 /**
 *
 */ 2 4 this 3 4008  10 fill_value 1 3723  
1675 0 0 4 1575 3870 0 0 0 2 4 this 3 4008  4 size 1 3868  
1676 0 0 6 1578 3871 0 0 0 1 4 this 3 4002  
1677 0 0 4 1579 3870 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 4008  10 fill_value 1 3723  
1678 0 0 4 1580 3870 0 0 10 /**
 *
 */ 17 4 this 3 4008  3 e00 1 3723  3 e01 1 3723  3 e02 1 3723  3 e03 1 3723  3 e10 1 3723  3 e11 1 3723  3 e12 1 3723  3 e13 1 3723  3 e20 1 3723  3 e21 1 3723  3 e22 1 3723  3 e23 1 3723  3 e30 1 3723  3 e31 1 3723  3 e32 1 3723  3 e33 1 3723  
1679 0 0 4 1581 3870 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 4008  6 upper3 1 3998  
1680 0 0 7 1582 3997 3476 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 4002  
1681 0 0 7 1583 4011 3482 0 0 2 4 this 3 4008  1 i 1 3726  
1682 0 0 7 1583 4012 3487 0 0 2 4 this 3 4002  1 i 1 3726  
1683 0 0 6 1584 3726 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1684 0 0 4 1585 3870 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 4008  3 row 1 3726  1 v 1 3917  
1685 0 0 4 1585 3870 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 4008  3 row 1 3726  1 v 1 3947  
1686 0 0 4 1586 3870 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 4008  3 col 1 3726  1 v 1 3917  
1687 0 0 4 1586 3870 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 4008  3 col 1 3726  1 v 1 3947  
1688 0 0 4 1587 3870 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 4002  10 result_vec 1 3946  3 row 1 3726  
1689 0 0 7 1587 3946 2966 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 4002  3 row 1 3726  
1690 0 0 7 1588 3946 2966 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 4002  3 col 1 3726  
1691 0 0 4 1589 3870 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 4002  10 result_vec 1 3916  3 row 1 3726  
1692 0 0 7 1589 3916 2543 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 4002  3 row 1 3726  
1693 0 0 7 1595 3916 2543 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 4002  3 col 1 3726  
1694 0 0 4 1596 3870 0 0 10 /**
 *
 */ 3 4 this 3 4008  3 row 1 3726  3 col 1 3726  
1695 0 0 6 1596 3723 0 0 0 3 4 this 3 4002  3 row 1 3726  3 col 1 3726  
1696 0 0 6 1597 3875 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 4002  
1697 0 0 6 1598 3875 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 4002  
1698 0 0 6 1599 3723 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 4002  3 row 1 3726  3 col 1 3726  
1699 0 0 4 1600 3870 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 4008  3 row 1 3726  3 col 1 3726  5 value 1 3723  
1700 0 0 4 1601 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 4002  
1701 0 0 6 1602 3726 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 4002  
1702 0 0 4 1603 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 4008  
1703 0 0 4 1603 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 4002  
1704 0 0 4 1604 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 4008  
1705 0 0 4 1604 3870 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 4002  
1706 0 0 6 1605 3875 0 0 0 2 4 this 3 4002  5 other 1 4002  
1707 0 0 6 1606 3875 0 0 0 2 4 this 3 4002  5 other 1 4002  
1708 0 0 6 1607 3875 0 0 0 2 4 this 3 4002  5 other 1 4002  
1709 0 0 6 1608 3726 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 4002  5 other 1 4002  
1710 0 0 6 1608 3726 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 4002  5 other 1 4002  9 threshold 1 3723  
1711 0 0 6 1609 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 4002  
1712 0 0 6 1609 3868 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 4002  9 threshold 1 3723  
1713 0 0 6 1610 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 4002  4 hash 1 3868  
1714 0 0 6 1610 3868 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 4002  4 hash 1 3868  9 threshold 1 3723  
1715 0 0 7 1611 3946 2966 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 4002  1 v 1 3947  
1716 0 0 7 1612 3916 2543 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 4002  1 v 1 3917  
1717 0 0 7 1613 3916 2543 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 4002  1 v 1 3917  
1718 0 0 7 1614 3916 2543 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 4002  1 v 1 3917  
1719 0 0 7 1615 3916 2543 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 4002  1 v 1 3917  
1720 0 0 4 1616 3870 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 4002  1 v 1 3946  
1721 0 0 4 1617 3870 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 4002  1 v 1 3916  
1722 0 0 4 1618 3870 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 4002  1 v 1 3916  
1723 0 0 4 1619 3870 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 4002  1 v 1 3916  
1724 0 0 4 1620 3870 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 4002  1 v 1 3916  
1725 0 0 4 1621 3870 0 0 25 // this = other1 * other2 3 4 this 3 4008  6 other1 1 4002  6 other2 1 4002  
1726 0 0 7 1622 4008 3574 0 0 2 4 this 3 4002  5 other 1 4002  
1727 0 0 7 1622 4008 3574 0 0 2 4 this 3 4002  6 scalar 1 3723  
1728 0 0 7 1623 4008 3574 0 0 2 4 this 3 4002  6 scalar 1 3723  
1729 0 0 6 1624 4008 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 4008  5 other 1 4002  
1730 0 0 6 1625 4008 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 4008  5 other 1 4002  
1731 0 0 6 1626 4008 0 0 10 /**
 *
 */ 2 4 this 3 4008  5 other 1 4002  
1732 0 0 6 1626 4008 0 0 10 /**
 *
 */ 2 4 this 3 4008  6 scalar 1 3723  
1733 0 0 6 1627 4008 0 0 10 /**
 *
 */ 2 4 this 3 4008  6 scalar 1 3723  
1734 0 0 7 1628 4008 3574 0 0 2 4 this 3 4002  6 scalar 1 3723  
1735 0 0 4 1629 3870 0 0 10 /**
 *
 */ 2 4 this 3 4008  5 other 1 4002  
1736 0 0 4 1630 3870 0 0 10 /**
 *
 */ 2 4 this 3 4008  5 other 1 4002  
1737 0 0 4 1631 3870 0 0 10 /**
 *
 */ 1 4 this 3 4008  
1738 0 0 6 1632 3875 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 4008  5 other 1 4002  
1739 0 0 6 1633 3875 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 4008  5 other 1 4002  
1740 0 0 6 1634 3875 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 4008  
1741 0 0 4 1635 3870 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 4008  5 other 1 4002  6 weight 1 3723  
1742 0 0 6 1636 4002 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1743 0 0 6 1637 4002 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1744 0 0 6 1638 4002 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1745 0 0 4 1639 3870 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 4008  5 trans 1 3917  
1746 0 0 4 1640 3870 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 4008  5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1747 0 0 4 1641 3870 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 4008  5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1748 0 0 4 1642 3870 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 4008  5 scale 1 3917  
1749 0 0 4 1643 3870 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 4008  5 shear 1 3917  2 cs 1 3739  
1750 0 0 4 1644 3870 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 4008  5 scale 1 3917  5 shear 1 3917  2 cs 1 3739  
1751 0 0 7 1645 4008 3574 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3917  
1752 0 0 7 1645 4008 3574 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3723  2 ty 1 3723  2 tz 1 3723  
1753 0 0 7 1646 4008 3574 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1754 0 0 7 1647 4008 3574 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3723  4 axis 1 3917  2 cs 1 3739  
1755 0 0 7 1648 4008 3574 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3917  
1756 0 0 7 1648 4008 3574 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3723  
1757 0 0 7 1648 4008 3574 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3723  2 sy 1 3723  2 sz 1 3723  
1758 0 0 7 1649 4008 3574 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3917  2 cs 1 3739  
1759 0 0 7 1649 4008 3574 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3723  4 shxz 1 3723  4 shyz 1 3723  2 cs 1 3739  
1760 0 0 7 1650 4008 3574 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3917  5 shear 1 3917  2 cs 1 3739  
1761 0 0 7 1650 4008 3574 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3723  2 sy 1 3723  2 sz 1 3723  4 shxy 1 3723  4 shxz 1 3723  4 shyz 1 3723  2 cs 1 3739  
1762 0 0 6 1651 4002 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1763 0 0 6 1652 4002 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1764 0 0 6 1653 4002 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3739  2 to 1 3739  
1765 0 0 6 1654 3875 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 4002  5 other 1 4002  
1766 0 0 6 1654 3875 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 4002  5 other 1 4002  9 threshold 1 3723  
1767 0 0 4 1655 3870 0 0 10 /**
 *
 */ 2 4 this 3 4002  3 out 1 3878  
1768 0 0 4 1656 3870 0 0 10 /**
 *
 */ 3 4 this 3 4002  3 out 1 3878  12 indent_level 1 3726  
1769 0 0 6 1657 3874 0 0 0 1 4 this 3 4002  
1770 0 0 4 1658 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 4002  7 hashgen 1 3876  
1771 0 0 4 1658 3870 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 4002  7 hashgen 1 3876  5 scale 1 3723  
1772 0 0 4 1659 3870 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 4002  11 destination 1 3880  
1773 0 0 4 1660 3870 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 4008  4 scan 1 3882  
1774 0 0 4 1661 3870 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 4002  11 destination 1 3880  
1775 0 0 4 1662 3870 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 4008  6 source 1 3882  
1776 0 0 7 1663 3888 0 0 0 0 
1777 0 0 7 1565 4011 3482 0 0 1 6 param0 0 4013  
1778 0 0 4 1561 3870 0 0 10 /**
 *
 */ 2 4 this 3 4011  1 i 1 3726  
1779 0 0 6 1561 3723 0 0 0 2 4 this 3 4013  1 i 1 3726  
1780 0 0 4 1562 3870 0 0 0 3 4 this 3 4011  1 i 1 3726  10 assign_val 1 3723  
1781 0 0 6 1563 3726 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1782 0 0 6 1564 3947 0 0 0 1 4 this 3 4013  
1783 0 0 7 1571 4012 3487 0 0 1 6 param0 0 4015  
1784 0 0 6 1568 3723 0 0 0 2 4 this 3 4015  1 i 1 3726  
1785 0 0 6 1569 3726 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1786 0 0 6 1570 3947 0 0 0 1 4 this 3 4015  
1787 0 0 7 1667 4017 3584 0 0 0 
1788 0 0 7 1667 4017 3584 0 10 /**
 *
 */ 1 4 copy 1 4002  
1789 0 0 7 1667 4017 3584 0 0 1 4 copy 1 4009  
1790 0 0 7 1667 4017 3584 0 10 /**
 *
 */ 16 3 e00 1 3723  3 e01 1 3723  3 e02 1 3723  3 e03 1 3723  3 e10 1 3723  3 e11 1 3723  3 e12 1 3723  3 e13 1 3723  3 e20 1 3723  3 e21 1 3723  3 e22 1 3723  3 e23 1 3723  3 e30 1 3723  3 e31 1 3723  3 e32 1 3723  3 e33 1 3723  
1791 0 0 6 1668 4017 0 0 10 /**
 *
 */ 2 4 this 3 4017  4 copy 1 4002  
1792 0 0 6 1668 4017 0 0 0 2 4 this 3 4017  4 copy 1 4009  
1793 0 0 4 1669 3870 0 0 10 /**
 *
 */ 17 4 this 3 4017  3 e00 1 3723  3 e01 1 3723  3 e02 1 3723  3 e03 1 3723  3 e10 1 3723  3 e11 1 3723  3 e12 1 3723  3 e13 1 3723  3 e20 1 3723  3 e21 1 3723  3 e22 1 3723  3 e23 1 3723  3 e30 1 3723  3 e31 1 3723  3 e32 1 3723  3 e33 1 3723  
1794 0 0 4 1670 3870 0 0 10 /**
 *
 */ 3 4 this 3 4017  3 row 1 3726  3 col 1 3726  
1795 0 0 6 1670 3723 0 0 0 3 4 this 3 4009  3 row 1 3726  3 col 1 3726  
1796 0 0 4 1671 3870 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 4009  
1797 0 0 6 1672 3726 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 4009  
1798 0 0 6 1673 3875 0 0 0 2 4 this 3 4009  5 other 1 4009  
1799 0 0 6 1674 3875 0 0 0 2 4 this 3 4009  5 other 1 4009  
1800 0 0 7 1675 3888 0 0 0 0 
1801 0 0 7 1686 4018 3641 0 10 /**
 *
 */ 0 
1802 0 0 7 1686 4018 3641 0 0 1 6 param0 0 4019  
1803 0 0 7 1686 4018 3641 0 10 /**
 *
 */ 1 4 copy 1 3941  
1804 0 0 7 1686 4018 3641 0 10 /**
 *
 */ 2 1 r 1 3720  4 copy 1 3914  
1805 0 0 7 1686 4018 3641 0 10 /**
 *
 */ 4 1 r 1 3720  1 i 1 3720  1 j 1 3720  1 k 1 3720  
1806 0 0 7 1687 4018 3641 0 10 /**
 *
 */ 1 1 v 1 3923  
1807 0 0 7 1688 4018 3641 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 4019  
1808 0 0 7 1689 3913 2462 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 4019  1 v 1 3914  
1809 0 0 7 1689 3940 2872 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 4019  1 v 1 3941  
1810 0 0 7 1690 4018 3641 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 4019  3 rhs 1 4019  
1811 0 0 7 1691 4018 3641 0 0 1 4 this 3 4019  
1812 0 0 7 1692 4018 3641 0 0 2 4 this 3 4019  5 other 1 4019  
1813 0 0 7 1693 4018 3641 0 0 2 4 this 3 4019  5 other 1 4019  
1814 0 0 6 1694 3720 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 4019  5 other 1 4019  
1815 0 0 6 1695 3720 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 4019  5 other 1 4019  
1816 0 0 7 1696 3976 3278 0 0 2 4 this 3 4018  6 param0 0 3977  
1817 0 0 7 1696 3987 3378 0 0 2 4 this 3 4018  6 param0 0 3981  
1818 0 0 7 1696 4018 3641 0 0 2 4 this 3 4019  6 param0 0 4019  
1819 0 0 7 1696 4018 3641 0 0 2 4 this 3 4019  6 scalar 1 3720  
1820 0 0 7 1697 4018 3641 0 0 2 4 this 3 4019  6 scalar 1 3720  
1821 0 0 6 1698 4018 0 0 10 /**
 *
 */ 2 4 this 3 4018  6 param0 0 4019  
1822 0 0 7 1699 4018 3641 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 4019  6 param0 0 3720  
1823 0 0 6 1700 3875 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 4019  5 other 1 4019  
1824 0 0 6 1700 3875 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 4019  5 other 1 4019  9 threshold 1 3720  
1825 0 0 6 1701 3875 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 4019  5 other 1 4019  
1826 0 0 6 1702 3875 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 4019  5 other 1 4019  9 threshold 1 3720  
1827 0 0 4 1703 3870 0 0 10 /**
 *
 */ 2 4 this 3 4019  6 param0 0 3878  
1828 0 0 4 1704 3870 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 4019  1 m 1 3976  
1829 0 0 4 1704 3870 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 4019  1 m 1 3987  
1830 0 0 4 1705 3870 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 4018  1 m 1 3977  
1831 0 0 4 1705 3870 0 0 10 /**
 *
 */ 2 4 this 3 4018  1 m 1 3981  
1832 0 0 4 1706 3870 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 4018  3 hpr 1 3914  2 cs 1 3739  
1833 0 0 7 1707 3913 2462 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 4019  2 cs 1 3739  
1834 0 0 7 1708 3922 2658 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 4019  
1835 0 0 7 1709 3922 2658 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 4019  
1836 0 0 6 1710 3720 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 4019  
1837 0 0 6 1711 3720 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 4019  
1838 0 0 4 1712 3870 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 4018  9 angle_rad 1 3720  4 axis 1 3923  
1839 0 0 4 1713 3870 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 4018  9 angle_deg 1 3720  4 axis 1 3923  
1840 0 0 7 1714 3922 2658 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 4019  2 cs 1 3739  
1841 0 0 7 1715 3922 2658 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 4019  2 cs 1 3739  
1842 0 0 7 1716 3922 2658 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 4019  2 cs 1 3739  
1843 0 0 6 1717 3720 0 0 10 /**
 *
 */ 1 4 this 3 4019  
1844 0 0 6 1718 3720 0 0 10 /**
 *
 */ 1 4 this 3 4019  
1845 0 0 6 1719 3720 0 0 10 /**
 *
 */ 1 4 this 3 4019  
1846 0 0 6 1720 3720 0 0 10 /**
 *
 */ 1 4 this 3 4019  
1847 0 0 4 1721 3870 0 0 10 /**
 *
 */ 2 4 this 3 4018  1 r 1 3720  
1848 0 0 4 1722 3870 0 0 10 /**
 *
 */ 2 4 this 3 4018  1 i 1 3720  
1849 0 0 4 1723 3870 0 0 10 /**
 *
 */ 2 4 this 3 4018  1 j 1 3720  
1850 0 0 4 1724 3870 0 0 10 /**
 *
 */ 2 4 this 3 4018  1 k 1 3720  
1851 0 0 6 1725 3875 0 0 10 /**
 *
 */ 1 4 this 3 4018  
1852 0 0 6 1726 3875 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 4018  5 other 1 4019  
1853 0 0 6 1727 3875 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 4018  
1854 0 0 6 1728 3875 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 4018  5 other 1 4019  
1855 0 0 6 1729 3875 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 4018  
1856 0 0 6 1730 3875 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 4019  
1857 0 0 6 1731 3875 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 4019  9 tolerance 1 3720  
1858 0 0 6 1732 4019 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1859 0 0 7 1733 3888 0 0 0 0 
1860 0 0 7 1736 4021 3690 0 10 /**
 *
 */ 0 
1861 0 0 7 1736 4021 3690 0 0 1 6 param0 0 4022  
1862 0 0 7 1736 4021 3690 0 10 /**
 *
 */ 1 4 copy 1 3947  
1863 0 0 7 1736 4021 3690 0 10 /**
 *
 */ 2 1 r 1 3723  4 copy 1 3917  
1864 0 0 7 1736 4021 3690 0 10 /**
 *
 */ 4 1 r 1 3723  1 i 1 3723  1 j 1 3723  1 k 1 3723  
1865 0 0 7 1737 4021 3690 0 10 /**
 *
 */ 1 1 v 1 3926  
1866 0 0 7 1738 4021 3690 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 4022  
1867 0 0 7 1739 3916 2543 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 4022  1 v 1 3917  
1868 0 0 7 1739 3946 2966 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 4022  1 v 1 3947  
1869 0 0 7 1740 4021 3690 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 4022  3 rhs 1 4022  
1870 0 0 7 1741 4021 3690 0 0 1 4 this 3 4022  
1871 0 0 7 1742 4021 3690 0 0 2 4 this 3 4022  5 other 1 4022  
1872 0 0 7 1743 4021 3690 0 0 2 4 this 3 4022  5 other 1 4022  
1873 0 0 6 1744 3723 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 4022  5 other 1 4022  
1874 0 0 6 1745 3723 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 4022  5 other 1 4022  
1875 0 0 7 1746 3997 3476 0 0 2 4 this 3 4021  6 param0 0 3998  
1876 0 0 7 1746 4008 3574 0 0 2 4 this 3 4021  6 param0 0 4002  
1877 0 0 7 1746 4021 3690 0 0 2 4 this 3 4022  6 param0 0 4022  
1878 0 0 7 1746 4021 3690 0 0 2 4 this 3 4022  6 scalar 1 3723  
1879 0 0 7 1747 4021 3690 0 0 2 4 this 3 4022  6 scalar 1 3723  
1880 0 0 6 1748 4021 0 0 10 /**
 *
 */ 2 4 this 3 4021  6 param0 0 4022  
1881 0 0 7 1749 4021 3690 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 4022  6 param0 0 3723  
1882 0 0 6 1750 3875 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 4022  5 other 1 4022  
1883 0 0 6 1750 3875 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 4022  5 other 1 4022  9 threshold 1 3723  
1884 0 0 6 1751 3875 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 4022  5 other 1 4022  
1885 0 0 6 1752 3875 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 4022  5 other 1 4022  9 threshold 1 3723  
1886 0 0 4 1753 3870 0 0 10 /**
 *
 */ 2 4 this 3 4022  6 param0 0 3878  
1887 0 0 4 1754 3870 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 4022  1 m 1 3997  
1888 0 0 4 1754 3870 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 4022  1 m 1 4008  
1889 0 0 4 1755 3870 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 4021  1 m 1 3998  
1890 0 0 4 1755 3870 0 0 10 /**
 *
 */ 2 4 this 3 4021  1 m 1 4002  
1891 0 0 4 1756 3870 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 4021  3 hpr 1 3917  2 cs 1 3739  
1892 0 0 7 1757 3916 2543 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 4022  2 cs 1 3739  
1893 0 0 7 1758 3925 2693 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 4022  
1894 0 0 7 1759 3925 2693 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 4022  
1895 0 0 6 1760 3723 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 4022  
1896 0 0 6 1761 3723 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 4022  
1897 0 0 4 1762 3870 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 4021  9 angle_rad 1 3723  4 axis 1 3926  
1898 0 0 4 1763 3870 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 4021  9 angle_deg 1 3723  4 axis 1 3926  
1899 0 0 7 1764 3925 2693 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 4022  2 cs 1 3739  
1900 0 0 7 1765 3925 2693 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 4022  2 cs 1 3739  
1901 0 0 7 1766 3925 2693 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 4022  2 cs 1 3739  
1902 0 0 6 1767 3723 0 0 10 /**
 *
 */ 1 4 this 3 4022  
1903 0 0 6 1768 3723 0 0 10 /**
 *
 */ 1 4 this 3 4022  
1904 0 0 6 1769 3723 0 0 10 /**
 *
 */ 1 4 this 3 4022  
1905 0 0 6 1770 3723 0 0 10 /**
 *
 */ 1 4 this 3 4022  
1906 0 0 4 1771 3870 0 0 10 /**
 *
 */ 2 4 this 3 4021  1 r 1 3723  
1907 0 0 4 1772 3870 0 0 10 /**
 *
 */ 2 4 this 3 4021  1 i 1 3723  
1908 0 0 4 1773 3870 0 0 10 /**
 *
 */ 2 4 this 3 4021  1 j 1 3723  
1909 0 0 4 1774 3870 0 0 10 /**
 *
 */ 2 4 this 3 4021  1 k 1 3723  
1910 0 0 6 1775 3875 0 0 10 /**
 *
 */ 1 4 this 3 4021  
1911 0 0 6 1776 3875 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 4021  5 other 1 4022  
1912 0 0 6 1777 3875 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 4021  
1913 0 0 6 1778 3875 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 4021  5 other 1 4022  
1914 0 0 6 1779 3875 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 4021  
1915 0 0 6 1780 3875 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 4022  
1916 0 0 6 1781 3875 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 4022  9 tolerance 1 3723  
1917 0 0 6 1782 4022 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1918 0 0 7 1783 3888 0 0 0 0 
1919 0 0 7 1786 4024 3695 0 10 /**
 *
 */ 0 
1920 0 0 7 1786 4024 3695 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3977  
1921 0 0 7 1786 4024 3695 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3981  
1922 0 0 7 1786 4024 3695 0 10 /**
 *
 */ 1 1 c 1 4019  
1923 0 0 7 1786 4024 3695 0 0 1 6 param0 0 4025  
1924 0 0 7 1786 4024 3695 0 10 /**
 *
 */ 1 4 copy 1 3941  
1925 0 0 7 1786 4024 3695 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3923  5 angle 1 3720  
1926 0 0 7 1786 4024 3695 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3720  1 p 1 3720  1 r 1 3720  
1927 0 0 7 1786 4024 3695 0 10 /**
 *
 */ 4 1 r 1 3720  1 i 1 3720  1 j 1 3720  1 k 1 3720  
1928 0 0 7 1787 4018 3641 0 0 2 4 this 3 4025  5 other 1 4019  
1929 0 0 7 1787 4024 3695 0 0 2 4 this 3 4025  5 other 1 4025  
1930 0 0 7 1787 4024 3695 0 0 2 4 this 3 4025  6 scalar 1 3720  
1931 0 0 7 1788 4024 3695 0 0 2 4 this 3 4025  6 scalar 1 3720  
1932 0 0 7 1789 3888 0 0 0 0 
1933 0 0 7 1792 4027 3700 0 10 /**
 *
 */ 0 
1934 0 0 7 1792 4027 3700 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3998  
1935 0 0 7 1792 4027 3700 0 19 /**
 * lmatrix4
 */ 1 1 m 1 4002  
1936 0 0 7 1792 4027 3700 0 10 /**
 *
 */ 1 1 c 1 4022  
1937 0 0 7 1792 4027 3700 0 0 1 6 param0 0 4028  
1938 0 0 7 1792 4027 3700 0 10 /**
 *
 */ 1 4 copy 1 3947  
1939 0 0 7 1792 4027 3700 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3926  5 angle 1 3723  
1940 0 0 7 1792 4027 3700 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3723  1 p 1 3723  1 r 1 3723  
1941 0 0 7 1792 4027 3700 0 10 /**
 *
 */ 4 1 r 1 3723  1 i 1 3723  1 j 1 3723  1 k 1 3723  
1942 0 0 7 1793 4021 3690 0 0 2 4 this 3 4028  5 other 1 4022  
1943 0 0 7 1793 4027 3700 0 0 2 4 this 3 4028  5 other 1 4028  
1944 0 0 7 1793 4027 3700 0 0 2 4 this 3 4028  6 scalar 1 3723  
1945 0 0 7 1794 4027 3700 0 0 2 4 this 3 4028  6 scalar 1 3723  
1946 0 0 7 1795 3888 0 0 0 0 
1947 0 0 7 1798 4030 3704 0 10 /**
 *
 */ 0 
1948 0 0 7 1798 4030 3704 0 18 /**
 * matrix3
 */ 1 1 m 1 3977  
1949 0 0 7 1798 4030 3704 0 18 /**
 * matrix4
 */ 1 1 m 1 3981  
1950 0 0 7 1798 4030 3704 0 0 1 6 param0 0 4031  
1951 0 0 7 1798 4030 3704 0 10 /**
 *
 */ 1 1 c 1 4019  
1952 0 0 7 1798 4030 3704 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3923  5 twist 1 3720  
1953 0 0 7 1798 4030 3704 0 10 /**
 *
 */ 4 1 r 1 3720  1 i 1 3720  1 j 1 3720  1 k 1 3720  
1954 0 0 7 1799 4030 3704 0 0 2 4 this 3 4031  5 other 1 4019  
1955 0 0 7 1799 4030 3704 0 0 2 4 this 3 4031  5 other 1 4025  
1956 0 0 7 1800 3888 0 0 0 0 
1957 0 0 7 1803 4033 3708 0 10 /**
 *
 */ 0 
1958 0 0 7 1803 4033 3708 0 18 /**
 * matrix3
 */ 1 1 m 1 3998  
1959 0 0 7 1803 4033 3708 0 18 /**
 * matrix4
 */ 1 1 m 1 4002  
1960 0 0 7 1803 4033 3708 0 0 1 6 param0 0 4034  
1961 0 0 7 1803 4033 3708 0 10 /**
 *
 */ 1 1 c 1 4022  
1962 0 0 7 1803 4033 3708 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3926  5 twist 1 3723  
1963 0 0 7 1803 4033 3708 0 10 /**
 *
 */ 4 1 r 1 3723  1 i 1 3723  1 j 1 3723  1 k 1 3723  
1964 0 0 7 1804 4033 3708 0 0 2 4 this 3 4034  5 other 1 4022  
1965 0 0 7 1804 4033 3708 0 0 2 4 this 3 4034  5 other 1 4028  
1966 0 0 7 1805 3888 0 0 0 0 
1967 0 0 7 1879 4038 3716 0 0 1 6 param0 0 4036  
1968 0 0 7 1879 4038 3716 0 10 /**
 *
 */ 1 4 name 1 3874  
1969 0 0 7 1879 4038 3716 0 10 /**
 *
 */ 4 4 name 1 3874  13 default_value 1 4039  11 description 1 3874  5 flags 1 3726  
1970 0 0 7 1879 4038 3716 0 10 /**
 *
 */ 4 4 name 1 3874  13 default_value 1 3874  11 description 1 3874  5 flags 1 3726  
1971 0 0 6 1880 4038 0 0 0 2 4 this 3 4038  5 value 1 4039  
1972 0 0 6 1882 4041 0 0 0 2 4 this 3 4036  1 n 1 3726  
1973 0 0 4 1883 3870 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 4038  5 value 1 4039  
1974 0 0 6 1884 4039 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 4036  
1975 0 0 7 1885 4042 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 4036  
1976 0 0 6 1881 4039 0 0 0 1 4 this 3 4036  
1977 0 0 6 4 3723 0 0 0 1 1 f 1 3723  
1978 0 0 6 4 3720 0 0 0 1 1 f 1 3720  
1979 0 0 6 5 3723 0 0 0 1 1 f 1 3723  
1980 0 0 6 5 3720 0 0 0 1 1 f 1 3720  
1981 0 0 6 601 3739 0 0 0 0 
1982 0 0 6 602 3739 0 0 0 1 3 str 1 3874  
1983 0 0 6 603 3874 0 0 0 1 2 cs 1 3739  
1984 0 0 6 604 3875 0 0 0 1 2 cs 1 3739  
1985 0 0 7 1339 3997 3476 0 0 1 1 a 1 3998  
1986 0 0 7 1339 3976 3278 0 0 1 1 a 1 3977  
1987 0 0 7 1339 4008 3574 0 0 1 1 a 1 4002  
1988 0 0 7 1339 3987 3378 0 0 1 1 a 1 3981  
1989 0 0 7 1340 3997 3476 0 0 1 1 a 1 3998  
1990 0 0 7 1340 3976 3278 0 0 1 1 a 1 3977  
1991 0 0 7 1340 4008 3574 0 0 1 1 a 1 4002  
1992 0 0 7 1340 3987 3378 0 0 1 1 a 1 3981  
1993 0 0 7 1340 4021 3690 0 0 1 1 a 1 4022  
1994 0 0 7 1340 4018 3641 0 0 1 1 a 1 4019  
1995 0 0 7 1677 3997 3476 0 0 2 1 m 1 3998  1 q 1 4022  
1996 0 0 7 1677 3976 3278 0 0 2 1 m 1 3977  1 q 1 4019  
1997 0 0 7 1677 4008 3574 0 0 2 1 m 1 4002  1 q 1 4022  
1998 0 0 7 1677 3987 3378 0 0 2 1 m 1 3981  1 q 1 4019  
1999 0 0 7 1677 3907 2366 0 0 2 1 v 1 3908  1 m 1 3998  
2000 0 0 7 1677 3904 2349 0 0 2 1 v 1 3905  1 m 1 3977  
2001 0 0 7 1677 3934 2768 0 0 2 1 v 1 3935  1 m 1 3998  
2002 0 0 7 1677 3934 2768 0 0 2 1 v 1 3935  1 m 1 4002  
2003 0 0 7 1677 3931 2744 0 0 2 1 v 1 3932  1 m 1 3977  
2004 0 0 7 1677 3931 2744 0 0 2 1 v 1 3932  1 m 1 3981  
2005 0 0 7 1677 3970 3171 0 0 2 1 v 1 3971  1 m 1 4002  
2006 0 0 7 1677 3967 3150 0 0 2 1 v 1 3968  1 m 1 3981  
2007 0 0 7 1677 3916 2543 0 0 2 1 v 1 3917  1 m 1 3998  
2008 0 0 7 1677 3913 2462 0 0 2 1 v 1 3914  1 m 1 3977  
2009 0 0 7 1677 3946 2966 0 0 2 1 v 1 3947  1 m 1 4002  
2010 0 0 7 1677 3940 2872 0 0 2 1 v 1 3941  1 m 1 3981  
2011 0 0 7 1677 3898 2317 0 0 2 1 v 1 3899  1 m 1 3998  
2012 0 0 7 1677 3895 2298 0 0 2 1 v 1 3896  1 m 1 3977  
2013 0 0 7 1677 3925 2693 0 0 2 1 v 1 3926  1 m 1 3998  
2014 0 0 7 1677 3925 2693 0 0 2 1 v 1 3926  1 m 1 4002  
2015 0 0 7 1677 3922 2658 0 0 2 1 v 1 3923  1 m 1 3977  
2016 0 0 7 1677 3922 2658 0 0 2 1 v 1 3923  1 m 1 3981  
2017 0 0 7 1677 3961 3110 0 0 2 1 v 1 3962  1 m 1 4002  
2018 0 0 7 1677 3958 3089 0 0 2 1 v 1 3959  1 m 1 3981  
2019 0 0 4 1678 3870 0 0 0 2 1 v 1 3907  1 m 1 3998  
2020 0 0 4 1678 3870 0 0 0 2 1 v 1 3904  1 m 1 3977  
2021 0 0 4 1678 3870 0 0 0 2 1 v 1 3934  1 m 1 3998  
2022 0 0 4 1678 3870 0 0 0 2 1 v 1 3934  1 m 1 4002  
2023 0 0 4 1678 3870 0 0 0 2 1 v 1 3931  1 m 1 3977  
2024 0 0 4 1678 3870 0 0 0 2 1 v 1 3931  1 m 1 3981  
2025 0 0 4 1678 3870 0 0 0 2 1 v 1 3916  1 m 1 3998  
2026 0 0 4 1678 3870 0 0 0 2 1 v 1 3913  1 m 1 3977  
2027 0 0 4 1678 3870 0 0 0 2 1 v 1 3946  1 m 1 4002  
2028 0 0 4 1678 3870 0 0 0 2 1 v 1 3940  1 m 1 3981  
2029 0 0 4 1678 3870 0 0 0 2 1 v 1 3898  1 m 1 3998  
2030 0 0 4 1678 3870 0 0 0 2 1 v 1 3895  1 m 1 3977  
2031 0 0 4 1678 3870 0 0 0 2 1 v 1 3925  1 m 1 3998  
2032 0 0 4 1678 3870 0 0 0 2 1 v 1 3925  1 m 1 4002  
2033 0 0 4 1678 3870 0 0 0 2 1 v 1 3922  1 m 1 3977  
2034 0 0 4 1678 3870 0 0 0 2 1 v 1 3922  1 m 1 3981  
2035 0 0 4 1679 3870 0 0 0 2 4 dest 1 3880  5 value 1 3998  
2036 0 0 4 1679 3870 0 0 0 2 4 dest 1 3880  5 value 1 3977  
2037 0 0 4 1679 3870 0 0 0 2 4 dest 1 3880  5 value 1 4002  
2038 0 0 4 1679 3870 0 0 0 2 4 dest 1 3880  5 value 1 3981  
2039 0 0 4 1680 3870 0 0 0 2 6 result 1 3997  6 source 1 3882  
2040 0 0 4 1680 3870 0 0 0 2 6 result 1 3976  6 source 1 3882  
2041 0 0 4 1680 3870 0 0 0 2 6 result 1 4008  6 source 1 3882  
2042 0 0 4 1680 3870 0 0 0 2 6 result 1 3987  6 source 1 3882  
2043 0 0 4 1681 3870 0 0 0 4 3 mat 1 3997  5 scale 1 3917  3 hpr 1 3917  2 cs 1 3739  
2044 0 0 4 1681 3870 0 0 0 5 3 mat 1 3997  5 scale 1 3917  5 shear 1 3917  3 hpr 1 3917  2 cs 1 3739  
2045 0 0 4 1681 3870 0 0 0 4 3 mat 1 3976  5 scale 1 3914  3 hpr 1 3914  2 cs 1 3739  
2046 0 0 4 1681 3870 0 0 0 5 3 mat 1 3976  5 scale 1 3914  5 shear 1 3914  3 hpr 1 3914  2 cs 1 3739  
2047 0 0 4 1681 3870 0 0 0 5 3 mat 1 4008  5 scale 1 3917  3 hpr 1 3917  9 translate 1 3917  2 cs 1 3739  
2048 0 0 4 1681 3870 0 0 0 6 3 mat 1 4008  5 scale 1 3917  5 shear 1 3917  3 hpr 1 3917  9 translate 1 3917  2 cs 1 3739  
2049 0 0 4 1681 3870 0 0 0 3 3 mat 1 4008  10 components 1 4043  2 cs 1 3739  
2050 0 0 4 1681 3870 0 0 0 5 3 mat 1 3987  5 scale 1 3914  3 hpr 1 3914  9 translate 1 3914  2 cs 1 3739  
2051 0 0 4 1681 3870 0 0 0 6 3 mat 1 3987  5 scale 1 3914  5 shear 1 3914  3 hpr 1 3914  9 translate 1 3914  2 cs 1 3739  
2052 0 0 4 1681 3870 0 0 0 3 3 mat 1 3987  10 components 1 4045  2 cs 1 3739  
2053 0 0 6 1682 3875 0 0 0 4 3 mat 1 3998  5 scale 1 3916  3 hpr 1 3916  2 cs 1 3739  
2054 0 0 6 1682 3875 0 0 0 5 3 mat 1 3998  5 scale 1 3916  5 shear 1 3916  3 hpr 1 3916  2 cs 1 3739  
2055 0 0 6 1682 3875 0 0 0 4 3 mat 1 3977  5 scale 1 3913  3 hpr 1 3913  2 cs 1 3739  
2056 0 0 6 1682 3875 0 0 0 5 3 mat 1 3977  5 scale 1 3913  5 shear 1 3913  3 hpr 1 3913  2 cs 1 3739  
2057 0 0 6 1682 3875 0 0 0 5 3 mat 1 4002  5 scale 1 3916  3 hpr 1 3916  9 translate 1 3916  2 cs 1 3739  
2058 0 0 6 1682 3875 0 0 0 6 3 mat 1 4002  5 scale 1 3916  5 shear 1 3916  3 hpr 1 3916  9 translate 1 3916  2 cs 1 3739  
2059 0 0 6 1682 3875 0 0 0 3 3 mat 1 4002  10 components 1 4047  2 CS 1 3739  
2060 0 0 6 1682 3875 0 0 0 5 3 mat 1 3981  5 scale 1 3913  3 hpr 1 3913  9 translate 1 3913  2 cs 1 3739  
2061 0 0 6 1682 3875 0 0 0 6 3 mat 1 3981  5 scale 1 3913  5 shear 1 3913  3 hpr 1 3913  9 translate 1 3913  2 cs 1 3739  
2062 0 0 6 1682 3875 0 0 0 3 3 mat 1 3981  10 components 1 4048  2 CS 1 3739  
2063 0 0 6 1683 3875 0 0 0 5 3 mat 1 3998  5 scale 1 3916  5 shear 1 3916  3 hpr 1 3916  2 cs 1 3739  
2064 0 0 6 1683 3875 0 0 0 5 3 mat 1 3977  5 scale 1 3913  5 shear 1 3913  3 hpr 1 3913  2 cs 1 3739  
2065 0 0 7 1684 3916 2543 0 0 1 7 old_hpr 1 3917  
2066 0 0 7 1684 3913 2462 0 0 1 7 old_hpr 1 3914  
332
3717 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 2067 2068 0 0 0 0 0 0 0 0

3718 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 2071 2141 2 4049 4050 69 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 0 0 0 0 1 3719 75
/**
 * This is the base class for all two-component vectors and points.
 */

3719 0 0 794624 12 LVecBase2f:: 0 3718 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3720 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3721 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2142 2212 2 4051 4052 69 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 0 0 0 0 1 3722 75
/**
 * This is the base class for all two-component vectors and points.
 */

3722 0 0 794624 12 LVecBase2d:: 0 3721 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3723 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3724 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2213 2279 2 4053 4054 65 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 0 0 0 0 1 3725 75
/**
 * This is the base class for all two-component vectors and points.
 */

3725 0 0 794624 12 LVecBase2i:: 0 3724 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3726 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3727 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2280 2298 0 17 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 0 0 1 0 3718 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3728 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2299 2317 0 17 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 0 0 1 0 3721 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3729 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2318 2332 0 13 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 0 0 1 0 3724 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3730 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2333 2349 0 15 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 0 0 1 0 3718 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3731 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2350 2366 0 15 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 0 0 1 0 3721 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3732 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2367 2381 0 13 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 0 0 1 0 3724 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3733 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2382 2462 6 4055 4056 4057 4058 4059 4060 79 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 0 0 0 0 1 3734 77
/**
 * This is the base class for all three-component vectors and points.
 */

3734 0 0 794624 12 LVecBase3f:: 0 3733 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3735 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2463 2543 6 4061 4062 4063 4064 4065 4066 79 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 0 0 0 0 1 3736 77
/**
 * This is the base class for all three-component vectors and points.
 */

3736 0 0 794624 12 LVecBase3d:: 0 3735 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3737 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2544 2619 6 4067 4068 4069 4070 4071 4072 74 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 0 0 0 0 1 3738 77
/**
 * This is the base class for all three-component vectors and points.
 */

3738 0 0 794624 12 LVecBase3i:: 0 3737 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3739 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3740 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2624 2658 3 4073 4074 4075 33 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 0 0 1 0 3733 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3741 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2659 2693 3 4076 4077 4078 33 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 0 0 1 0 3735 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3742 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2694 2720 3 4079 4080 4081 25 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 0 0 1 0 3737 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3743 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2721 2744 3 4082 4083 4084 22 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 0 0 1 0 3733 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3744 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2745 2768 3 4085 4086 4087 22 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 0 0 1 0 3735 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3745 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2769 2790 3 4088 4089 4090 20 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 0 0 1 0 3737 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3746 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2791 2872 5 4091 4092 4093 4094 4095 80 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 0 0 0 0 1 3747 77
/**
 * This is the base class for all three-component vectors and points.
 */

3747 0 0 794624 12 LVecBase4f:: 0 3746 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3748 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2873 2884 0 10 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 0 0 0 0 1 3749 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3749 0 0 794624 21 UnalignedLVecBase4f:: 0 3748 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3750 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2885 2966 5 4096 4097 4098 4099 4100 80 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 0 0 0 0 1 3751 77
/**
 * This is the base class for all three-component vectors and points.
 */

3751 0 0 794624 12 LVecBase4d:: 0 3750 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3752 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2967 2978 0 10 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 0 0 0 0 1 3753 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3753 0 0 794624 21 UnalignedLVecBase4d:: 0 3752 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3754 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2979 3056 5 4101 4102 4103 4104 4105 76 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 0 0 0 0 1 3755 77
/**
 * This is the base class for all three-component vectors and points.
 */

3755 0 0 794624 12 LVecBase4i:: 0 3754 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3756 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 3057 3068 0 10 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 0 0 0 0 1 3757 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3757 0 0 794624 21 UnalignedLVecBase4i:: 0 3756 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3758 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 3069 3089 2 4106 4107 19 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 0 0 1 0 3746 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3759 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 3090 3110 2 4108 4109 19 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 0 0 1 0 3750 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3760 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 3111 3129 2 4110 4111 17 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 0 0 1 0 3754 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3761 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 3130 3150 2 4112 4113 19 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 0 0 1 0 3746 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3762 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 3151 3171 2 4114 4115 19 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 0 0 1 0 3750 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3763 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 3172 3190 2 4116 4117 17 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 0 0 1 0 3754 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3764 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3202 3278 2 4118 4119 75 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 4 4126 4127 4128 4129 0 0 0 3 3765 3766 3767 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3765 0 0 794624 11 LMatrix3f:: 0 3764 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3766 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3764 0 0 1 3195 3196 0 3 3191 3192 3193 0 1 3194 0 0 0 66
// These helper classes are used to support two-level operator [].

3767 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3764 0 0 1 3200 3201 0 2 3197 3198 0 1 3199 0 0 0 0

3768 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3292 3378 2 4120 4121 85 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3 4130 4131 4132 0 0 0 3 3769 3770 3771 45
/**
 * This is a 4-by-4 transform matrix.
 */

3769 0 0 794624 11 LMatrix4f:: 0 3768 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3770 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3768 0 0 1 3285 3286 0 3 3281 3282 3283 0 1 3284 0 0 0 66
// These helper classes are used to support two-level operator [].

3771 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3768 0 0 1 3290 3291 0 2 3287 3288 0 1 3289 0 0 0 0

3772 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3379 3388 0 8 3380 3381 3382 3383 3384 3385 3386 3387 0 0 0 0 1 3773 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3773 0 0 794624 20 UnalignedLMatrix4f:: 0 3772 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3774 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3400 3476 2 4122 4123 75 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 4 4133 4134 4135 4136 0 0 0 3 3775 3776 3777 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3775 0 0 794624 11 LMatrix3d:: 0 3774 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3776 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3774 0 0 1 3393 3394 0 3 3389 3390 3391 0 1 3392 0 0 0 66
// These helper classes are used to support two-level operator [].

3777 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3774 0 0 1 3398 3399 0 2 3395 3396 0 1 3397 0 0 0 0

3778 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3488 3574 2 4124 4125 85 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3 4137 4138 4139 0 0 0 3 3779 3780 3781 45
/**
 * This is a 4-by-4 transform matrix.
 */

3779 0 0 794624 11 LMatrix4d:: 0 3778 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3780 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3778 0 0 1 3481 3482 0 3 3477 3478 3479 0 1 3480 0 0 0 66
// These helper classes are used to support two-level operator [].

3781 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3778 0 0 1 3486 3487 0 2 3483 3484 0 1 3485 0 0 0 0

3782 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3575 3584 0 8 3576 3577 3578 3579 3580 3581 3582 3583 0 0 0 0 1 3783 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3783 0 0 794624 20 UnalignedLMatrix4d:: 0 3782 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3784 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3593 3641 0 47 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 0 0 1 0 3746 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3785 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3642 3690 0 47 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 0 0 1 0 3750 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3786 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3691 3695 0 3 3692 3693 3694 0 0 1 0 3784 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3787 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3696 3700 0 3 3697 3698 3699 0 0 1 0 3785 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3788 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3701 3704 0 2 3702 3703 0 0 1 0 3784 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3789 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3705 3708 0 2 3706 3707 0 0 1 0 3785 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3790 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3743 0 0 0 0 0 0 0 0 0 0

3791 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3740 0 0 0 0 0 0 0 0 0 0

3792 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3730 0 0 0 0 0 0 0 0 0 0

3793 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3743 0 0 0 0 0 0 0 0 0 0

3794 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3746 0 0 0 0 0 0 0 0 0 0

3795 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3733 0 0 0 0 0 0 0 0 0 0

3796 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3744 0 0 0 0 0 0 0 0 0 0

3797 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3741 0 0 0 0 0 0 0 0 0 0

3798 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3731 0 0 0 0 0 0 0 0 0 0

3799 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3744 0 0 0 0 0 0 0 0 0 0

3800 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3750 0 0 0 0 0 0 0 0 0 0

3801 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3735 0 0 0 0 0 0 0 0 0 0

3802 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3768 0 0 0 0 0 0 0 0 0 0

3803 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3764 0 0 0 0 0 0 0 0 0 0

3804 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3746 0 0 0 0 0 0 0 0 0 0

3805 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3758 0 0 0 0 0 0 0 0 0 0

3806 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3761 0 0 0 0 0 0 0 0 0 0

3807 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3733 0 0 0 0 0 0 0 0 0 0

3808 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3740 0 0 0 0 0 0 0 0 0 0

3809 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3743 0 0 0 0 0 0 0 0 0 0

3810 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3718 0 0 0 0 0 0 0 0 0 0

3811 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3727 0 0 0 0 0 0 0 0 0 0

3812 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3730 0 0 0 0 0 0 0 0 0 0

3813 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3784 0 0 0 0 0 0 0 0 0 0

3814 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3778 0 0 0 0 0 0 0 0 0 0

3815 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3774 0 0 0 0 0 0 0 0 0 0

3816 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3750 0 0 0 0 0 0 0 0 0 0

3817 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3759 0 0 0 0 0 0 0 0 0 0

3818 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3762 0 0 0 0 0 0 0 0 0 0

3819 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3735 0 0 0 0 0 0 0 0 0 0

3820 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3741 0 0 0 0 0 0 0 0 0 0

3821 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3744 0 0 0 0 0 0 0 0 0 0

3822 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3721 0 0 0 0 0 0 0 0 0 0

3823 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3728 0 0 0 0 0 0 0 0 0 0

3824 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3731 0 0 0 0 0 0 0 0 0 0

3825 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3785 0 0 0 0 0 0 0 0 0 0

3826 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3718 0 0 0 0 0 0 0 0 0 0

3827 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3730 0 0 0 0 0 0 0 0 0 0

3828 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3727 0 0 0 0 0 0 0 0 0 0

3829 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3733 0 0 0 0 0 0 0 0 0 0

3830 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3743 0 0 0 0 0 0 0 0 0 0

3831 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3740 0 0 0 0 0 0 0 0 0 0

3832 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3746 0 0 0 0 0 0 0 0 0 0

3833 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3761 0 0 0 0 0 0 0 0 0 0

3834 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3758 0 0 0 0 0 0 0 0 0 0

3835 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3784 0 0 0 0 0 0 0 0 0 0

3836 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3786 0 0 0 0 0 0 0 0 0 0

3837 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3788 0 0 0 0 0 0 0 0 0 0

3838 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3764 0 0 0 0 0 0 0 0 0 0

3839 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3768 0 0 0 0 0 0 0 0 0 0

3840 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3790 0 0 0 0 0 0 0 0 0 0

3841 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3791 0 0 0 0 0 0 0 0 0 0

3842 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3792 0 0 0 0 0 0 0 0 0 0

3843 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3793 0 0 0 0 0 0 0 0 0 0

3844 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3794 0 0 0 0 0 0 0 0 0 0

3845 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3795 0 0 0 0 0 0 0 0 0 0

3846 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3748 0 0 0 0 0 0 0 0 0 0

3847 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3772 0 0 0 0 0 0 0 0 0 0

3848 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3768 0 0 0 0 0 0 0 0 0 0

3849 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3764 0 0 0 0 0 0 0 0 0 0

3850 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3746 0 0 0 0 0 0 0 0 0 0

3851 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3758 0 0 0 0 0 0 0 0 0 0

3852 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3761 0 0 0 0 0 0 0 0 0 0

3853 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3733 0 0 0 0 0 0 0 0 0 0

3854 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3740 0 0 0 0 0 0 0 0 0 0

3855 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3743 0 0 0 0 0 0 0 0 0 0

3856 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3718 0 0 0 0 0 0 0 0 0 0

3857 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3727 0 0 0 0 0 0 0 0 0 0

3858 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3730 0 0 0 0 0 0 0 0 0 0

3859 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3784 0 0 0 0 0 0 0 0 0 0

3860 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3709 3716 0 5 3710 3712 3713 3714 3715 0 1 3711 1 0 3861 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3861 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3862 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3717 0 0 0 0 0 0 0 0 0 0

3863 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3864 0 0 0 0 0 0 0 0 0 0

3864 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3717 0 0 0 0 0 0 0 0 0 0

3865 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3718 0 0 0 0 0 0 0 0 0 0

3866 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3867 0 0 0 0 0 0 0 0 0 0

3867 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3718 0 0 0 0 0 0 0 0 0 0

3868 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3869 0 0 0 0 0 0 0 0 0 0

3869 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3870 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3871 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3872 0 0 0 0 0 0 0 0 0 0

3872 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3873 0 0 0 0 0 0 0 0 0 0

3873 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3874 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3875 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3876 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3877 0 0 0 0 0 0 0 0 0 0

3877 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3878 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3879 0 0 0 0 0 0 0 0 0 0

3879 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3880 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3881 0 0 0 0 0 0 0 0 0 0

3881 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3882 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3883 0 0 0 0 0 0 0 0 0 0

3883 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3884 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 3885 0 0 0 0 0 0 0 0 0 0

3885 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 3886 0 0 0 0 0 0 0 0 0 0

3886 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0

3887 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3888 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3887 0 0 0 0 0 0 0 0 0 0

3889 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3721 0 0 0 0 0 0 0 0 0 0

3890 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3891 0 0 0 0 0 0 0 0 0 0

3891 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3721 0 0 0 0 0 0 0 0 0 0

3892 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3724 0 0 0 0 0 0 0 0 0 0

3893 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3894 0 0 0 0 0 0 0 0 0 0

3894 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3724 0 0 0 0 0 0 0 0 0 0

3895 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3727 0 0 0 0 0 0 0 0 0 0

3896 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3897 0 0 0 0 0 0 0 0 0 0

3897 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3727 0 0 0 0 0 0 0 0 0 0

3898 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3728 0 0 0 0 0 0 0 0 0 0

3899 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3900 0 0 0 0 0 0 0 0 0 0

3900 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3728 0 0 0 0 0 0 0 0 0 0

3901 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3729 0 0 0 0 0 0 0 0 0 0

3902 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3903 0 0 0 0 0 0 0 0 0 0

3903 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3729 0 0 0 0 0 0 0 0 0 0

3904 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3730 0 0 0 0 0 0 0 0 0 0

3905 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3906 0 0 0 0 0 0 0 0 0 0

3906 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3730 0 0 0 0 0 0 0 0 0 0

3907 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3731 0 0 0 0 0 0 0 0 0 0

3908 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3909 0 0 0 0 0 0 0 0 0 0

3909 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3731 0 0 0 0 0 0 0 0 0 0

3910 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3732 0 0 0 0 0 0 0 0 0 0

3911 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3912 0 0 0 0 0 0 0 0 0 0

3912 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3732 0 0 0 0 0 0 0 0 0 0

3913 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3733 0 0 0 0 0 0 0 0 0 0

3914 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3915 0 0 0 0 0 0 0 0 0 0

3915 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3733 0 0 0 0 0 0 0 0 0 0

3916 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3735 0 0 0 0 0 0 0 0 0 0

3917 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3918 0 0 0 0 0 0 0 0 0 0

3918 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3735 0 0 0 0 0 0 0 0 0 0

3919 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3737 0 0 0 0 0 0 0 0 0 0

3920 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3921 0 0 0 0 0 0 0 0 0 0

3921 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3737 0 0 0 0 0 0 0 0 0 0

3922 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3740 0 0 0 0 0 0 0 0 0 0

3923 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3924 0 0 0 0 0 0 0 0 0 0

3924 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3740 0 0 0 0 0 0 0 0 0 0

3925 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3741 0 0 0 0 0 0 0 0 0 0

3926 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3927 0 0 0 0 0 0 0 0 0 0

3927 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3741 0 0 0 0 0 0 0 0 0 0

3928 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3742 0 0 0 0 0 0 0 0 0 0

3929 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3930 0 0 0 0 0 0 0 0 0 0

3930 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3742 0 0 0 0 0 0 0 0 0 0

3931 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3743 0 0 0 0 0 0 0 0 0 0

3932 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3933 0 0 0 0 0 0 0 0 0 0

3933 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3743 0 0 0 0 0 0 0 0 0 0

3934 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3744 0 0 0 0 0 0 0 0 0 0

3935 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3936 0 0 0 0 0 0 0 0 0 0

3936 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3744 0 0 0 0 0 0 0 0 0 0

3937 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3745 0 0 0 0 0 0 0 0 0 0

3938 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3939 0 0 0 0 0 0 0 0 0 0

3939 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3745 0 0 0 0 0 0 0 0 0 0

3940 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3746 0 0 0 0 0 0 0 0 0 0

3941 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3942 0 0 0 0 0 0 0 0 0 0

3942 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3746 0 0 0 0 0 0 0 0 0 0

3943 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3944 0 0 0 0 0 0 0 0 0 0

3944 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3748 0 0 0 0 0 0 0 0 0 0

3945 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3748 0 0 0 0 0 0 0 0 0 0

3946 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3750 0 0 0 0 0 0 0 0 0 0

3947 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3948 0 0 0 0 0 0 0 0 0 0

3948 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3750 0 0 0 0 0 0 0 0 0 0

3949 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3950 0 0 0 0 0 0 0 0 0 0

3950 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3752 0 0 0 0 0 0 0 0 0 0

3951 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3752 0 0 0 0 0 0 0 0 0 0

3952 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3754 0 0 0 0 0 0 0 0 0 0

3953 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3954 0 0 0 0 0 0 0 0 0 0

3954 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3754 0 0 0 0 0 0 0 0 0 0

3955 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3956 0 0 0 0 0 0 0 0 0 0

3956 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3756 0 0 0 0 0 0 0 0 0 0

3957 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3756 0 0 0 0 0 0 0 0 0 0

3958 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3758 0 0 0 0 0 0 0 0 0 0

3959 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3960 0 0 0 0 0 0 0 0 0 0

3960 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3758 0 0 0 0 0 0 0 0 0 0

3961 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3759 0 0 0 0 0 0 0 0 0 0

3962 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3963 0 0 0 0 0 0 0 0 0 0

3963 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3759 0 0 0 0 0 0 0 0 0 0

3964 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3760 0 0 0 0 0 0 0 0 0 0

3965 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3966 0 0 0 0 0 0 0 0 0 0

3966 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3760 0 0 0 0 0 0 0 0 0 0

3967 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3761 0 0 0 0 0 0 0 0 0 0

3968 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3969 0 0 0 0 0 0 0 0 0 0

3969 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3761 0 0 0 0 0 0 0 0 0 0

3970 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3762 0 0 0 0 0 0 0 0 0 0

3971 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3972 0 0 0 0 0 0 0 0 0 0

3972 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3762 0 0 0 0 0 0 0 0 0 0

3973 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3763 0 0 0 0 0 0 0 0 0 0

3974 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3975 0 0 0 0 0 0 0 0 0 0

3975 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3763 0 0 0 0 0 0 0 0 0 0

3976 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3764 0 0 0 0 0 0 0 0 0 0

3977 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3978 0 0 0 0 0 0 0 0 0 0

3978 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3764 0 0 0 0 0 0 0 0 0 0

3979 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3766 0 0 0 0 0 0 0 0 0 0

3980 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3767 0 0 0 0 0 0 0 0 0 0

3981 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3982 0 0 0 0 0 0 0 0 0 0

3982 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3768 0 0 0 0 0 0 0 0 0 0

3983 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3984 0 0 0 0 0 0 0 0 0 0

3984 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3766 0 0 0 0 0 0 0 0 0 0

3985 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3986 0 0 0 0 0 0 0 0 0 0

3986 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3767 0 0 0 0 0 0 0 0 0 0

3987 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3768 0 0 0 0 0 0 0 0 0 0

3988 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3989 0 0 0 0 0 0 0 0 0 0

3989 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3772 0 0 0 0 0 0 0 0 0 0

3990 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3770 0 0 0 0 0 0 0 0 0 0

3991 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3771 0 0 0 0 0 0 0 0 0 0

3992 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3993 0 0 0 0 0 0 0 0 0 0

3993 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3770 0 0 0 0 0 0 0 0 0 0

3994 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3995 0 0 0 0 0 0 0 0 0 0

3995 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3771 0 0 0 0 0 0 0 0 0 0

3996 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3772 0 0 0 0 0 0 0 0 0 0

3997 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3774 0 0 0 0 0 0 0 0 0 0

3998 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3999 0 0 0 0 0 0 0 0 0 0

3999 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3774 0 0 0 0 0 0 0 0 0 0

4000 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3776 0 0 0 0 0 0 0 0 0 0

4001 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3777 0 0 0 0 0 0 0 0 0 0

4002 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 4003 0 0 0 0 0 0 0 0 0 0

4003 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3778 0 0 0 0 0 0 0 0 0 0

4004 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 4005 0 0 0 0 0 0 0 0 0 0

4005 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3776 0 0 0 0 0 0 0 0 0 0

4006 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 4007 0 0 0 0 0 0 0 0 0 0

4007 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3777 0 0 0 0 0 0 0 0 0 0

4008 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3778 0 0 0 0 0 0 0 0 0 0

4009 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 4010 0 0 0 0 0 0 0 0 0 0

4010 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3782 0 0 0 0 0 0 0 0 0 0

4011 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3780 0 0 0 0 0 0 0 0 0 0

4012 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3781 0 0 0 0 0 0 0 0 0 0

4013 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 4014 0 0 0 0 0 0 0 0 0 0

4014 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3780 0 0 0 0 0 0 0 0 0 0

4015 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 4016 0 0 0 0 0 0 0 0 0 0

4016 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3781 0 0 0 0 0 0 0 0 0 0

4017 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3782 0 0 0 0 0 0 0 0 0 0

4018 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3784 0 0 0 0 0 0 0 0 0 0

4019 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 4020 0 0 0 0 0 0 0 0 0 0

4020 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3784 0 0 0 0 0 0 0 0 0 0

4021 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3785 0 0 0 0 0 0 0 0 0 0

4022 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 4023 0 0 0 0 0 0 0 0 0 0

4023 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3785 0 0 0 0 0 0 0 0 0 0

4024 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3786 0 0 0 0 0 0 0 0 0 0

4025 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 4026 0 0 0 0 0 0 0 0 0 0

4026 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3786 0 0 0 0 0 0 0 0 0 0

4027 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3787 0 0 0 0 0 0 0 0 0 0

4028 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 4029 0 0 0 0 0 0 0 0 0 0

4029 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3787 0 0 0 0 0 0 0 0 0 0

4030 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3788 0 0 0 0 0 0 0 0 0 0

4031 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 4032 0 0 0 0 0 0 0 0 0 0

4032 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3788 0 0 0 0 0 0 0 0 0 0

4033 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3789 0 0 0 0 0 0 0 0 0 0

4034 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 4035 0 0 0 0 0 0 0 0 0 0

4035 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3789 0 0 0 0 0 0 0 0 0 0

4036 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 4037 0 0 0 0 0 0 0 0 0 0

4037 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3860 0 0 0 0 0 0 0 0 0 0

4038 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3860 0 0 0 0 0 0 0 0 0 0

4039 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 4040 0 0 0 0 0 0 0 0 0 0

4040 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3844 0 0 0 0 0 0 0 0 0 0

4041 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3720 0 0 0 0 0 0 0 0 0 0

4042 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3844 0 0 0 0 0 0 0 0 0 0

4043 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 4044 12 0 0 0 0 0 0 0 0 0 0

4044 12 double const 0 8832 12 double const 12 double const 0 0 3723 0 0 0 0 0 0 0 0 0 0

4045 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 4046 12 0 0 0 0 0 0 0 0 0 0

4046 11 float const 0 8832 11 float const 11 float const 0 0 3720 0 0 0 0 0 0 0 0 0 0

4047 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3723 12 0 0 0 0 0 0 0 0 0 0

4048 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3720 12 0 0 0 0 0 0 0 0 0 0

0
77
4049 1 x 0 6 3720 2088 2090 0 0 0 0 0 0 13 LVecBase2f::x 0

4050 1 y 0 6 3720 2089 2091 0 0 0 0 0 0 13 LVecBase2f::y 0

4051 1 x 0 6 3723 2159 2161 0 0 0 0 0 0 13 LVecBase2d::x 0

4052 1 y 0 6 3723 2160 2162 0 0 0 0 0 0 13 LVecBase2d::y 0

4053 1 x 0 6 3726 2230 2232 0 0 0 0 0 0 13 LVecBase2i::x 0

4054 1 y 0 6 3726 2231 2233 0 0 0 0 0 0 13 LVecBase2i::y 0

4055 1 x 0 6 3720 2399 2403 0 0 0 0 0 0 13 LVecBase3f::x 0

4056 1 y 0 6 3720 2400 2404 0 0 0 0 0 0 13 LVecBase3f::y 0

4057 1 z 0 6 3720 2401 2405 0 0 0 0 0 0 13 LVecBase3f::z 0

4058 2 xy 0 2 3718 2406 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

4059 2 xz 0 2 3718 2407 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

4060 2 yz 0 2 3718 2408 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

4061 1 x 0 6 3723 2480 2484 0 0 0 0 0 0 13 LVecBase3d::x 0

4062 1 y 0 6 3723 2481 2485 0 0 0 0 0 0 13 LVecBase3d::y 0

4063 1 z 0 6 3723 2482 2486 0 0 0 0 0 0 13 LVecBase3d::z 0

4064 2 xy 0 2 3721 2487 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

4065 2 xz 0 2 3721 2488 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

4066 2 yz 0 2 3721 2489 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

4067 1 x 0 6 3726 2561 2565 0 0 0 0 0 0 13 LVecBase3i::x 0

4068 1 y 0 6 3726 2562 2566 0 0 0 0 0 0 13 LVecBase3i::y 0

4069 1 z 0 6 3726 2563 2567 0 0 0 0 0 0 13 LVecBase3i::z 0

4070 2 xy 0 2 3724 2568 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

4071 2 xz 0 2 3724 2569 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

4072 2 yz 0 2 3724 2570 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

4073 2 xy 0 2 3727 2631 0 0 0 0 0 0 0 13 LVector3f::xy 0

4074 2 xz 0 2 3727 2632 0 0 0 0 0 0 0 13 LVector3f::xz 0

4075 2 yz 0 2 3727 2633 0 0 0 0 0 0 0 13 LVector3f::yz 0

4076 2 xy 0 2 3728 2666 0 0 0 0 0 0 0 13 LVector3d::xy 0

4077 2 xz 0 2 3728 2667 0 0 0 0 0 0 0 13 LVector3d::xz 0

4078 2 yz 0 2 3728 2668 0 0 0 0 0 0 0 13 LVector3d::yz 0

4079 2 xy 0 2 3729 2701 0 0 0 0 0 0 0 13 LVector3i::xy 0

4080 2 xz 0 2 3729 2702 0 0 0 0 0 0 0 13 LVector3i::xz 0

4081 2 yz 0 2 3729 2703 0 0 0 0 0 0 0 13 LVector3i::yz 0

4082 2 xy 0 2 3730 2728 0 0 0 0 0 0 0 12 LPoint3f::xy 0

4083 2 xz 0 2 3730 2729 0 0 0 0 0 0 0 12 LPoint3f::xz 0

4084 2 yz 0 2 3730 2730 0 0 0 0 0 0 0 12 LPoint3f::yz 0

4085 2 xy 0 2 3731 2752 0 0 0 0 0 0 0 12 LPoint3d::xy 0

4086 2 xz 0 2 3731 2753 0 0 0 0 0 0 0 12 LPoint3d::xz 0

4087 2 yz 0 2 3731 2754 0 0 0 0 0 0 0 12 LPoint3d::yz 0

4088 2 xy 0 2 3732 2776 0 0 0 0 0 0 0 12 LPoint3i::xy 0

4089 2 xz 0 2 3732 2777 0 0 0 0 0 0 0 12 LPoint3i::xz 0

4090 2 yz 0 2 3732 2778 0 0 0 0 0 0 0 12 LPoint3i::yz 0

4091 1 x 0 6 3720 2810 2816 0 0 0 0 0 0 13 LVecBase4f::x 0

4092 1 y 0 6 3720 2811 2817 0 0 0 0 0 0 13 LVecBase4f::y 0

4093 1 z 0 6 3720 2812 2818 0 0 0 0 0 0 13 LVecBase4f::z 0

4094 3 xyz 0 2 3733 2814 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

4095 2 xy 0 2 3718 2815 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

4096 1 x 0 6 3723 2904 2910 0 0 0 0 0 0 13 LVecBase4d::x 0

4097 1 y 0 6 3723 2905 2911 0 0 0 0 0 0 13 LVecBase4d::y 0

4098 1 z 0 6 3723 2906 2912 0 0 0 0 0 0 13 LVecBase4d::z 0

4099 3 xyz 0 2 3735 2908 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

4100 2 xy 0 2 3721 2909 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

4101 1 x 0 6 3726 2998 3004 0 0 0 0 0 0 13 LVecBase4i::x 0

4102 1 y 0 6 3726 2999 3005 0 0 0 0 0 0 13 LVecBase4i::y 0

4103 1 z 0 6 3726 3000 3006 0 0 0 0 0 0 13 LVecBase4i::z 0

4104 3 xyz 0 2 3737 3002 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

4105 2 xy 0 2 3724 3003 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

4106 3 xyz 0 2 3740 3077 0 0 0 0 0 0 0 14 LVector4f::xyz 0

4107 2 xy 0 2 3727 3078 0 0 0 0 0 0 0 13 LVector4f::xy 0

4108 3 xyz 0 2 3741 3098 0 0 0 0 0 0 0 14 LVector4d::xyz 0

4109 2 xy 0 2 3728 3099 0 0 0 0 0 0 0 13 LVector4d::xy 0

4110 3 xyz 0 2 3742 3119 0 0 0 0 0 0 0 14 LVector4i::xyz 0

4111 2 xy 0 2 3729 3120 0 0 0 0 0 0 0 13 LVector4i::xy 0

4112 3 xyz 0 2 3743 3138 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

4113 2 xy 0 2 3730 3139 0 0 0 0 0 0 0 12 LPoint4f::xy 0

4114 3 xyz 0 2 3744 3159 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

4115 2 xy 0 2 3731 3160 0 0 0 0 0 0 0 12 LPoint4d::xy 0

4116 3 xyz 0 2 3745 3180 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

4117 2 xy 0 2 3732 3181 0 0 0 0 0 0 0 12 LPoint4i::xy 0

4118 4 rows 0 66 3733 3214 0 0 0 0 3211 0 0 15 LMatrix3f::rows 0

4119 4 cols 0 66 3733 3215 0 0 0 0 3211 0 0 15 LMatrix3f::cols 0

4120 4 rows 0 66 3746 3306 0 0 0 0 3303 0 0 15 LMatrix4f::rows 0

4121 4 cols 0 66 3746 3307 0 0 0 0 3303 0 0 15 LMatrix4f::cols 0

4122 4 rows 0 66 3735 3412 0 0 0 0 3409 0 0 15 LMatrix3d::rows 0

4123 4 cols 0 66 3735 3413 0 0 0 0 3409 0 0 15 LMatrix3d::cols 0

4124 4 rows 0 66 3750 3502 0 0 0 0 3499 0 0 15 LMatrix4d::rows 0

4125 4 cols 0 66 3750 3503 0 0 0 0 3499 0 0 15 LMatrix4d::cols 0

14
4126 8 get_rows 0 3211 3214 19 LMatrix3f::get_rows 0

4127 8 get_cols 0 3211 3215 19 LMatrix3f::get_cols 0

4128 9 get_col2s 0 3211 3217 20 LMatrix3f::get_col2s 0

4129 9 get_row2s 0 3211 3216 20 LMatrix3f::get_row2s 0

4130 8 get_rows 0 3303 3306 19 LMatrix4f::get_rows 0

4131 8 get_cols 0 3303 3307 19 LMatrix4f::get_cols 0

4132 9 get_row3s 0 3303 3308 20 LMatrix4f::get_row3s 0

4133 8 get_rows 0 3409 3412 19 LMatrix3d::get_rows 0

4134 8 get_cols 0 3409 3413 19 LMatrix3d::get_cols 0

4135 9 get_col2s 0 3409 3415 20 LMatrix3d::get_col2s 0

4136 9 get_row2s 0 3409 3414 20 LMatrix3d::get_row2s 0

4137 8 get_rows 0 3499 3502 19 LMatrix4d::get_rows 0

4138 8 get_cols 0 3499 3503 19 LMatrix4d::get_cols 0

4139 9 get_row3s 0 3499 3504 20 LMatrix4d::get_row3s 0

