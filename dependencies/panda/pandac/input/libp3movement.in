1641927158
3 3
13 libp3movement 4 Nf1f 11 panda3d.otp 
33
37 8 CImpulse 0 4 70 18 CImpulse::CImpulse 0 2 1 2 217
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
80
CImpulse::CImpulse(void);
inline CImpulse::CImpulse(CImpulse const &) = default;

38 7 process 0 6 70 17 CImpulse::process 0 1 3 313
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::process
//       Access: Public, Virtual
//  Description: override this and set your impulse's influence for
//               this pass on its mover
////////////////////////////////////////////////////////////////////
41
virtual void CImpulse::process(float dt);

39 9 set_mover 0 6 70 19 CImpulse::set_mover 0 1 4 269
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::set_mover
//       Access: Public, Virtual
//  Description: called internally by cMover when we're added
////////////////////////////////////////////////////////////////////
48
virtual void CImpulse::set_mover(CMover &mover);

40 11 clear_mover 0 6 70 21 CImpulse::clear_mover 0 1 5 273
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::clear_mover
//       Access: Public, Virtual
//  Description: called internally by cMover when we're removed
////////////////////////////////////////////////////////////////////
50
virtual void CImpulse::clear_mover(CMover &mover);

41 9 get_mover 0 4 70 19 CImpulse::get_mover 0 1 6 298
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::get_mover
//       Access: Published
//  Description: Returns pointer to mover obj that we're attached to;
//               may be 0.
////////////////////////////////////////////////////////////////////
47
inline CMover *CImpulse::get_mover(void) const;

42 13 get_node_path 0 4 70 23 CImpulse::get_node_path 0 1 7 272
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::get_node_path
//       Access: Published
//  Description: Returns NodePath that our mover is moving around.
////////////////////////////////////////////////////////////////////
52
inline NodePath CImpulse::get_node_path(void) const;

43 6 is_cpp 0 4 70 16 CImpulse::is_cpp 0 1 8 381
////////////////////////////////////////////////////////////////////
//     Function: CImpulse::is_cpp
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
////////////////////////////////////////////////////////////////////
41
inline bool CImpulse::is_cpp(void) const;

44 14 get_class_type 0 4 70 24 CImpulse::get_class_type 0 1 9 0
49
static TypeHandle CImpulse::get_class_type(void);

45 6 CMover 0 4 72 14 CMover::CMover 0 2 10 11 0
129
CMover::CMover(NodePath &objNodePath, float fwd_speed = 1, float rot_speed = 1);
inline CMover::CMover(CMover const &) = default;

46 13 set_fwd_speed 0 4 72 21 CMover::set_fwd_speed 0 1 12 297
////////////////////////////////////////////////////////////////////
//     Function: CMover::set_fwd_speed
//       Access: Published
//  Description: Sets the speed that impulses should use when moving
//               forward
////////////////////////////////////////////////////////////////////
51
inline void CMover::set_fwd_speed(float fwd_speed);

47 13 set_rot_speed 0 4 72 21 CMover::set_rot_speed 0 1 13 274
////////////////////////////////////////////////////////////////////
//     Function: CMover::set_rot_speed
//       Access: Published
//  Description: Sets the speed that impulses should use when rotating
////////////////////////////////////////////////////////////////////
51
inline void CMover::set_rot_speed(float rot_speed);

48 13 get_fwd_speed 0 4 72 21 CMover::get_fwd_speed 0 1 14 300
////////////////////////////////////////////////////////////////////
//     Function: CMover::get_fwd_speed
//       Access: Published
//  Description: Returns the speed that impulses should use when moving
//               forward
////////////////////////////////////////////////////////////////////
47
inline float CMover::get_fwd_speed(void) const;

49 13 get_rot_speed 0 4 72 21 CMover::get_rot_speed 0 1 15 277
////////////////////////////////////////////////////////////////////
//     Function: CMover::get_rot_speed
//       Access: Published
//  Description: Returns the speed that impulses should use when rotating
////////////////////////////////////////////////////////////////////
47
inline float CMover::get_rot_speed(void) const;

50 13 add_c_impulse 0 4 72 21 CMover::add_c_impulse 0 1 16 0
71
void CMover::add_c_impulse(std::string const &name, CImpulse *impulse);

51 16 remove_c_impulse 0 4 72 24 CMover::remove_c_impulse 0 1 17 0
55
bool CMover::remove_c_impulse(std::string const &name);

52 18 process_c_impulses 0 4 72 26 CMover::process_c_impulses 0 1 18 0
47
void CMover::process_c_impulses(float dt = -1);

53 9 integrate 0 4 72 17 CMover::integrate 0 1 19 0
29
void CMover::integrate(void);

54 9 add_force 0 4 72 17 CMover::add_force 0 1 20 257
////////////////////////////////////////////////////////////////////
//     Function: CMover::add_force
//       Access: Published
//  Description: Called by impulses during CMover::move()
////////////////////////////////////////////////////////////////////
54
inline void CMover::add_force(LVector3f const &force);

55 13 add_rot_force 0 4 72 21 CMover::add_rot_force 0 1 21 261
////////////////////////////////////////////////////////////////////
//     Function: CMover::add_rot_force
//       Access: Published
//  Description: Called by impulses during CMover::move()
////////////////////////////////////////////////////////////////////
62
inline void CMover::add_rot_force(LVector3f const &rot_force);

56 9 add_shove 0 4 72 17 CMover::add_shove 0 1 22 257
////////////////////////////////////////////////////////////////////
//     Function: CMover::add_shove
//       Access: Published
//  Description: Called by impulses during CMover::move()
////////////////////////////////////////////////////////////////////
54
inline void CMover::add_shove(LVector3f const &shove);

57 13 add_rot_shove 0 4 72 21 CMover::add_rot_shove 0 1 23 261
////////////////////////////////////////////////////////////////////
//     Function: CMover::add_rot_shove
//       Access: Published
//  Description: Called by impulses during CMover::move()
////////////////////////////////////////////////////////////////////
62
inline void CMover::add_rot_shove(LVector3f const &rot_shove);

58 13 get_node_path 0 4 72 21 CMover::get_node_path 0 1 24 263
////////////////////////////////////////////////////////////////////
//     Function: CMover::get_node_path
//       Access: Published
//  Description: Returns nodepath being moved by this mover
////////////////////////////////////////////////////////////////////
50
inline NodePath CMover::get_node_path(void) const;

59 6 get_dt 0 4 72 14 CMover::get_dt 0 1 25 249
////////////////////////////////////////////////////////////////////
//     Function: CMover::get_dt
//       Access: Published
//  Description: Returns dt from last call to move()
////////////////////////////////////////////////////////////////////
40
inline float CMover::get_dt(void) const;

60 8 reset_dt 0 4 72 16 CMover::reset_dt 0 1 26 438
////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::reset_dt
//       Access: Published
//  Description: ignores time elapsed since last set_dt, call if
//               mover group has not been moved in a long time
//               and you don't want objects to move as if they
//               were moving the whole time
////////////////////////////////////////////////////////////////////
35
inline void CMover::reset_dt(void);

61 14 get_class_type 0 4 72 22 CMover::get_class_type 0 1 27 0
47
static TypeHandle CMover::get_class_type(void);

62 11 CMoverGroup 0 4 73 24 CMoverGroup::CMoverGroup 0 2 28 29 0
95
CMoverGroup::CMoverGroup(void);
inline CMoverGroup::CMoverGroup(CMoverGroup const &) = default;

63 11 add_c_mover 0 4 73 24 CMoverGroup::add_c_mover 0 1 30 0
70
void CMoverGroup::add_c_mover(std::string const &name, CMover *mover);

64 14 remove_c_mover 0 4 73 27 CMoverGroup::remove_c_mover 0 1 31 0
58
bool CMoverGroup::remove_c_mover(std::string const &name);

65 6 set_dt 0 4 73 19 CMoverGroup::set_dt 0 1 32 318
////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::set_dt
//       Access: Published
//  Description: sets dt for current frame, calculates if -1 is passed
//               returns dt for current frame
////////////////////////////////////////////////////////////////////
48
inline float CMoverGroup::set_dt(float dt = -1);

66 6 get_dt 0 4 73 19 CMoverGroup::get_dt 0 1 33 254
////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::get_dt
//       Access: Published
//  Description: Returns dt from last call to set_dt
////////////////////////////////////////////////////////////////////
45
inline float CMoverGroup::get_dt(void) const;

67 8 reset_dt 0 4 73 21 CMoverGroup::reset_dt 0 1 34 438
////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::reset_dt
//       Access: Published
//  Description: ignores time elapsed since last set_dt, call if
//               mover group has not been moved in a long time
//               and you don't want objects to move as if they
//               were moving the whole time
////////////////////////////////////////////////////////////////////
40
inline void CMoverGroup::reset_dt(void);

68 32 process_c_impulses_and_integrate 0 4 73 45 CMoverGroup::process_c_impulses_and_integrate 0 1 35 59
// processes C++ impulses and integrates; call set_dt first
57
void CMoverGroup::process_c_impulses_and_integrate(void);

69 14 get_class_type 0 4 73 27 CMoverGroup::get_class_type 0 1 36 0
52
static TypeHandle CMoverGroup::get_class_type(void);

36
1 0 0 7 3 74 0 0 217 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
2 0 0 7 3 74 0 0 0 1 6 param0 0 75  
3 0 0 4 4 78 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::process
//       Access: Public, Virtual
//  Description: override this and set your impulse's influence for
//               this pass on its mover
//////////////////////////////////////////////////////////////////// 2 4 this 3 74  2 dt 1 77  
4 0 0 4 5 78 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::set_mover
//       Access: Public, Virtual
//  Description: called internally by cMover when we're added
//////////////////////////////////////////////////////////////////// 2 4 this 3 74  5 mover 1 79  
5 0 0 4 6 78 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::clear_mover
//       Access: Public, Virtual
//  Description: called internally by cMover when we're removed
//////////////////////////////////////////////////////////////////// 2 4 this 3 74  5 mover 1 79  
6 0 0 7 7 79 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::get_mover
//       Access: Published
//  Description: Returns pointer to mover obj that we're attached to;
//               may be 0.
//////////////////////////////////////////////////////////////////// 1 4 this 3 75  
7 0 0 7 8 81 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::get_node_path
//       Access: Published
//  Description: Returns NodePath that our mover is moving around.
//////////////////////////////////////////////////////////////////// 1 4 this 3 75  
8 0 0 6 9 82 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: CImpulse::is_cpp
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
//////////////////////////////////////////////////////////////////// 1 4 this 3 75  
9 0 0 7 10 84 0 0 0 0 
10 0 0 7 12 79 0 0 0 1 6 param0 0 85  
11 0 0 7 12 79 0 0 0 3 11 objNodePath 1 81  9 fwd_speed 1 77  9 rot_speed 1 77  
12 0 0 4 13 78 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: CMover::set_fwd_speed
//       Access: Published
//  Description: Sets the speed that impulses should use when moving
//               forward
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  9 fwd_speed 1 77  
13 0 0 4 14 78 0 0 274 ////////////////////////////////////////////////////////////////////
//     Function: CMover::set_rot_speed
//       Access: Published
//  Description: Sets the speed that impulses should use when rotating
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  9 rot_speed 1 77  
14 0 0 6 15 77 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: CMover::get_fwd_speed
//       Access: Published
//  Description: Returns the speed that impulses should use when moving
//               forward
//////////////////////////////////////////////////////////////////// 1 4 this 3 85  
15 0 0 6 16 77 0 0 277 ////////////////////////////////////////////////////////////////////
//     Function: CMover::get_rot_speed
//       Access: Published
//  Description: Returns the speed that impulses should use when rotating
//////////////////////////////////////////////////////////////////// 1 4 this 3 85  
16 0 0 4 17 78 0 0 0 3 4 this 3 79  4 name 1 87  7 impulse 1 74  
17 0 0 6 18 82 0 0 0 2 4 this 3 79  4 name 1 87  
18 0 0 4 19 78 0 0 0 2 4 this 3 79  2 dt 1 77  
19 0 0 4 20 78 0 0 0 1 4 this 3 79  
20 0 0 4 21 78 0 0 257 ////////////////////////////////////////////////////////////////////
//     Function: CMover::add_force
//       Access: Published
//  Description: Called by impulses during CMover::move()
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  5 force 1 88  
21 0 0 4 22 78 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: CMover::add_rot_force
//       Access: Published
//  Description: Called by impulses during CMover::move()
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  9 rot_force 1 88  
22 0 0 4 23 78 0 0 257 ////////////////////////////////////////////////////////////////////
//     Function: CMover::add_shove
//       Access: Published
//  Description: Called by impulses during CMover::move()
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  5 shove 1 88  
23 0 0 4 24 78 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: CMover::add_rot_shove
//       Access: Published
//  Description: Called by impulses during CMover::move()
//////////////////////////////////////////////////////////////////// 2 4 this 3 79  9 rot_shove 1 88  
24 0 0 7 25 81 0 0 263 ////////////////////////////////////////////////////////////////////
//     Function: CMover::get_node_path
//       Access: Published
//  Description: Returns nodepath being moved by this mover
//////////////////////////////////////////////////////////////////// 1 4 this 3 85  
25 0 0 6 26 77 0 0 249 ////////////////////////////////////////////////////////////////////
//     Function: CMover::get_dt
//       Access: Published
//  Description: Returns dt from last call to move()
//////////////////////////////////////////////////////////////////// 1 4 this 3 85  
26 0 0 4 27 78 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::reset_dt
//       Access: Published
//  Description: ignores time elapsed since last set_dt, call if
//               mover group has not been moved in a long time
//               and you don't want objects to move as if they
//               were moving the whole time
//////////////////////////////////////////////////////////////////// 1 4 this 3 79  
27 0 0 7 28 84 0 0 0 0 
28 0 0 7 30 91 0 0 0 0 
29 0 0 7 30 91 0 0 0 1 6 param0 0 92  
30 0 0 4 31 78 0 0 0 3 4 this 3 91  4 name 1 87  5 mover 1 79  
31 0 0 6 32 82 0 0 0 2 4 this 3 91  4 name 1 87  
32 0 0 6 33 77 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::set_dt
//       Access: Published
//  Description: sets dt for current frame, calculates if -1 is passed
//               returns dt for current frame
//////////////////////////////////////////////////////////////////// 2 4 this 3 91  2 dt 1 77  
33 0 0 6 34 77 0 0 254 ////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::get_dt
//       Access: Published
//  Description: Returns dt from last call to set_dt
//////////////////////////////////////////////////////////////////// 1 4 this 3 92  
34 0 0 4 35 78 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: CMoverGroup::reset_dt
//       Access: Published
//  Description: ignores time elapsed since last set_dt, call if
//               mover group has not been moved in a long time
//               and you don't want objects to move as if they
//               were moving the whole time
//////////////////////////////////////////////////////////////////// 1 4 this 3 91  
35 0 0 4 36 78 0 0 59 // processes C++ impulses and integrates; call set_dt first 1 4 this 3 91  
36 0 0 7 37 84 0 0 0 0 
24
70 8 CImpulse 0 75777 8 CImpulse 8 CImpulse 0 0 0 1 37 0 0 7 38 39 40 41 42 43 44 0 0 1 0 71 0 0 0 0 0

71 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

72 6 CMover 0 75777 6 CMover 6 CMover 0 0 0 1 45 0 0 16 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 0 0 1 0 71 0 0 0 0 0

73 11 CMoverGroup 0 75777 11 CMoverGroup 11 CMoverGroup 0 0 0 1 62 0 0 7 63 64 65 66 67 68 69 0 0 1 0 71 0 0 0 0 0

74 10 CImpulse * 0 8576 10 CImpulse * 10 CImpulse * 0 0 70 0 0 0 0 0 0 0 0 0 0

75 16 CImpulse const * 0 8576 16 CImpulse const * 16 CImpulse const * 0 0 76 0 0 0 0 0 0 0 0 0 0

76 14 CImpulse const 0 8832 14 CImpulse const 14 CImpulse const 0 0 70 0 0 0 0 0 0 0 0 0 0

77 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

78 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

79 8 CMover * 0 8576 8 CMover * 8 CMover * 0 0 72 0 0 0 0 0 0 0 0 0 0

80 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

81 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 80 0 0 0 0 0 0 0 0 0 0

82 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

83 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

84 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 83 0 0 0 0 0 0 0 0 0 0

85 14 CMover const * 0 8576 14 CMover const * 14 CMover const * 0 0 86 0 0 0 0 0 0 0 0 0 0

86 12 CMover const 0 8832 12 CMover const 12 CMover const 0 0 72 0 0 0 0 0 0 0 0 0 0

87 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

88 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 89 0 0 0 0 0 0 0 0 0 0

89 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 90 0 0 0 0 0 0 0 0 0 0

90 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

91 13 CMoverGroup * 0 8576 13 CMoverGroup * 13 CMoverGroup * 0 0 73 0 0 0 0 0 0 0 0 0 0

92 19 CMoverGroup const * 0 8576 19 CMoverGroup const * 19 CMoverGroup const * 0 0 93 0 0 0 0 0 0 0 0 0 0

93 17 CMoverGroup const 0 8832 17 CMoverGroup const 17 CMoverGroup const 0 0 73 0 0 0 0 0 0 0 0 0 0

0
0
0
