1641926158
3 3
10 libp3putil 4 xqRv 12 panda3d.core 
965
977 5 clear 0 4 1944 68 PointerToBase< ReferenceCountedVector< unsigned short int > >::clear 0 1 17 0
87
inline void PointerToBase< ReferenceCountedVector< unsigned short int > >::clear(void);

978 6 output 0 4 1944 69 PointerToBase< ReferenceCountedVector< unsigned short int > >::output 0 1 18 0
100
void PointerToBase< ReferenceCountedVector< unsigned short int > >::output(std::ostream &out) const;

979 19 ~PointerToArrayBase 0 4 1943 61 PointerToArrayBase< unsigned short int >::~PointerToArrayBase 0 0 0
75
inline PointerToArrayBase< unsigned short int >::~PointerToArrayBase(void);

980 11 operator == 0 4 1943 53 PointerToArrayBase< unsigned short int >::operator == 0 1 15 64
// These are implemented in PointerToVoid, but expose them here.
127
inline bool PointerToArrayBase< unsigned short int >::operator ==(PointerToArrayBase< unsigned short int > const &other) const;

981 11 operator != 0 4 1943 53 PointerToArrayBase< unsigned short int >::operator != 0 1 16 0
127
inline bool PointerToArrayBase< unsigned short int >::operator !=(PointerToArrayBase< unsigned short int > const &other) const;

982 19 ConstPointerToArray 0 4 1942 62 ConstPointerToArray< unsigned short int >::ConstPointerToArray 0 2 1 2 0
246
inline ConstPointerToArray< unsigned short int >::ConstPointerToArray(PointerToArray< unsigned short int > const &copy);
inline ConstPointerToArray< unsigned short int >::ConstPointerToArray(ConstPointerToArray< unsigned short int > const &copy);

983 5 clear 0 4 1942 48 ConstPointerToArray< unsigned short int >::clear 0 1 3 0
67
inline void ConstPointerToArray< unsigned short int >::clear(void);

984 4 size 0 4 1942 47 ConstPointerToArray< unsigned short int >::size 0 1 4 0
90
inline unsigned long long int ConstPointerToArray< unsigned short int >::size(void) const;

985 11 get_element 0 4 1942 54 ConstPointerToArray< unsigned short int >::get_element 0 1 5 0
120
inline unsigned short int const &ConstPointerToArray< unsigned short int >::get_element(unsigned long long int n) const;

986 11 __getitem__ 0 4 1942 54 ConstPointerToArray< unsigned short int >::__getitem__ 0 1 6 0
113
unsigned short int const &ConstPointerToArray< unsigned short int >::__getitem__(unsigned long long int n) const;

987 8 get_data 0 4 1942 51 ConstPointerToArray< unsigned short int >::get_data 0 1 7 0
74
PyObject *ConstPointerToArray< unsigned short int >::get_data(void) const;

988 11 get_subdata 0 4 1942 54 ConstPointerToArray< unsigned short int >::get_subdata 0 1 8 0
127
PyObject *ConstPointerToArray< unsigned short int >::get_subdata(unsigned long long int n, unsigned long long int count) const;

989 13 get_ref_count 0 4 1942 56 ConstPointerToArray< unsigned short int >::get_ref_count 0 1 9 0
80
inline int ConstPointerToArray< unsigned short int >::get_ref_count(void) const;

990 18 get_node_ref_count 0 4 1942 61 ConstPointerToArray< unsigned short int >::get_node_ref_count 0 1 10 0
85
inline int ConstPointerToArray< unsigned short int >::get_node_ref_count(void) const;

991 5 count 0 4 1942 48 ConstPointerToArray< unsigned short int >::count 0 1 11 0
113
inline unsigned long long int ConstPointerToArray< unsigned short int >::count(unsigned short int const &) const;

992 10 __reduce__ 0 4 1942 53 ConstPointerToArray< unsigned short int >::__reduce__ 0 1 12 0
86
PyObject *ConstPointerToArray< unsigned short int >::__reduce__(PyObject *self) const;

993 13 __getbuffer__ 0 4 1942 56 ConstPointerToArray< unsigned short int >::__getbuffer__ 0 1 13 0
111
int ConstPointerToArray< unsigned short int >::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

994 17 __releasebuffer__ 0 4 1942 60 ConstPointerToArray< unsigned short int >::__releasebuffer__ 0 1 14 0
105
void ConstPointerToArray< unsigned short int >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

995 20 ~ConstPointerToArray 0 4 1942 63 ConstPointerToArray< unsigned short int >::~ConstPointerToArray 0 0 0
70
ConstPointerToArray< unsigned short int >::~ConstPointerToArray(void);

996 14 PointerToArray 0 4 1946 52 PointerToArray< unsigned short int >::PointerToArray 0 3 19 20 21 0
339
inline PointerToArray< unsigned short int >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((unsigned short int const *)(0))));
inline PointerToArray< unsigned short int >::PointerToArray(PointerToArray< unsigned short int > const &copy);
PointerToArray< unsigned short int >::PointerToArray(PyObject *self, PyObject *source);

997 11 empty_array 0 4 1946 49 PointerToArray< unsigned short int >::empty_array 0 1 22 0
207
static inline PointerToArray< unsigned short int > PointerToArray< unsigned short int >::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((unsigned short int const *)(0))));

998 5 clear 0 4 1946 43 PointerToArray< unsigned short int >::clear 0 1 23 0
62
inline void PointerToArray< unsigned short int >::clear(void);

999 4 size 0 4 1946 42 PointerToArray< unsigned short int >::size 0 1 24 0
85
inline unsigned long long int PointerToArray< unsigned short int >::size(void) const;

1000 9 push_back 0 4 1946 47 PointerToArray< unsigned short int >::push_back 0 1 25 0
89
inline void PointerToArray< unsigned short int >::push_back(unsigned short int const &x);

1001 8 pop_back 0 4 1946 46 PointerToArray< unsigned short int >::pop_back 0 1 26 0
65
inline void PointerToArray< unsigned short int >::pop_back(void);

1002 11 get_element 0 4 1946 49 PointerToArray< unsigned short int >::get_element 0 1 27 0
115
inline unsigned short int const &PointerToArray< unsigned short int >::get_element(unsigned long long int n) const;

1003 11 set_element 0 4 1946 49 PointerToArray< unsigned short int >::set_element 0 1 28 0
121
inline void PointerToArray< unsigned short int >::set_element(unsigned long long int n, unsigned short int const &value);

1004 11 __getitem__ 0 4 1946 49 PointerToArray< unsigned short int >::__getitem__ 0 1 29 0
108
unsigned short int const &PointerToArray< unsigned short int >::__getitem__(unsigned long long int n) const;

1005 11 __setitem__ 0 4 1946 49 PointerToArray< unsigned short int >::__setitem__ 0 1 30 0
114
void PointerToArray< unsigned short int >::__setitem__(unsigned long long int n, unsigned short int const &value);

1006 8 get_data 0 4 1946 46 PointerToArray< unsigned short int >::get_data 0 1 31 0
69
PyObject *PointerToArray< unsigned short int >::get_data(void) const;

1007 8 set_data 0 4 1946 46 PointerToArray< unsigned short int >::set_data 0 1 32 0
68
void PointerToArray< unsigned short int >::set_data(PyObject *data);

1008 11 get_subdata 0 4 1946 49 PointerToArray< unsigned short int >::get_subdata 0 1 33 0
122
PyObject *PointerToArray< unsigned short int >::get_subdata(unsigned long long int n, unsigned long long int count) const;

1009 11 set_subdata 0 4 1946 49 PointerToArray< unsigned short int >::set_subdata 0 1 34 0
157
inline void PointerToArray< unsigned short int >::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string< char > const &data);

1010 13 get_ref_count 0 4 1946 51 PointerToArray< unsigned short int >::get_ref_count 0 1 35 0
75
inline int PointerToArray< unsigned short int >::get_ref_count(void) const;

1011 18 get_node_ref_count 0 4 1946 56 PointerToArray< unsigned short int >::get_node_ref_count 0 1 36 0
80
inline int PointerToArray< unsigned short int >::get_node_ref_count(void) const;

1012 5 count 0 4 1946 43 PointerToArray< unsigned short int >::count 0 1 37 0
108
inline unsigned long long int PointerToArray< unsigned short int >::count(unsigned short int const &) const;

1013 10 __reduce__ 0 4 1946 48 PointerToArray< unsigned short int >::__reduce__ 0 1 38 0
81
PyObject *PointerToArray< unsigned short int >::__reduce__(PyObject *self) const;

1014 13 __getbuffer__ 0 4 1946 51 PointerToArray< unsigned short int >::__getbuffer__ 0 1 39 0
100
int PointerToArray< unsigned short int >::__getbuffer__(PyObject *self, Py_buffer *view, int flags);

1015 17 __releasebuffer__ 0 4 1946 55 PointerToArray< unsigned short int >::__releasebuffer__ 0 1 40 0
100
void PointerToArray< unsigned short int >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

1016 15 ~PointerToArray 0 4 1946 53 PointerToArray< unsigned short int >::~PointerToArray 0 0 0
60
PointerToArray< unsigned short int >::~PointerToArray(void);

1017 14 ~AnimInterface 0 6 1947 29 AnimInterface::~AnimInterface 0 0 10
/**
 *
 */
44
virtual AnimInterface::~AnimInterface(void);

1018 4 play 0 4 1947 19 AnimInterface::play 0 2 41 42 477
/**
 * Runs the entire animation from beginning to end and stops.
 */

/**
 * Runs the animation from the frame "from" to and including the frame "to",
 * at which point the animation is stopped.  Both "from" and "to" frame
 * numbers may be outside the range (0, get_num_frames()) and the animation
 * will follow the range correctly, reporting numbers modulo get_num_frames().
 * For instance, play(0, get_num_frames() * 2) will play the animation twice
 * and then stop.
 */
95
inline void AnimInterface::play(void);
inline void AnimInterface::play(double from, double to);

1019 4 loop 0 4 1947 19 AnimInterface::loop 0 2 43 44 392
/**
 * Starts the entire animation looping.  If restart is true, the animation is
 * restarted from the beginning; otherwise, it continues from the current
 * frame.
 */

/**
 * Loops the animation from the frame "from" to and including the frame "to",
 * indefinitely.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */
117
inline void AnimInterface::loop(bool restart);
inline void AnimInterface::loop(bool restart, double from, double to);

1020 8 pingpong 0 4 1947 23 AnimInterface::pingpong 0 2 45 46 369
/**
 * Starts the entire animation bouncing back and forth between its first frame
 * and last frame.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */

/**
 * Loops the animation from the frame "from" to and including the frame "to",
 * and then back in the opposite direction, indefinitely.
 */
125
inline void AnimInterface::pingpong(bool restart);
inline void AnimInterface::pingpong(bool restart, double from, double to);

1021 4 stop 0 4 1947 19 AnimInterface::stop 0 1 47 130
/**
 * Stops a currently playing or looping animation right where it is.  The
 * animation remains posed at the current frame.
 */
38
inline void AnimInterface::stop(void);

1022 4 pose 0 4 1947 19 AnimInterface::pose 0 1 48 72
/**
 * Sets the animation to the indicated frame and holds it there.
 */
46
inline void AnimInterface::pose(double frame);

1023 13 set_play_rate 0 4 1947 28 AnimInterface::set_play_rate 0 1 49 243
/**
 * Changes the rate at which the animation plays.  1.0 is the normal speed,
 * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
 * pause the animation, and a negative value will play the animation
 * backwards.
 */
59
inline void AnimInterface::set_play_rate(double play_rate);

1024 13 get_play_rate 0 4 1947 28 AnimInterface::get_play_rate 0 1 50 79
/**
 * Returns the rate at which the animation plays.  See set_play_rate().
 */
55
inline double AnimInterface::get_play_rate(void) const;

1025 14 get_frame_rate 0 4 1947 29 AnimInterface::get_frame_rate 0 1 51 234
/**
 * Returns the native frame rate of the animation.  This is the number of
 * frames per second that will elapse when the play_rate is set to 1.0.  It is
 * a fixed property of the animation and may not be adjusted by the user.
 */
56
inline double AnimInterface::get_frame_rate(void) const;

1026 14 get_num_frames 0 6 1947 29 AnimInterface::get_num_frames 0 1 52 278
/**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */
54
virtual int AnimInterface::get_num_frames(void) const;

1027 9 get_frame 0 4 1947 24 AnimInterface::get_frame 0 1 53 116
/**
 * Returns the current integer frame number.  This number will be in the range
 * 0 <= f < get_num_frames().
 */
48
inline int AnimInterface::get_frame(void) const;

1028 14 get_next_frame 0 4 1947 29 AnimInterface::get_next_frame 0 1 54 330
/**
 * Returns the current integer frame number + 1, constrained to the range 0 <=
 * f < get_num_frames().
 *
 * If the play mode is PM_play, this will clamp to the same value as
 * get_frame() at the end of the animation.  If the play mode is any other
 * value, this will wrap around to frame 0 at the end of the animation.
 */
53
inline int AnimInterface::get_next_frame(void) const;

1029 8 get_frac 0 4 1947 23 AnimInterface::get_frac 0 1 55 314
/**
 * Returns the fractional part of the current frame.  Normally, this is in the
 * range 0.0 <= f < 1.0, but in the one special case of an animation playing
 * to its end frame and stopping, it might exactly equal 1.0.
 *
 * It will always be true that get_full_frame() + get_frac() ==
 * get_full_fframe().
 */
50
inline double AnimInterface::get_frac(void) const;

1030 14 get_full_frame 0 4 1947 29 AnimInterface::get_full_frame 0 1 56 372
/**
 * Returns the current integer frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_fframe(), this return value will
 * never exceed the value passed to to_frame in the play() method.
 */
53
inline int AnimInterface::get_full_frame(void) const;

1031 15 get_full_fframe 0 4 1947 30 AnimInterface::get_full_fframe 0 1 57 490
/**
 * Returns the current floating-point frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_frame(), this return value may equal
 * (to_frame + 1.0), when the animation has played to its natural end.
 * However, in this case the return value of get_full_frame() will be
 * to_frame, not (to_frame + 1).
 */
57
inline double AnimInterface::get_full_fframe(void) const;

1032 10 is_playing 0 4 1947 25 AnimInterface::is_playing 0 1 58 208
/**
 * Returns true if the animation is currently playing, false if it is stopped
 * (e.g.  because stop() or pose() was called, or because it reached the end
 * of the animation after play() was called).
 */
50
inline bool AnimInterface::is_playing(void) const;

1033 6 output 0 6 1947 21 AnimInterface::output 0 1 59 10
/**
 *
 */
60
virtual void AnimInterface::output(std::ostream &out) const;

1034 14 get_class_type 0 4 1947 29 AnimInterface::get_class_type 0 1 60 0
54
static TypeHandle AnimInterface::get_class_type(void);

1035 9 UpdateSeq 0 4 1952 20 UpdateSeq::UpdateSeq 0 2 61 62 132
/**
 * Creates an UpdateSeq in the given state.
 */

/**
 * Creates an UpdateSeq in the 'initial' state.
 */

/**
 *
 */

/**
 *
 */
89
constexpr UpdateSeq::UpdateSeq(void);
inline UpdateSeq::UpdateSeq(UpdateSeq const &copy);

1036 7 initial 0 4 1952 18 UpdateSeq::initial 0 1 63 0
52
static constexpr UpdateSeq UpdateSeq::initial(void);

1037 3 old 0 4 1952 14 UpdateSeq::old 0 1 64 0
48
static constexpr UpdateSeq UpdateSeq::old(void);

1038 5 fresh 0 4 1952 16 UpdateSeq::fresh 0 1 65 0
50
static constexpr UpdateSeq UpdateSeq::fresh(void);

1039 10 operator = 0 4 1952 21 UpdateSeq::operator = 0 1 66 10
/**
 *
 */
57
inline void UpdateSeq::operator =(UpdateSeq const &copy);

1040 5 clear 0 4 1952 16 UpdateSeq::clear 0 1 67 55
/**
 * Resets the UpdateSeq to the 'initial' state.
 */
35
inline void UpdateSeq::clear(void);

1041 10 is_initial 0 4 1952 21 UpdateSeq::is_initial 0 1 68 67
/**
 * Returns true if the UpdateSeq is in the 'initial' state.
 */
46
inline bool UpdateSeq::is_initial(void) const;

1042 6 is_old 0 4 1952 17 UpdateSeq::is_old 0 1 69 63
/**
 * Returns true if the UpdateSeq is in the 'old' state.
 */
42
inline bool UpdateSeq::is_old(void) const;

1043 8 is_fresh 0 4 1952 19 UpdateSeq::is_fresh 0 1 70 65
/**
 * Returns true if the UpdateSeq is in the 'fresh' state.
 */
44
inline bool UpdateSeq::is_fresh(void) const;

1044 10 is_special 0 4 1952 21 UpdateSeq::is_special 0 1 71 105
/**
 * Returns true if the UpdateSeq is in any special states, i.e.  'initial',
 * 'old', or 'fresh'.
 */
46
inline bool UpdateSeq::is_special(void) const;

1045 11 operator == 0 4 1952 22 UpdateSeq::operator == 0 1 72 0
65
inline bool UpdateSeq::operator ==(UpdateSeq const &other) const;

1046 11 operator != 0 4 1952 22 UpdateSeq::operator != 0 1 73 0
65
inline bool UpdateSeq::operator !=(UpdateSeq const &other) const;

1047 10 operator < 0 4 1952 21 UpdateSeq::operator < 0 1 74 0
64
inline bool UpdateSeq::operator <(UpdateSeq const &other) const;

1048 11 operator <= 0 4 1952 22 UpdateSeq::operator <= 0 1 75 0
65
inline bool UpdateSeq::operator <=(UpdateSeq const &other) const;

1049 10 operator > 0 4 1952 21 UpdateSeq::operator > 0 1 76 0
64
inline bool UpdateSeq::operator >(UpdateSeq const &other) const;

1050 11 operator >= 0 4 1952 22 UpdateSeq::operator >= 0 1 77 0
65
inline bool UpdateSeq::operator >=(UpdateSeq const &other) const;

1051 11 operator ++ 0 68 1952 22 UpdateSeq::operator ++ 0 1 78 0
46
inline UpdateSeq UpdateSeq::operator ++(void);

1052 11 operator ++ 0 4 1952 22 UpdateSeq::operator ++ 0 1 79 0
46
inline UpdateSeq UpdateSeq::operator ++(int );

1053 7 get_seq 0 4 1952 18 UpdateSeq::get_seq 0 1 80 107
/**
 * Returns the internal integer value associated with the UpdateSeq.  Useful
 * for debugging only.
 */
60
inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const;

1054 6 output 0 4 1952 17 UpdateSeq::output 0 1 81 10
/**
 *
 */
55
inline void UpdateSeq::output(std::ostream &out) const;

1055 10 ~UpdateSeq 0 4 1952 21 UpdateSeq::~UpdateSeq 0 0 0
28
UpdateSeq::~UpdateSeq(void);

1056 6 fillin 0 6 1956 21 TypedWritable::fillin 0 1 82 308
/**
 * This internal function is intended to be called by each class's
 * make_from_bam() method to read in all of the relevant data from the BamFile
 * for the new object.  It is also called directly by the BamReader to re-read
 * the data for an object that has been placed on the stream for an update.
 */
79
virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager);

1057 17 mark_bam_modified 0 4 1956 32 TypedWritable::mark_bam_modified 0 1 83 345
/**
 * Increments the bam_modified counter, so that this object will be
 * invalidated and retransmitted on any open bam streams.  This should
 * normally not need to be called by user code; it should be called internally
 * when the object has been changed in a way that legitimately requires its
 * retransmission to any connected clients.
 */
51
inline void TypedWritable::mark_bam_modified(void);

1058 16 get_bam_modified 0 4 1956 31 TypedWritable::get_bam_modified 0 1 84 140
/**
 * Returns the current bam_modified counter.  This counter is normally
 * incremented automatically whenever the object is modified.
 */
61
inline UpdateSeq TypedWritable::get_bam_modified(void) const;

1059 10 __reduce__ 0 4 1956 25 TypedWritable::__reduce__ 0 1 85 0
58
PyObject *TypedWritable::__reduce__(PyObject *self) const;

1060 18 __reduce_persist__ 0 4 1956 33 TypedWritable::__reduce_persist__ 0 1 86 0
85
PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const;

1061 20 encode_to_bam_stream 0 4 1956 35 TypedWritable::encode_to_bam_stream 0 2 87 88 854
/**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and returns that data as a bytes object.  Returns an empty bytes
 * object on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */

/**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and stores that data in the indicated string.  Returns true on
 * success, false on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */
165
inline vector_uchar TypedWritable::encode_to_bam_stream(void) const;
bool TypedWritable::encode_to_bam_stream(vector_uchar &data, BamWriter *writer = nullptr) const;

1062 26 decode_raw_from_bam_stream 0 4 1956 41 TypedWritable::decode_raw_from_bam_stream 0 0 953
/**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts the single object on those bytes.  Returns true on success, false
 * on error.
 *
 * This variant sets the TypedWritable and ReferenceCount pointers separately;
 * both are pointers to the same object.  The reference count is not
 * incremented; it is the caller's responsibility to manage the reference
 * count.
 *
 * Note that this method cannot be used to retrieve objects that do not
 * inherit from ReferenceCount, because these objects cannot persist beyond
 * the lifetime of the BamReader that reads them.  To retrieve these objects
 * from a bam stream, you must construct a BamReader directly.
 *
 * If you happen to know that the particular object in question inherits from
 * TypedWritableReferenceCount or PandaNode, consider calling the variant of
 * decode_from_bam_stream() defined for those methods, which presents a
 * simpler interface.
 */
149
static bool TypedWritable::decode_raw_from_bam_stream(TypedWritable *&ptr, ReferenceCount *&ref_ptr, vector_uchar data, BamReader *reader = nullptr);

1063 14 get_class_type 0 4 1956 29 TypedWritable::get_class_type 0 1 89 0
54
static TypeHandle TypedWritable::get_class_type(void);

1064 23 upcast_to_TypedWritable 0 12 1958 52 TypedWritableReferenceCount::upcast_to_TypedWritable 0 1 92 56
upcast from TypedWritableReferenceCount to TypedWritable
74
TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void);

1065 39 downcast_to_TypedWritableReferenceCount 0 12 1956 54 TypedWritable::downcast_to_TypedWritableReferenceCount 0 0 58
downcast from TypedWritable to TypedWritableReferenceCount
90
TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void);

1066 24 upcast_to_ReferenceCount 0 12 1958 53 TypedWritableReferenceCount::upcast_to_ReferenceCount 0 1 93 57
upcast from TypedWritableReferenceCount to ReferenceCount
76
ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void);

1067 39 downcast_to_TypedWritableReferenceCount 0 12 1959 55 ReferenceCount::downcast_to_TypedWritableReferenceCount 0 0 59
downcast from ReferenceCount to TypedWritableReferenceCount
91
TypedWritableReferenceCount *ReferenceCount::downcast_to_TypedWritableReferenceCount(void);

1068 22 decode_from_bam_stream 0 4 1958 51 TypedWritableReferenceCount::decode_from_bam_stream 0 1 90 491
/**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts and returns the single object on those bytes.  Returns NULL on
 * error.
 *
 * This method is intended to replace decode_raw_from_bam_stream() when you
 * know the stream in question returns an object of type
 * TypedWritableReferenceCount, allowing for easier reference count
 * management.  Note that the caller is still responsible for maintaining the
 * reference count on the return value.
 */
148
static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr);

1069 14 get_class_type 0 4 1958 43 TypedWritableReferenceCount::get_class_type 0 1 91 0
68
static TypeHandle TypedWritableReferenceCount::get_class_type(void);

1070 28 ~TypedWritableReferenceCount 0 4 1958 57 TypedWritableReferenceCount::~TypedWritableReferenceCount 0 0 0
64
TypedWritableReferenceCount::~TypedWritableReferenceCount(void);

1071 37 upcast_to_TypedWritableReferenceCount 0 12 1960 53 BamCacheRecord::upcast_to_TypedWritableReferenceCount 0 1 116 57
upcast from BamCacheRecord to TypedWritableReferenceCount
89
TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void);

1072 26 downcast_to_BamCacheRecord 0 12 1958 55 TypedWritableReferenceCount::downcast_to_BamCacheRecord 0 0 59
downcast from TypedWritableReferenceCount to BamCacheRecord
78
BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void);

1073 24 upcast_to_LinkedListNode 0 12 1960 40 BamCacheRecord::upcast_to_LinkedListNode 0 0 44
upcast from BamCacheRecord to LinkedListNode
63
LinkedListNode *BamCacheRecord::upcast_to_LinkedListNode(void);

1074 26 downcast_to_BamCacheRecord 0 12 1961 42 LinkedListNode::downcast_to_BamCacheRecord 0 0 46
downcast from LinkedListNode to BamCacheRecord
65
BamCacheRecord *LinkedListNode::downcast_to_BamCacheRecord(void);

1075 15 ~BamCacheRecord 0 6 1960 31 BamCacheRecord::~BamCacheRecord 0 0 10
/**
 *
 */
46
virtual BamCacheRecord::~BamCacheRecord(void);

1076 9 make_copy 0 4 1960 25 BamCacheRecord::make_copy 0 1 94 179
/**
 * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
 * data pointer set, even though one may have been assigned to the original
 * via set_data().
 */
73
inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const;

1077 11 operator == 0 4 1960 27 BamCacheRecord::operator == 0 1 95 0
75
inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const;

1078 19 get_source_pathname 0 4 1960 35 BamCacheRecord::get_source_pathname 0 1 96 237
/**
 * Returns the full pathname to the source file that originally generated this
 * cache request.  In some cases, for instance in the case of a of a multipage
 * texture like "cube_#.png", this may not not a true filename on disk.
 */
71
inline Filename const &BamCacheRecord::get_source_pathname(void) const;

1079 18 get_cache_filename 0 4 1960 34 BamCacheRecord::get_cache_filename 0 1 97 230
/**
 * Returns the name of the cache file as hashed from the source_pathname.
 * This will be relative to the root of the cache directory, and it will not
 * include any suffixes that may be appended to resolve hash conflicts.
 */
70
inline Filename const &BamCacheRecord::get_cache_filename(void) const;

1080 20 get_source_timestamp 0 4 1960 36 BamCacheRecord::get_source_timestamp 0 1 98 204
/**
 * Returns the file timestamp of the original source file that generated this
 * cache record, if available.  In some cases the original file timestamp is
 * not available, and this will return 0.
 */
63
inline time_t BamCacheRecord::get_source_timestamp(void) const;

1081 17 get_recorded_time 0 4 1960 33 BamCacheRecord::get_recorded_time 0 1 99 84
/**
 * Returns the time at which this particular record was recorded or updated.
 */
60
inline time_t BamCacheRecord::get_recorded_time(void) const;

1082 23 get_num_dependent_files 0 4 1960 39 BamCacheRecord::get_num_dependent_files 0 1 100 75
/**
 * Returns the number of source files that contribute to the cache.
 */
63
inline int BamCacheRecord::get_num_dependent_files(void) const;

1083 22 get_dependent_pathname 0 4 1960 38 BamCacheRecord::get_dependent_pathname 0 1 101 94
/**
 * Returns the full pathname of the nth source files that contributes to the
 * cache.
 */
75
inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const;

1084 20 dependents_unchanged 0 4 1960 36 BamCacheRecord::dependents_unchanged 0 1 102 124
/**
 * Returns true if all of the dependent files are still the same as when the
 * cache was recorded, false otherwise.
 */
54
bool BamCacheRecord::dependents_unchanged(void) const;

1085 21 clear_dependent_files 0 4 1960 37 BamCacheRecord::clear_dependent_files 0 1 103 80
/**
 * Empties the list of files that contribute to the data in this record.
 */
49
void BamCacheRecord::clear_dependent_files(void);

1086 18 add_dependent_file 0 4 1960 34 BamCacheRecord::add_dependent_file 0 2 104 105 309
/**
 * Adds the indicated file to the list of files that will be loaded to
 * generate the data in this record.  This should be called once for the
 * primary source file, and again for each secondary source file, if any.
 */

/**
 * Variant of add_dependent_file that takes an already opened VirtualFile.
 */
132
void BamCacheRecord::add_dependent_file(Filename const &pathname);
void BamCacheRecord::add_dependent_file(VirtualFile const *file);

1087 8 has_data 0 4 1960 24 BamCacheRecord::has_data 0 1 106 130
/**
 * Returns true if this cache record has an in-memory data object associated--
 * that is, the object stored in the cache.
 */
49
inline bool BamCacheRecord::has_data(void) const;

1088 10 clear_data 0 4 1960 26 BamCacheRecord::clear_data 0 1 107 147
/**
 * Removes the in-memory data object associated with this record, if any.
 * This does not affect the on-disk representation of the record.
 */
45
inline void BamCacheRecord::clear_data(void);

1089 8 get_data 0 4 1960 24 BamCacheRecord::get_data 0 1 108 139
/**
 * Returns a pointer to the data stored in the record, or NULL if there is no
 * data.  The pointer is not removed from the record.
 */
59
inline TypedWritable *BamCacheRecord::get_data(void) const;

1090 12 extract_data 0 4 1960 28 BamCacheRecord::extract_data 0 0 416
/**
 * Fills ptr and ref_ptr with the two different-typed pointers to the same
 * object, the data stored within this record.  This transfers ownership of
 * the data pointer; the caller will be responsible for managing the reference
 * counts on this object subsequently.
 *
 * Returns true if the record contained any data (and the pointers have been
 * filled), false if it didn't (and the pointers are NULL).
 */
88
inline bool BamCacheRecord::extract_data(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

1091 8 set_data 0 4 1960 24 BamCacheRecord::set_data 0 4 109 110 111 112 916
/**
 * Stores a new data object on the record.  You should pass the same pointer
 * twice, to both parameters; this allows the C++ typecasting to automatically
 * convert the pointer into both a TypedWritable and a ReferenceCount pointer,
 * so that the BamCacheRecord object can reliably manage the reference counts.
 *
 * You may pass 0 or NULL as the second parameter.  If you do this, the
 * BamCacheRecord will not manage the object's reference count; it will be up
 * to you to ensure the object is not deleted during the lifetime of the
 * BamCacheRecord object.
 */

/**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritable.
 */

/**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritableReferenceCount.
 */

/**
 * This variant on set_data() is provided just to allow Python code to pass a
 * 0 as the second parameter.
 */
281
inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr);
inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy);

1092 6 output 0 4 1960 22 BamCacheRecord::output 0 1 113 10
/**
 *
 */
53
void BamCacheRecord::output(std::ostream &out) const;

1093 5 write 0 4 1960 21 BamCacheRecord::write 0 1 114 10
/**
 *
 */
74
void BamCacheRecord::write(std::ostream &out, int indent_level = 0) const;

1094 14 get_class_type 0 4 1960 30 BamCacheRecord::get_class_type 0 1 115 0
55
static TypeHandle BamCacheRecord::get_class_type(void);

1095 8 BamCache 0 4 1966 18 BamCache::BamCache 0 1 117 10
/**
 *
 */
25
BamCache::BamCache(void);

1096 9 ~BamCache 0 4 1966 19 BamCache::~BamCache 0 0 10
/**
 *
 */
26
BamCache::~BamCache(void);

1097 10 set_active 0 4 1966 20 BamCache::set_active 0 1 118 347
/**
 * Changes the state of the active flag.  "active" means that the cache should
 * be consulted automatically on loads, "not active" means that objects should
 * be loaded directly without consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */
44
inline void BamCache::set_active(bool flag);

1098 10 get_active 0 4 1966 20 BamCache::get_active 0 1 119 381
/**
 * Returns true if the BamCache is currently active, false if it is not.
 * "active" means that the cache should be consulted automatically on loads,
 * "not active" means that objects should be loaded directly without
 * consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */
45
inline bool BamCache::get_active(void) const;

1099 16 set_cache_models 0 4 1966 26 BamCache::set_cache_models 0 1 120 118
/**
 * Indicates whether model files (e.g.  egg files and bam files) will be
 * stored in the cache, as bam files.
 */
50
inline void BamCache::set_cache_models(bool flag);

1100 16 get_cache_models 0 4 1966 26 BamCache::get_cache_models 0 1 121 172
/**
 * Returns whether model files (e.g.  egg files and bam files) will be stored
 * in the cache, as bam files.
 *
 * This also returns false if get_active() is false.
 */
51
inline bool BamCache::get_cache_models(void) const;

1101 18 set_cache_textures 0 4 1966 28 BamCache::set_cache_textures 0 1 122 101
/**
 * Indicates whether texture files will be stored in the cache, as
 * uncompressed txo files.
 */
52
inline void BamCache::set_cache_textures(bool flag);

1102 18 get_cache_textures 0 4 1966 28 BamCache::get_cache_textures 0 1 123 174
/**
 * Returns whether texture files (e.g.  egg files and bam files) will be
 * stored in the cache, as txo files.
 *
 * This also returns false if get_active() is false.
 */
53
inline bool BamCache::get_cache_textures(void) const;

1103 29 set_cache_compressed_textures 0 4 1966 39 BamCache::set_cache_compressed_textures 0 1 124 722
/**
 * Indicates whether compressed texture files will be stored in the cache, as
 * compressed txo files.  The compressed data may either be generated in-CPU,
 * via the squish library, or it may be extracted from the GSG after the
 * texture has been loaded.
 *
 * This may be set in conjunction with set_cache_textures(), or independently
 * of it.  If set_cache_textures() is true and this is false, all textures
 * will be cached in their uncompressed form.  If set_cache_textures() is
 * false and this is true, only compressed textures will be cached, and they
 * will be cached in their compressed form.  If both are true, all textures
 * will be cached, in their uncompressed or compressed form appropriately.
 */
63
inline void BamCache::set_cache_compressed_textures(bool flag);

1104 29 get_cache_compressed_textures 0 4 1966 39 BamCache::get_cache_compressed_textures 0 1 125 202
/**
 * Returns whether compressed texture files will be stored in the cache, as
 * compressed txo files.  See set_cache_compressed_textures().
 *
 * This also returns false if get_active() is false.
 */
64
inline bool BamCache::get_cache_compressed_textures(void) const;

1105 26 set_cache_compiled_shaders 0 4 1966 36 BamCache::set_cache_compiled_shaders 0 1 126 184
/**
 * Indicates whether compiled shader programs will be stored in the cache, as
 * binary .sho files.  This may not be supported by all shader languages or
 * graphics renderers.
 */
60
inline void BamCache::set_cache_compiled_shaders(bool flag);

1106 26 get_cache_compiled_shaders 0 4 1966 36 BamCache::get_cache_compiled_shaders 0 1 127 196
/**
 * Returns whether compiled shader programs will be stored in the cache, as
 * binary .txo files.  See set_cache_compiled_shaders().
 *
 * This also returns false if get_active() is false.
 */
61
inline bool BamCache::get_cache_compiled_shaders(void) const;

1107 8 set_root 0 4 1966 18 BamCache::set_root 0 1 128 372
/**
 * Changes the current root pathname of the cache.  This specifies where the
 * cache files are stored on disk.  This should name a directory that is on a
 * disk local to the machine (not on a network-mounted disk), for instance,
 * /tmp/panda-cache or /c/panda-cache.
 *
 * If the directory does not already exist, it will be created as a result of
 * this call.
 */
46
void BamCache::set_root(Filename const &root);

1108 8 get_root 0 4 1966 18 BamCache::get_root 0 1 129 75
/**
 * Returns the current root pathname of the cache.  See set_root().
 */
47
inline Filename BamCache::get_root(void) const;

1109 14 set_flush_time 0 4 1966 24 BamCache::set_flush_time 0 1 130 86
/**
 * Specifies the time in seconds between automatic flushes of the cache index.
 */
53
inline void BamCache::set_flush_time(int flush_time);

1110 14 get_flush_time 0 4 1966 24 BamCache::get_flush_time 0 1 131 84
/**
 * Returns the time in seconds between automatic flushes of the cache index.
 */
48
inline int BamCache::get_flush_time(void) const;

1111 20 set_cache_max_kbytes 0 4 1966 30 BamCache::set_cache_max_kbytes 0 1 132 430
/**
 * Specifies the maximum size, in kilobytes, which the cache is allowed to
 * grow to.  If a newly cached file would exceed this size, an older file is
 * removed from the cache.
 *
 * Note that in the case of multiple different processes simultaneously
 * operating on the same cache directory, the actual cache size may slightly
 * exceed this value from time to time due to latency in checking between the
 * processes.
 */
59
inline void BamCache::set_cache_max_kbytes(int max_kbytes);

1112 20 get_cache_max_kbytes 0 4 1966 30 BamCache::get_cache_max_kbytes 0 1 133 121
/**
 * Returns the maximum size, in kilobytes, which the cache is allowed to grow
 * to.  See set_cache_max_kbytes().
 */
54
inline int BamCache::get_cache_max_kbytes(void) const;

1113 13 set_read_only 0 4 1966 23 BamCache::set_read_only 0 1 134 252
/**
 * Can be used to put the cache in read-only mode, or take it out of read-only
 * mode.  Note that if you put it into read-write mode, and it discovers that
 * it does not have write access, it will put itself right back into read-only
 * mode.
 */
45
inline void BamCache::set_read_only(bool ro);

1114 13 get_read_only 0 4 1966 23 BamCache::get_read_only 0 1 135 230
/**
 * Returns true if the cache is in read-only mode.  Normally, the cache starts
 * in read-write mode.  It can put itself into read-only mode automatically if
 * it discovers that it does not have write access to the cache.
 */
48
inline bool BamCache::get_read_only(void) const;

1115 6 lookup 0 4 1966 16 BamCache::lookup 0 1 136 782
/**
 * Looks up a file in the cache.
 *
 * If the file is cacheable, then regardless of whether the file is found in
 * the cache or not, this returns a BamCacheRecord.  On the other hand, if the
 * file cannot be cached, returns NULL.
 *
 * If record->has_data() returns true, then the file was found in the cache,
 * and you may call record->extract_data() to get the object.  If
 * record->has_data() returns false, then the file was not found in the cache
 * or the cache was stale; and you should reload the source file (calling
 * record->add_dependent_file() for each file loaded, including the original
 * source file), and then call record->set_data() to record the resulting
 * loaded object; and finally, you should call store() to write the cached
 * record to disk.
 */
114
PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension);

1116 5 store 0 4 1966 15 BamCache::store 0 1 137 212
/**
 * Flushes a cache entry to disk.  You must have retrieved the cache record
 * via a prior call to lookup(), and then stored the data via
 * record->set_data().  Returns true on success, false on failure.
 */
45
bool BamCache::store(BamCacheRecord *record);

1117 20 consider_flush_index 0 4 1966 30 BamCache::consider_flush_index 0 1 138 92
/**
 * Flushes the index if enough time has elapsed since the index was last
 * flushed.
 */
42
void BamCache::consider_flush_index(void);

1118 11 flush_index 0 4 1966 21 BamCache::flush_index 0 1 139 48
/**
 * Ensures the index is written to disk.
 */
33
void BamCache::flush_index(void);

1119 10 list_index 0 4 1966 20 BamCache::list_index 0 1 140 63
/**
 * Writes the contents of the index to standard output.
 */
73
void BamCache::list_index(std::ostream &out, int indent_level = 0) const;

1120 14 get_global_ptr 0 4 1966 24 BamCache::get_global_ptr 0 1 141 124
/**
 * Returns a pointer to the global BamCache object, which is used
 * automatically by the ModelPool and TexturePool.
 */
55
static inline BamCache *BamCache::get_global_ptr(void);

1121 27 consider_flush_global_index 0 4 1966 37 BamCache::consider_flush_global_index 0 1 142 84
/**
 * If there is a global BamCache object, calls consider_flush_index() on it.
 */
63
static inline void BamCache::consider_flush_global_index(void);

1122 18 flush_global_index 0 4 1966 28 BamCache::flush_global_index 0 1 143 75
/**
 * If there is a global BamCache object, calls flush_index() on it.
 */
54
static inline void BamCache::flush_global_index(void);

1123 8 BamEnums 0 4 1967 18 BamEnums::BamEnums 0 2 144 145 0
97
inline BamEnums::BamEnums(void) = default;
inline BamEnums::BamEnums(BamEnums const &) = default;

1124 9 ~BamEnums 0 4 1967 19 BamEnums::~BamEnums 0 0 0
26
BamEnums::~BamEnums(void);

1125 13 LoaderOptions 0 4 1971 28 LoaderOptions::LoaderOptions 0 3 146 147 148 22
/**
 *
 */

/**
 *
 */
247
LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors));
constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags);
inline LoaderOptions::LoaderOptions(LoaderOptions const &) = default;

1126 9 set_flags 0 4 1971 24 LoaderOptions::set_flags 0 1 149 10
/**
 *
 */
48
inline void LoaderOptions::set_flags(int flags);

1127 9 get_flags 0 4 1971 24 LoaderOptions::get_flags 0 1 150 10
/**
 *
 */
48
inline int LoaderOptions::get_flags(void) const;

1128 17 set_texture_flags 0 4 1971 32 LoaderOptions::set_texture_flags 0 1 151 10
/**
 *
 */
56
inline void LoaderOptions::set_texture_flags(int flags);

1129 17 get_texture_flags 0 4 1971 32 LoaderOptions::get_texture_flags 0 1 152 10
/**
 *
 */
56
inline int LoaderOptions::get_texture_flags(void) const;

1130 21 set_texture_num_views 0 4 1971 36 LoaderOptions::set_texture_num_views 0 1 153 459
/**
 * Specifies the expected number of views to load for the texture.  This is
 * ignored unless TF_multiview is included in texture_flags.  This must be
 * specified when loading a 3-d multiview texture or 2-d texture array, in
 * which case it is used to differentiate z levels from separate views; it
 * may be zero in the case of 2-d textures or cube maps, in which case the
 * number of views can be inferred from the number of images found on disk.
 */
64
inline void LoaderOptions::set_texture_num_views(int num_views);

1131 21 get_texture_num_views 0 4 1971 36 LoaderOptions::get_texture_num_views 0 1 154 39
/**
 * See set_texture_num_views().
 */
60
inline int LoaderOptions::get_texture_num_views(void) const;

1132 22 set_auto_texture_scale 0 4 1971 37 LoaderOptions::set_auto_texture_scale 0 1 155 209
/**
 * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
 * texture is scaled from disk when it is subsequently loaded.  Set it to
 * ATS_unspecified to restore the default behavior.
 */
74
inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale);

1133 22 get_auto_texture_scale 0 4 1971 37 LoaderOptions::get_auto_texture_scale 0 1 156 40
/**
 * See set_auto_texture_scale().
 */
74
inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const;

1134 6 output 0 4 1971 21 LoaderOptions::output 0 1 157 10
/**
 *
 */
52
void LoaderOptions::output(std::ostream &out) const;

1135 14 ~LoaderOptions 0 4 1971 29 LoaderOptions::~LoaderOptions 0 0 0
36
LoaderOptions::~LoaderOptions(void);

1136 9 BamReader 0 4 1974 20 BamReader::BamReader 0 1 158 50
// The primary interface for a caller.

/**
 *
 */
67
explicit BamReader::BamReader(DatagramGenerator *source = nullptr);

1137 10 ~BamReader 0 4 1974 21 BamReader::~BamReader 0 0 10
/**
 *
 */
28
BamReader::~BamReader(void);

1138 10 set_source 0 4 1974 21 BamReader::set_source 0 1 159 142
/**
 * Changes the source of future datagrams for this BamReader.  This also
 * implicitly calls init() if it has not already been called.
 */
54
void BamReader::set_source(DatagramGenerator *source);

1139 10 get_source 0 4 1974 21 BamReader::get_source 0 1 160 100
/**
 * Returns the current source of the BamReader as set by set_source() or the
 * constructor.
 */
54
inline DatagramGenerator *BamReader::get_source(void);

1140 4 init 0 4 1974 15 BamReader::init 0 1 161 210
/**
 * Initializes the BamReader prior to reading any objects from its source.
 * This includes reading the Bam header.
 *
 * This returns true if the BamReader successfully initialized, false
 * otherwise.
 */
27
bool BamReader::init(void);

1141 12 set_aux_data 0 4 1974 23 BamReader::set_aux_data 0 1 162 1007
/**
 * Associates an arbitrary block of data with the indicated object (or NULL),
 * and the indicated name.
 *
 * This is intended to provide a place for temporary storage for objects
 * reading themselves from the bam file.  To use it, inherit from
 * BamReader::AuxData and store whatever data you like there.  Then associate
 * your AuxData with the object as it is being read with set_aux_data().  You
 * may later set the aux data to NULL to remove it; or it will automatically
 * be removed (and deleted) after finalize() is called for the object in
 * question.
 *
 * If the TypedWritable pointer is NULL, the the aux data is stored globally
 * for the BamReader in general.  This pointer is available to any bam
 * objects, and will not be automatically removed until the BamReader itself
 * destructs.
 *
 * In either case, the name is just an arbitrary user-defined key.  If there
 * is already a data pointer stored for the obj/name pair, that data pointer
 * will be replaced (and deleted).
 */
100
void BamReader::set_aux_data(TypedWritable *obj, std::string const &name, BamReader::AuxData *data);

1142 12 get_aux_data 0 4 1974 23 BamReader::get_aux_data 0 1 163 173
/**
 * Returns the pointer previously associated with the bam reader by a previous
 * call to set_aux_data(), or NULL if data with the indicated key has not been
 * set.
 */
95
BamReader::AuxData *BamReader::get_aux_data(TypedWritable *obj, std::string const &name) const;

1143 12 get_filename 0 4 1974 23 BamReader::get_filename 0 1 164 199
/**
 * If a BAM is a file, then the BamReader should contain the name of the file.
 * This enables the reader to interpret pathnames in the BAM as relative to
 * the directory containing the BAM.
 */
59
inline Filename const &BamReader::get_filename(void) const;

1144 18 get_loader_options 0 4 1974 29 BamReader::get_loader_options 0 1 165 98
/**
 * Returns the LoaderOptions passed to the loader when the model was
 * requested, if any.
 */
70
inline LoaderOptions const &BamReader::get_loader_options(void) const;

1145 18 set_loader_options 0 4 1974 29 BamReader::set_loader_options 0 1 166 58
/**
 * Specifies the LoaderOptions for this BamReader.
 */
72
inline void BamReader::set_loader_options(LoaderOptions const &options);

1146 11 read_object 0 4 1974 22 BamReader::read_object 0 1 167 1393
/**
 * Reads a single object from the Bam file.  If the object type is known, a
 * new object of the appropriate type is created and returned; otherwise, NULL
 * is returned.  NULL is also returned when the end of the file is reached.
 * is_eof() may be called to differentiate between these two cases.
 *
 * This may be called repeatedly to extract out all the objects in the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is retrieved directly from the Bam file:
 * the root of the scene graph.  The remaining objects will all be retrieved
 * recursively by the first object.
 *
 * Note that the object returned may not yet be complete.  In particular, some
 * of its pointers may not be filled in; you must call resolve() to fill in
 * all the available pointers before you can safely use any objects returned
 * by read_object().
 *
 * This flavor of read_object() requires the caller to know what type of
 * object it has received in order to properly manage the reference counts.
 */

/**
 * Reads a single object from the Bam file.
 *
 * This flavor of read_object() returns both a TypedWritable and a
 * ReferenceCount pointer to the same object, so the reference count may be
 * tracked reliably, without having to know precisely what type of object we
 * have.
 * @return true on success, or false on failure.
 */
120
TypedWritable *BamReader::read_object(void);
bool BamReader::read_object(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

1147 6 is_eof 0 4 1974 17 BamReader::is_eof 0 1 168 138
/**
 * Returns true if the reader has reached end-of-file, false otherwise.  This
 * call is only valid after a call to read_object().
 */
42
inline bool BamReader::is_eof(void) const;

1148 7 resolve 0 4 1974 18 BamReader::resolve 0 1 169 565
/**
 * This may be called at any time during processing of the Bam file to resolve
 * all the known pointers so far.  It is usually called at the end of the
 * processing, after all objects have been read, which is generally the best
 * time to call it.
 *
 * This must be called at least once after reading a particular object via
 * get_object() in order to validate that object.
 *
 * The return value is true if all objects have been resolved, or false if
 * some objects are still outstanding (in which case you will need to call
 * resolve() again later).
 */
30
bool BamReader::resolve(void);

1149 14 change_pointer 0 4 1974 25 BamReader::change_pointer 0 1 170 406
/**
 * Indicates that an object recently read from the bam stream should be
 * replaced with a new object.  Any future occurrences of the original object
 * in the stream will henceforth return the new object instead.
 *
 * The return value is true if the replacement was successfully made, or false
 * if the object was not read from the stream (or if change_pointer had
 * already been called on it).
 */
100
bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer);

1150 18 get_file_major_ver 0 4 1974 29 BamReader::get_file_major_ver 0 1 171 81
/**
 * Returns the major version number of the Bam file currently being read.
 */
53
inline int BamReader::get_file_major_ver(void) const;

1151 18 get_file_minor_ver 0 4 1974 29 BamReader::get_file_minor_ver 0 1 172 81
/**
 * Returns the minor version number of the Bam file currently being read.
 */
53
inline int BamReader::get_file_minor_ver(void) const;

1152 15 get_file_endian 0 4 1974 26 BamReader::get_file_endian 0 1 173 254
/**
 * Returns the endian preference indicated by the Bam file currently being
 * read.  This does not imply that every number is stored using the indicated
 * convention, but individual objects may choose to respect this flag when
 * recording data.
 */
66
inline BamEnums::BamEndian BamReader::get_file_endian(void) const;

1153 24 get_file_stdfloat_double 0 4 1974 35 BamReader::get_file_stdfloat_double 0 1 174 220
/**
 * Returns true if the file stores all "standard" floats as 64-bit doubles, or
 * false if they are 32-bit floats.  This is determined by the compilation
 * flags of the version of Panda that generated this file.
 */
60
inline bool BamReader::get_file_stdfloat_double(void) const;

1154 21 get_current_major_ver 0 4 1974 32 BamReader::get_current_major_ver 0 1 175 174
/**
 * Returns the major version number of Bam files supported by the current code
 * base.  This must match get_file_major_ver() in order to successfully read a
 * file.
 */
56
inline int BamReader::get_current_major_ver(void) const;

1155 21 get_current_minor_ver 0 4 1974 32 BamReader::get_current_minor_ver 0 1 176 184
/**
 * Returns the minor version number of Bam files supported by the current code
 * base.  This must match or exceed get_file_minor_ver() in order to
 * successfully read a file.
 */
56
inline int BamReader::get_current_minor_ver(void) const;

1156 16 get_file_version 0 4 1974 27 BamReader::get_file_version 0 1 177 0
50
PyObject *BamReader::get_file_version(void) const;

1157 16 register_factory 0 4 1974 27 BamReader::register_factory 0 1 178 208
/**
 * Registers a factory function that is called when an object of the given
 * type is encountered within the .bam stream.
 *
 * @param user_data an optional pointer to be passed along to the function.
 */
75
static void BamReader::register_factory(TypeHandle handle, PyObject *func);

1158 9 BamWriter 0 4 1981 20 BamWriter::BamWriter 0 2 179 180 10
/**
 *
 */
120
explicit BamWriter::BamWriter(DatagramSink *target = nullptr);
inline BamWriter::BamWriter(BamWriter const &) = default;

1159 10 ~BamWriter 0 4 1981 21 BamWriter::~BamWriter 0 0 10
/**
 *
 */
28
BamWriter::~BamWriter(void);

1160 10 set_target 0 4 1981 21 BamWriter::set_target 0 1 181 153
/**
 * Changes the destination of future datagrams written by the BamWriter.  This
 * also implicitly calls init() if it has not already been called.
 */
49
void BamWriter::set_target(DatagramSink *target);

1161 10 get_target 0 4 1981 21 BamWriter::get_target 0 1 182 100
/**
 * Returns the current target of the BamWriter as set by set_target() or the
 * constructor.
 */
49
inline DatagramSink *BamWriter::get_target(void);

1162 4 init 0 4 1981 15 BamWriter::init 0 1 183 220
/**
 * Initializes the BamWriter prior to writing any objects to its output
 * stream.  This includes writing out the Bam header.
 *
 * This returns true if the BamWriter successfully initialized, false
 * otherwise.
 */
27
bool BamWriter::init(void);

1163 12 get_filename 0 4 1981 23 BamWriter::get_filename 0 1 184 197
/**
 * If a BAM is a file, then the BamWriter should contain the name of the file.
 * This enables the writer to convert pathnames in the BAM to relative to the
 * directory containing the BAM.
 */
59
inline Filename const &BamWriter::get_filename(void) const;

1164 12 write_object 0 4 1981 23 BamWriter::write_object 0 1 185 736
/**
 * Writes a single object to the Bam file, so that the
 * BamReader::read_object() can later correctly restore the object and all its
 * pointers.
 *
 * This implicitly also writes any additional objects this object references
 * (if they haven't already been written), so that pointers may be fully
 * resolved.
 *
 * This may be called repeatedly to write a sequence of objects to the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is written directly from the Bam file: the
 * root of the scene graph.  The remaining objects will all be written
 * recursively by the first object.
 *
 * Returns true if the object is successfully written, false otherwise.
 */
55
bool BamWriter::write_object(TypedWritable const *obj);

1165 10 has_object 0 4 1981 21 BamWriter::has_object 0 1 186 170
/**
 * Returns true if the object has previously been written (or at least
 * requested to be written) to the bam file, or false if we've never heard of
 * it before.
 */
59
bool BamWriter::has_object(TypedWritable const *obj) const;

1166 5 flush 0 4 1981 16 BamWriter::flush 0 1 187 85
/**
 * Ensures that all data written thus far is manifested on the output stream.
 */
28
void BamWriter::flush(void);

1167 18 get_file_major_ver 0 4 1981 29 BamWriter::get_file_major_ver 0 1 188 84
/**
 * Returns the major version number of the Bam file currently being written.
 */
53
inline int BamWriter::get_file_major_ver(void) const;

1168 18 get_file_minor_ver 0 4 1981 29 BamWriter::get_file_minor_ver 0 1 189 84
/**
 * Returns the minor version number of the Bam file currently being written.
 */
53
inline int BamWriter::get_file_minor_ver(void) const;

1169 18 set_file_minor_ver 0 4 1981 29 BamWriter::set_file_minor_ver 0 1 190 232
/**
 * Changes the minor .bam version to write.  This should be called before
 * init().  Each Panda version has only a fairly narrow range of versions it
 * is able to write; consult the .bam documentation for more information.
 */
57
inline void BamWriter::set_file_minor_ver(int minor_ver);

1170 15 get_file_endian 0 4 1981 26 BamWriter::get_file_endian 0 1 191 257
/**
 * Returns the endian preference indicated by the Bam file currently being
 * written.  This does not imply that every number is stored using the
 * indicated convention, but individual objects may choose to respect this
 * flag when recording data.
 */
66
inline BamEnums::BamEndian BamWriter::get_file_endian(void) const;

1171 24 get_file_stdfloat_double 0 4 1981 35 BamWriter::get_file_stdfloat_double 0 1 192 248
/**
 * Returns true if the file will store all "standard" floats as 64-bit
 * doubles, or false if they are 32-bit floats.  This isn't runtime settable;
 * it's based on the compilation flags of the version of Panda that generated
 * this file.
 */
60
inline bool BamWriter::get_file_stdfloat_double(void) const;

1172 21 get_file_texture_mode 0 4 1981 32 BamWriter::get_file_texture_mode 0 1 193 196
/**
 * Returns the BamTextureMode preference indicated by the Bam file currently
 * being written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */
77
inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const;

1173 21 set_file_texture_mode 0 4 1981 32 BamWriter::set_file_texture_mode 0 1 194 187
/**
 * Changes the BamTextureMode preference for the Bam file currently being
 * written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */
89
inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode);

1174 13 get_root_node 0 4 1981 24 BamWriter::get_root_node 0 1 195 165
/**
 * Returns the root node of the part of the scene graph we are currently
 * writing out.  This is used for determining what to make NodePaths relative
 * to.
 */
59
inline TypedWritable *BamWriter::get_root_node(void) const;

1175 13 set_root_node 0 4 1981 24 BamWriter::set_root_node 0 1 196 160
/**
 * Sets the root node of the part of the scene graph we are currently writing
 * out.  NodePaths written to this bam file will be relative to this node.
 */
63
inline void BamWriter::set_root_node(TypedWritable *root_node);

1176 7 BitMask 0 4 1984 32 BitMask< uint16_t, 16 >::BitMask 0 3 197 198 199 0
215
constexpr BitMask< uint16_t, 16 >::BitMask(void) = default;
inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value);
inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &) = default;

1177 6 all_on 0 4 1984 31 BitMask< uint16_t, 16 >::all_on 0 1 200 0
76
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void);

1178 7 all_off 0 4 1984 32 BitMask< uint16_t, 16 >::all_off 0 1 201 0
77
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void);

1179 8 lower_on 0 4 1984 33 BitMask< uint16_t, 16 >::lower_on 0 1 202 0
85
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits);

1180 3 bit 0 4 1984 28 BitMask< uint16_t, 16 >::bit 0 1 203 0
78
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index);

1181 5 range 0 4 1984 30 BitMask< uint16_t, 16 >::range 0 1 204 0
92
static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size);

1182 16 has_max_num_bits 0 4 1984 41 BitMask< uint16_t, 16 >::has_max_num_bits 0 1 205 0
70
static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void);

1183 16 get_max_num_bits 0 4 1984 41 BitMask< uint16_t, 16 >::get_max_num_bits 0 1 206 0
69
static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void);

1184 12 get_num_bits 0 4 1984 37 BitMask< uint16_t, 16 >::get_num_bits 0 1 207 0
64
constexpr int BitMask< uint16_t, 16 >::get_num_bits(void) const;

1185 7 get_bit 0 4 1984 32 BitMask< uint16_t, 16 >::get_bit 0 1 208 0
62
inline bool BitMask< uint16_t, 16 >::get_bit(int index) const;

1186 7 set_bit 0 4 1984 32 BitMask< uint16_t, 16 >::set_bit 0 1 209 0
56
inline void BitMask< uint16_t, 16 >::set_bit(int index);

1187 9 clear_bit 0 4 1984 34 BitMask< uint16_t, 16 >::clear_bit 0 1 210 0
58
inline void BitMask< uint16_t, 16 >::clear_bit(int index);

1188 10 set_bit_to 0 4 1984 35 BitMask< uint16_t, 16 >::set_bit_to 0 1 211 0
71
inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value);

1189 7 is_zero 0 4 1984 32 BitMask< uint16_t, 16 >::is_zero 0 1 212 0
57
inline bool BitMask< uint16_t, 16 >::is_zero(void) const;

1190 9 is_all_on 0 4 1984 34 BitMask< uint16_t, 16 >::is_all_on 0 1 213 0
59
inline bool BitMask< uint16_t, 16 >::is_all_on(void) const;

1191 7 extract 0 4 1984 32 BitMask< uint16_t, 16 >::extract 0 1 214 0
78
inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const;

1192 5 store 0 4 1984 30 BitMask< uint16_t, 16 >::store 0 1 215 0
82
inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size);

1193 10 has_any_of 0 4 1984 35 BitMask< uint16_t, 16 >::has_any_of 0 1 216 0
77
inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const;

1194 10 has_all_of 0 4 1984 35 BitMask< uint16_t, 16 >::has_all_of 0 1 217 0
77
inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const;

1195 9 set_range 0 4 1984 34 BitMask< uint16_t, 16 >::set_range 0 1 218 0
70
inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size);

1196 11 clear_range 0 4 1984 36 BitMask< uint16_t, 16 >::clear_range 0 1 219 0
72
inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size);

1197 12 set_range_to 0 4 1984 37 BitMask< uint16_t, 16 >::set_range_to 0 1 220 0
85
inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size);

1198 8 get_word 0 4 1984 33 BitMask< uint16_t, 16 >::get_word 0 1 221 0
62
inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const;

1199 8 set_word 0 4 1984 33 BitMask< uint16_t, 16 >::set_word 0 1 222 0
62
inline void BitMask< uint16_t, 16 >::set_word(uint16_t value);

1200 15 get_num_on_bits 0 4 1984 40 BitMask< uint16_t, 16 >::get_num_on_bits 0 1 223 0
64
inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const;

1201 16 get_num_off_bits 0 4 1984 41 BitMask< uint16_t, 16 >::get_num_off_bits 0 1 224 0
65
inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const;

1202 17 get_lowest_on_bit 0 4 1984 42 BitMask< uint16_t, 16 >::get_lowest_on_bit 0 1 225 0
66
inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const;

1203 18 get_lowest_off_bit 0 4 1984 43 BitMask< uint16_t, 16 >::get_lowest_off_bit 0 1 226 0
67
inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const;

1204 18 get_highest_on_bit 0 4 1984 43 BitMask< uint16_t, 16 >::get_highest_on_bit 0 1 227 0
67
inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const;

1205 19 get_highest_off_bit 0 4 1984 44 BitMask< uint16_t, 16 >::get_highest_off_bit 0 1 228 0
68
inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const;

1206 29 get_next_higher_different_bit 0 4 1984 54 BitMask< uint16_t, 16 >::get_next_higher_different_bit 0 1 229 0
85
inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const;

1207 15 invert_in_place 0 4 1984 40 BitMask< uint16_t, 16 >::invert_in_place 0 1 230 0
59
inline void BitMask< uint16_t, 16 >::invert_in_place(void);

1208 18 has_bits_in_common 0 4 1984 43 BitMask< uint16_t, 16 >::has_bits_in_common 0 1 231 0
100
inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const;

1209 5 clear 0 4 1984 30 BitMask< uint16_t, 16 >::clear 0 1 232 0
49
inline void BitMask< uint16_t, 16 >::clear(void);

1210 6 output 0 4 1984 31 BitMask< uint16_t, 16 >::output 0 1 233 0
62
void BitMask< uint16_t, 16 >::output(std::ostream &out) const;

1211 13 output_binary 0 4 1984 38 BitMask< uint16_t, 16 >::output_binary 0 1 234 0
91
void BitMask< uint16_t, 16 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1212 10 output_hex 0 4 1984 35 BitMask< uint16_t, 16 >::output_hex 0 1 235 0
88
void BitMask< uint16_t, 16 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1213 5 write 0 4 1984 30 BitMask< uint16_t, 16 >::write 0 1 236 0
83
void BitMask< uint16_t, 16 >::write(std::ostream &out, int indent_level = 0) const;

1214 11 operator == 0 4 1984 36 BitMask< uint16_t, 16 >::operator == 0 1 237 0
93
inline bool BitMask< uint16_t, 16 >::operator ==(BitMask< uint16_t, 16 > const &other) const;

1215 11 operator != 0 4 1984 36 BitMask< uint16_t, 16 >::operator != 0 1 238 0
93
inline bool BitMask< uint16_t, 16 >::operator !=(BitMask< uint16_t, 16 > const &other) const;

1216 10 operator < 0 4 1984 35 BitMask< uint16_t, 16 >::operator < 0 1 239 0
92
inline bool BitMask< uint16_t, 16 >::operator <(BitMask< uint16_t, 16 > const &other) const;

1217 10 compare_to 0 4 1984 35 BitMask< uint16_t, 16 >::compare_to 0 1 240 0
91
inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const;

1218 10 operator & 0 4 1984 35 BitMask< uint16_t, 16 >::operator & 0 1 241 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator &(BitMask< uint16_t, 16 > const &other) const;

1219 10 operator | 0 4 1984 35 BitMask< uint16_t, 16 >::operator | 0 1 242 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator |(BitMask< uint16_t, 16 > const &other) const;

1220 10 operator ^ 0 4 1984 35 BitMask< uint16_t, 16 >::operator ^ 0 1 243 0
111
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ^(BitMask< uint16_t, 16 > const &other) const;

1221 10 operator ~ 0 68 1984 35 BitMask< uint16_t, 16 >::operator ~ 0 1 244 0
79
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ~(void) const;

1222 11 operator << 0 4 1984 36 BitMask< uint16_t, 16 >::operator << 0 1 245 0
85
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator <<(int shift) const;

1223 11 operator >> 0 4 1984 36 BitMask< uint16_t, 16 >::operator >> 0 1 246 0
85
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator >>(int shift) const;

1224 11 operator &= 0 4 1984 36 BitMask< uint16_t, 16 >::operator &= 0 1 247 0
87
inline void BitMask< uint16_t, 16 >::operator &=(BitMask< uint16_t, 16 > const &other);

1225 11 operator |= 0 4 1984 36 BitMask< uint16_t, 16 >::operator |= 0 1 248 0
87
inline void BitMask< uint16_t, 16 >::operator |=(BitMask< uint16_t, 16 > const &other);

1226 11 operator ^= 0 4 1984 36 BitMask< uint16_t, 16 >::operator ^= 0 1 249 0
87
inline void BitMask< uint16_t, 16 >::operator ^=(BitMask< uint16_t, 16 > const &other);

1227 12 operator <<= 0 4 1984 37 BitMask< uint16_t, 16 >::operator <<= 0 1 250 0
61
inline void BitMask< uint16_t, 16 >::operator <<=(int shift);

1228 12 operator >>= 0 4 1984 37 BitMask< uint16_t, 16 >::operator >>= 0 1 251 0
61
inline void BitMask< uint16_t, 16 >::operator >>=(int shift);

1229 19 flood_down_in_place 0 4 1984 44 BitMask< uint16_t, 16 >::flood_down_in_place 0 1 252 0
63
inline void BitMask< uint16_t, 16 >::flood_down_in_place(void);

1230 17 flood_up_in_place 0 4 1984 42 BitMask< uint16_t, 16 >::flood_up_in_place 0 1 253 0
61
inline void BitMask< uint16_t, 16 >::flood_up_in_place(void);

1231 15 flood_bits_down 0 4 1984 40 BitMask< uint16_t, 16 >::flood_bits_down 0 1 254 0
84
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const;

1232 13 flood_bits_up 0 4 1984 38 BitMask< uint16_t, 16 >::flood_bits_up 0 1 255 0
82
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const;

1233 21 keep_next_highest_bit 0 4 1984 46 BitMask< uint16_t, 16 >::keep_next_highest_bit 0 3 256 257 258 0
309
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const;

1234 20 keep_next_lowest_bit 0 4 1984 45 BitMask< uint16_t, 16 >::keep_next_lowest_bit 0 3 259 260 261 0
306
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const;

1235 7 get_key 0 4 1984 32 BitMask< uint16_t, 16 >::get_key 0 1 262 0
56
inline int BitMask< uint16_t, 16 >::get_key(void) const;

1236 8 __bool__ 0 4 1984 33 BitMask< uint16_t, 16 >::__bool__ 0 1 263 0
51
bool BitMask< uint16_t, 16 >::__bool__(void) const;

1237 7 __int__ 0 4 1984 32 BitMask< uint16_t, 16 >::__int__ 0 1 264 0
55
PyObject *BitMask< uint16_t, 16 >::__int__(void) const;

1238 10 __reduce__ 0 4 1984 35 BitMask< uint16_t, 16 >::__reduce__ 0 1 265 0
68
PyObject *BitMask< uint16_t, 16 >::__reduce__(PyObject *self) const;

1239 14 get_class_type 0 4 1984 39 BitMask< uint16_t, 16 >::get_class_type 0 1 266 0
64
static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void);

1240 8 ~BitMask 0 4 1984 33 BitMask< uint16_t, 16 >::~BitMask 0 0 0
40
BitMask< uint16_t, 16 >::~BitMask(void);

1241 7 BitMask 0 4 1986 32 BitMask< uint32_t, 32 >::BitMask 0 3 267 268 269 0
215
constexpr BitMask< uint32_t, 32 >::BitMask(void) = default;
inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value);
inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &) = default;

1242 6 all_on 0 4 1986 31 BitMask< uint32_t, 32 >::all_on 0 1 270 0
76
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void);

1243 7 all_off 0 4 1986 32 BitMask< uint32_t, 32 >::all_off 0 1 271 0
77
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void);

1244 8 lower_on 0 4 1986 33 BitMask< uint32_t, 32 >::lower_on 0 1 272 0
85
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits);

1245 3 bit 0 4 1986 28 BitMask< uint32_t, 32 >::bit 0 1 273 0
78
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index);

1246 5 range 0 4 1986 30 BitMask< uint32_t, 32 >::range 0 1 274 0
92
static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size);

1247 16 has_max_num_bits 0 4 1986 41 BitMask< uint32_t, 32 >::has_max_num_bits 0 1 275 0
70
static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void);

1248 16 get_max_num_bits 0 4 1986 41 BitMask< uint32_t, 32 >::get_max_num_bits 0 1 276 0
69
static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void);

1249 12 get_num_bits 0 4 1986 37 BitMask< uint32_t, 32 >::get_num_bits 0 1 277 0
64
constexpr int BitMask< uint32_t, 32 >::get_num_bits(void) const;

1250 7 get_bit 0 4 1986 32 BitMask< uint32_t, 32 >::get_bit 0 1 278 0
62
inline bool BitMask< uint32_t, 32 >::get_bit(int index) const;

1251 7 set_bit 0 4 1986 32 BitMask< uint32_t, 32 >::set_bit 0 1 279 0
56
inline void BitMask< uint32_t, 32 >::set_bit(int index);

1252 9 clear_bit 0 4 1986 34 BitMask< uint32_t, 32 >::clear_bit 0 1 280 0
58
inline void BitMask< uint32_t, 32 >::clear_bit(int index);

1253 10 set_bit_to 0 4 1986 35 BitMask< uint32_t, 32 >::set_bit_to 0 1 281 0
71
inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value);

1254 7 is_zero 0 4 1986 32 BitMask< uint32_t, 32 >::is_zero 0 1 282 0
57
inline bool BitMask< uint32_t, 32 >::is_zero(void) const;

1255 9 is_all_on 0 4 1986 34 BitMask< uint32_t, 32 >::is_all_on 0 1 283 0
59
inline bool BitMask< uint32_t, 32 >::is_all_on(void) const;

1256 7 extract 0 4 1986 32 BitMask< uint32_t, 32 >::extract 0 1 284 0
78
inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const;

1257 5 store 0 4 1986 30 BitMask< uint32_t, 32 >::store 0 1 285 0
82
inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size);

1258 10 has_any_of 0 4 1986 35 BitMask< uint32_t, 32 >::has_any_of 0 1 286 0
77
inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const;

1259 10 has_all_of 0 4 1986 35 BitMask< uint32_t, 32 >::has_all_of 0 1 287 0
77
inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const;

1260 9 set_range 0 4 1986 34 BitMask< uint32_t, 32 >::set_range 0 1 288 0
70
inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size);

1261 11 clear_range 0 4 1986 36 BitMask< uint32_t, 32 >::clear_range 0 1 289 0
72
inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size);

1262 12 set_range_to 0 4 1986 37 BitMask< uint32_t, 32 >::set_range_to 0 1 290 0
85
inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size);

1263 8 get_word 0 4 1986 33 BitMask< uint32_t, 32 >::get_word 0 1 291 0
62
inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const;

1264 8 set_word 0 4 1986 33 BitMask< uint32_t, 32 >::set_word 0 1 292 0
62
inline void BitMask< uint32_t, 32 >::set_word(uint32_t value);

1265 15 get_num_on_bits 0 4 1986 40 BitMask< uint32_t, 32 >::get_num_on_bits 0 1 293 0
64
inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const;

1266 16 get_num_off_bits 0 4 1986 41 BitMask< uint32_t, 32 >::get_num_off_bits 0 1 294 0
65
inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const;

1267 17 get_lowest_on_bit 0 4 1986 42 BitMask< uint32_t, 32 >::get_lowest_on_bit 0 1 295 0
66
inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const;

1268 18 get_lowest_off_bit 0 4 1986 43 BitMask< uint32_t, 32 >::get_lowest_off_bit 0 1 296 0
67
inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const;

1269 18 get_highest_on_bit 0 4 1986 43 BitMask< uint32_t, 32 >::get_highest_on_bit 0 1 297 0
67
inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const;

1270 19 get_highest_off_bit 0 4 1986 44 BitMask< uint32_t, 32 >::get_highest_off_bit 0 1 298 0
68
inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const;

1271 29 get_next_higher_different_bit 0 4 1986 54 BitMask< uint32_t, 32 >::get_next_higher_different_bit 0 1 299 0
85
inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const;

1272 15 invert_in_place 0 4 1986 40 BitMask< uint32_t, 32 >::invert_in_place 0 1 300 0
59
inline void BitMask< uint32_t, 32 >::invert_in_place(void);

1273 18 has_bits_in_common 0 4 1986 43 BitMask< uint32_t, 32 >::has_bits_in_common 0 1 301 0
100
inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const;

1274 5 clear 0 4 1986 30 BitMask< uint32_t, 32 >::clear 0 1 302 0
49
inline void BitMask< uint32_t, 32 >::clear(void);

1275 6 output 0 4 1986 31 BitMask< uint32_t, 32 >::output 0 1 303 0
62
void BitMask< uint32_t, 32 >::output(std::ostream &out) const;

1276 13 output_binary 0 4 1986 38 BitMask< uint32_t, 32 >::output_binary 0 1 304 0
91
void BitMask< uint32_t, 32 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1277 10 output_hex 0 4 1986 35 BitMask< uint32_t, 32 >::output_hex 0 1 305 0
88
void BitMask< uint32_t, 32 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1278 5 write 0 4 1986 30 BitMask< uint32_t, 32 >::write 0 1 306 0
83
void BitMask< uint32_t, 32 >::write(std::ostream &out, int indent_level = 0) const;

1279 11 operator == 0 4 1986 36 BitMask< uint32_t, 32 >::operator == 0 1 307 0
93
inline bool BitMask< uint32_t, 32 >::operator ==(BitMask< uint32_t, 32 > const &other) const;

1280 11 operator != 0 4 1986 36 BitMask< uint32_t, 32 >::operator != 0 1 308 0
93
inline bool BitMask< uint32_t, 32 >::operator !=(BitMask< uint32_t, 32 > const &other) const;

1281 10 operator < 0 4 1986 35 BitMask< uint32_t, 32 >::operator < 0 1 309 0
92
inline bool BitMask< uint32_t, 32 >::operator <(BitMask< uint32_t, 32 > const &other) const;

1282 10 compare_to 0 4 1986 35 BitMask< uint32_t, 32 >::compare_to 0 1 310 0
91
inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const;

1283 10 operator & 0 4 1986 35 BitMask< uint32_t, 32 >::operator & 0 1 311 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator &(BitMask< uint32_t, 32 > const &other) const;

1284 10 operator | 0 4 1986 35 BitMask< uint32_t, 32 >::operator | 0 1 312 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator |(BitMask< uint32_t, 32 > const &other) const;

1285 10 operator ^ 0 4 1986 35 BitMask< uint32_t, 32 >::operator ^ 0 1 313 0
111
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ^(BitMask< uint32_t, 32 > const &other) const;

1286 10 operator ~ 0 68 1986 35 BitMask< uint32_t, 32 >::operator ~ 0 1 314 0
79
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ~(void) const;

1287 11 operator << 0 4 1986 36 BitMask< uint32_t, 32 >::operator << 0 1 315 0
85
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator <<(int shift) const;

1288 11 operator >> 0 4 1986 36 BitMask< uint32_t, 32 >::operator >> 0 1 316 0
85
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator >>(int shift) const;

1289 11 operator &= 0 4 1986 36 BitMask< uint32_t, 32 >::operator &= 0 1 317 0
87
inline void BitMask< uint32_t, 32 >::operator &=(BitMask< uint32_t, 32 > const &other);

1290 11 operator |= 0 4 1986 36 BitMask< uint32_t, 32 >::operator |= 0 1 318 0
87
inline void BitMask< uint32_t, 32 >::operator |=(BitMask< uint32_t, 32 > const &other);

1291 11 operator ^= 0 4 1986 36 BitMask< uint32_t, 32 >::operator ^= 0 1 319 0
87
inline void BitMask< uint32_t, 32 >::operator ^=(BitMask< uint32_t, 32 > const &other);

1292 12 operator <<= 0 4 1986 37 BitMask< uint32_t, 32 >::operator <<= 0 1 320 0
61
inline void BitMask< uint32_t, 32 >::operator <<=(int shift);

1293 12 operator >>= 0 4 1986 37 BitMask< uint32_t, 32 >::operator >>= 0 1 321 0
61
inline void BitMask< uint32_t, 32 >::operator >>=(int shift);

1294 19 flood_down_in_place 0 4 1986 44 BitMask< uint32_t, 32 >::flood_down_in_place 0 1 322 0
63
inline void BitMask< uint32_t, 32 >::flood_down_in_place(void);

1295 17 flood_up_in_place 0 4 1986 42 BitMask< uint32_t, 32 >::flood_up_in_place 0 1 323 0
61
inline void BitMask< uint32_t, 32 >::flood_up_in_place(void);

1296 15 flood_bits_down 0 4 1986 40 BitMask< uint32_t, 32 >::flood_bits_down 0 1 324 0
84
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const;

1297 13 flood_bits_up 0 4 1986 38 BitMask< uint32_t, 32 >::flood_bits_up 0 1 325 0
82
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const;

1298 21 keep_next_highest_bit 0 4 1986 46 BitMask< uint32_t, 32 >::keep_next_highest_bit 0 3 326 327 328 0
309
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const;

1299 20 keep_next_lowest_bit 0 4 1986 45 BitMask< uint32_t, 32 >::keep_next_lowest_bit 0 3 329 330 331 0
306
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const;

1300 7 get_key 0 4 1986 32 BitMask< uint32_t, 32 >::get_key 0 1 332 0
56
inline int BitMask< uint32_t, 32 >::get_key(void) const;

1301 8 __bool__ 0 4 1986 33 BitMask< uint32_t, 32 >::__bool__ 0 1 333 0
51
bool BitMask< uint32_t, 32 >::__bool__(void) const;

1302 7 __int__ 0 4 1986 32 BitMask< uint32_t, 32 >::__int__ 0 1 334 0
55
PyObject *BitMask< uint32_t, 32 >::__int__(void) const;

1303 10 __reduce__ 0 4 1986 35 BitMask< uint32_t, 32 >::__reduce__ 0 1 335 0
68
PyObject *BitMask< uint32_t, 32 >::__reduce__(PyObject *self) const;

1304 14 get_class_type 0 4 1986 39 BitMask< uint32_t, 32 >::get_class_type 0 1 336 0
64
static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void);

1305 8 ~BitMask 0 4 1986 33 BitMask< uint32_t, 32 >::~BitMask 0 0 0
40
BitMask< uint32_t, 32 >::~BitMask(void);

1306 7 BitMask 0 4 1988 32 BitMask< uint64_t, 64 >::BitMask 0 3 337 338 339 0
215
constexpr BitMask< uint64_t, 64 >::BitMask(void) = default;
inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value);
inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &) = default;

1307 6 all_on 0 4 1988 31 BitMask< uint64_t, 64 >::all_on 0 1 340 0
76
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void);

1308 7 all_off 0 4 1988 32 BitMask< uint64_t, 64 >::all_off 0 1 341 0
77
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void);

1309 8 lower_on 0 4 1988 33 BitMask< uint64_t, 64 >::lower_on 0 1 342 0
85
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits);

1310 3 bit 0 4 1988 28 BitMask< uint64_t, 64 >::bit 0 1 343 0
78
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index);

1311 5 range 0 4 1988 30 BitMask< uint64_t, 64 >::range 0 1 344 0
92
static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size);

1312 16 has_max_num_bits 0 4 1988 41 BitMask< uint64_t, 64 >::has_max_num_bits 0 1 345 0
70
static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void);

1313 16 get_max_num_bits 0 4 1988 41 BitMask< uint64_t, 64 >::get_max_num_bits 0 1 346 0
69
static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void);

1314 12 get_num_bits 0 4 1988 37 BitMask< uint64_t, 64 >::get_num_bits 0 1 347 0
64
constexpr int BitMask< uint64_t, 64 >::get_num_bits(void) const;

1315 7 get_bit 0 4 1988 32 BitMask< uint64_t, 64 >::get_bit 0 1 348 0
62
inline bool BitMask< uint64_t, 64 >::get_bit(int index) const;

1316 7 set_bit 0 4 1988 32 BitMask< uint64_t, 64 >::set_bit 0 1 349 0
56
inline void BitMask< uint64_t, 64 >::set_bit(int index);

1317 9 clear_bit 0 4 1988 34 BitMask< uint64_t, 64 >::clear_bit 0 1 350 0
58
inline void BitMask< uint64_t, 64 >::clear_bit(int index);

1318 10 set_bit_to 0 4 1988 35 BitMask< uint64_t, 64 >::set_bit_to 0 1 351 0
71
inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value);

1319 7 is_zero 0 4 1988 32 BitMask< uint64_t, 64 >::is_zero 0 1 352 0
57
inline bool BitMask< uint64_t, 64 >::is_zero(void) const;

1320 9 is_all_on 0 4 1988 34 BitMask< uint64_t, 64 >::is_all_on 0 1 353 0
59
inline bool BitMask< uint64_t, 64 >::is_all_on(void) const;

1321 7 extract 0 4 1988 32 BitMask< uint64_t, 64 >::extract 0 1 354 0
78
inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const;

1322 5 store 0 4 1988 30 BitMask< uint64_t, 64 >::store 0 1 355 0
82
inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size);

1323 10 has_any_of 0 4 1988 35 BitMask< uint64_t, 64 >::has_any_of 0 1 356 0
77
inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const;

1324 10 has_all_of 0 4 1988 35 BitMask< uint64_t, 64 >::has_all_of 0 1 357 0
77
inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const;

1325 9 set_range 0 4 1988 34 BitMask< uint64_t, 64 >::set_range 0 1 358 0
70
inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size);

1326 11 clear_range 0 4 1988 36 BitMask< uint64_t, 64 >::clear_range 0 1 359 0
72
inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size);

1327 12 set_range_to 0 4 1988 37 BitMask< uint64_t, 64 >::set_range_to 0 1 360 0
85
inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size);

1328 8 get_word 0 4 1988 33 BitMask< uint64_t, 64 >::get_word 0 1 361 0
62
inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const;

1329 8 set_word 0 4 1988 33 BitMask< uint64_t, 64 >::set_word 0 1 362 0
62
inline void BitMask< uint64_t, 64 >::set_word(uint64_t value);

1330 15 get_num_on_bits 0 4 1988 40 BitMask< uint64_t, 64 >::get_num_on_bits 0 1 363 0
64
inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const;

1331 16 get_num_off_bits 0 4 1988 41 BitMask< uint64_t, 64 >::get_num_off_bits 0 1 364 0
65
inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const;

1332 17 get_lowest_on_bit 0 4 1988 42 BitMask< uint64_t, 64 >::get_lowest_on_bit 0 1 365 0
66
inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const;

1333 18 get_lowest_off_bit 0 4 1988 43 BitMask< uint64_t, 64 >::get_lowest_off_bit 0 1 366 0
67
inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const;

1334 18 get_highest_on_bit 0 4 1988 43 BitMask< uint64_t, 64 >::get_highest_on_bit 0 1 367 0
67
inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const;

1335 19 get_highest_off_bit 0 4 1988 44 BitMask< uint64_t, 64 >::get_highest_off_bit 0 1 368 0
68
inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const;

1336 29 get_next_higher_different_bit 0 4 1988 54 BitMask< uint64_t, 64 >::get_next_higher_different_bit 0 1 369 0
85
inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const;

1337 15 invert_in_place 0 4 1988 40 BitMask< uint64_t, 64 >::invert_in_place 0 1 370 0
59
inline void BitMask< uint64_t, 64 >::invert_in_place(void);

1338 18 has_bits_in_common 0 4 1988 43 BitMask< uint64_t, 64 >::has_bits_in_common 0 1 371 0
100
inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const;

1339 5 clear 0 4 1988 30 BitMask< uint64_t, 64 >::clear 0 1 372 0
49
inline void BitMask< uint64_t, 64 >::clear(void);

1340 6 output 0 4 1988 31 BitMask< uint64_t, 64 >::output 0 1 373 0
62
void BitMask< uint64_t, 64 >::output(std::ostream &out) const;

1341 13 output_binary 0 4 1988 38 BitMask< uint64_t, 64 >::output_binary 0 1 374 0
91
void BitMask< uint64_t, 64 >::output_binary(std::ostream &out, int spaces_every = 4) const;

1342 10 output_hex 0 4 1988 35 BitMask< uint64_t, 64 >::output_hex 0 1 375 0
88
void BitMask< uint64_t, 64 >::output_hex(std::ostream &out, int spaces_every = 4) const;

1343 5 write 0 4 1988 30 BitMask< uint64_t, 64 >::write 0 1 376 0
83
void BitMask< uint64_t, 64 >::write(std::ostream &out, int indent_level = 0) const;

1344 11 operator == 0 4 1988 36 BitMask< uint64_t, 64 >::operator == 0 1 377 0
93
inline bool BitMask< uint64_t, 64 >::operator ==(BitMask< uint64_t, 64 > const &other) const;

1345 11 operator != 0 4 1988 36 BitMask< uint64_t, 64 >::operator != 0 1 378 0
93
inline bool BitMask< uint64_t, 64 >::operator !=(BitMask< uint64_t, 64 > const &other) const;

1346 10 operator < 0 4 1988 35 BitMask< uint64_t, 64 >::operator < 0 1 379 0
92
inline bool BitMask< uint64_t, 64 >::operator <(BitMask< uint64_t, 64 > const &other) const;

1347 10 compare_to 0 4 1988 35 BitMask< uint64_t, 64 >::compare_to 0 1 380 0
91
inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const;

1348 10 operator & 0 4 1988 35 BitMask< uint64_t, 64 >::operator & 0 1 381 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator &(BitMask< uint64_t, 64 > const &other) const;

1349 10 operator | 0 4 1988 35 BitMask< uint64_t, 64 >::operator | 0 1 382 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator |(BitMask< uint64_t, 64 > const &other) const;

1350 10 operator ^ 0 4 1988 35 BitMask< uint64_t, 64 >::operator ^ 0 1 383 0
111
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ^(BitMask< uint64_t, 64 > const &other) const;

1351 10 operator ~ 0 68 1988 35 BitMask< uint64_t, 64 >::operator ~ 0 1 384 0
79
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ~(void) const;

1352 11 operator << 0 4 1988 36 BitMask< uint64_t, 64 >::operator << 0 1 385 0
85
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator <<(int shift) const;

1353 11 operator >> 0 4 1988 36 BitMask< uint64_t, 64 >::operator >> 0 1 386 0
85
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator >>(int shift) const;

1354 11 operator &= 0 4 1988 36 BitMask< uint64_t, 64 >::operator &= 0 1 387 0
87
inline void BitMask< uint64_t, 64 >::operator &=(BitMask< uint64_t, 64 > const &other);

1355 11 operator |= 0 4 1988 36 BitMask< uint64_t, 64 >::operator |= 0 1 388 0
87
inline void BitMask< uint64_t, 64 >::operator |=(BitMask< uint64_t, 64 > const &other);

1356 11 operator ^= 0 4 1988 36 BitMask< uint64_t, 64 >::operator ^= 0 1 389 0
87
inline void BitMask< uint64_t, 64 >::operator ^=(BitMask< uint64_t, 64 > const &other);

1357 12 operator <<= 0 4 1988 37 BitMask< uint64_t, 64 >::operator <<= 0 1 390 0
61
inline void BitMask< uint64_t, 64 >::operator <<=(int shift);

1358 12 operator >>= 0 4 1988 37 BitMask< uint64_t, 64 >::operator >>= 0 1 391 0
61
inline void BitMask< uint64_t, 64 >::operator >>=(int shift);

1359 19 flood_down_in_place 0 4 1988 44 BitMask< uint64_t, 64 >::flood_down_in_place 0 1 392 0
63
inline void BitMask< uint64_t, 64 >::flood_down_in_place(void);

1360 17 flood_up_in_place 0 4 1988 42 BitMask< uint64_t, 64 >::flood_up_in_place 0 1 393 0
61
inline void BitMask< uint64_t, 64 >::flood_up_in_place(void);

1361 15 flood_bits_down 0 4 1988 40 BitMask< uint64_t, 64 >::flood_bits_down 0 1 394 0
84
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const;

1362 13 flood_bits_up 0 4 1988 38 BitMask< uint64_t, 64 >::flood_bits_up 0 1 395 0
82
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const;

1363 21 keep_next_highest_bit 0 4 1988 46 BitMask< uint64_t, 64 >::keep_next_highest_bit 0 3 396 397 398 0
309
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const;

1364 20 keep_next_lowest_bit 0 4 1988 45 BitMask< uint64_t, 64 >::keep_next_lowest_bit 0 3 399 400 401 0
306
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const;
inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const;

1365 7 get_key 0 4 1988 32 BitMask< uint64_t, 64 >::get_key 0 1 402 0
56
inline int BitMask< uint64_t, 64 >::get_key(void) const;

1366 8 __bool__ 0 4 1988 33 BitMask< uint64_t, 64 >::__bool__ 0 1 403 0
51
bool BitMask< uint64_t, 64 >::__bool__(void) const;

1367 7 __int__ 0 4 1988 32 BitMask< uint64_t, 64 >::__int__ 0 1 404 0
55
PyObject *BitMask< uint64_t, 64 >::__int__(void) const;

1368 10 __reduce__ 0 4 1988 35 BitMask< uint64_t, 64 >::__reduce__ 0 1 405 0
68
PyObject *BitMask< uint64_t, 64 >::__reduce__(PyObject *self) const;

1369 14 get_class_type 0 4 1988 39 BitMask< uint64_t, 64 >::get_class_type 0 1 406 0
64
static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void);

1370 8 ~BitMask 0 4 1988 33 BitMask< uint64_t, 64 >::~BitMask 0 0 0
40
BitMask< uint64_t, 64 >::~BitMask(void);

1371 8 BitArray 0 4 1991 18 BitArray::BitArray 0 4 407 408 409 410 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
174
inline BitArray::BitArray(void);
BitArray::BitArray(SparseArray const &from);
BitArray::BitArray(PyObject *init_value);
inline BitArray::BitArray(BitArray const &) = default;

1372 6 all_on 0 4 1991 16 BitArray::all_on 0 1 411 69
/**
 * Returns a BitArray with an infinite array of bits, all on.
 */
46
static inline BitArray BitArray::all_on(void);

1373 7 all_off 0 4 1991 17 BitArray::all_off 0 1 412 53
/**
 * Returns a BitArray whose bits are all off.
 */
47
static inline BitArray BitArray::all_off(void);

1374 8 lower_on 0 4 1991 18 BitArray::lower_on 0 1 413 62
/**
 * Returns a BitArray whose lower on_bits bits are on.
 */
55
static inline BitArray BitArray::lower_on(int on_bits);

1375 3 bit 0 4 1991 13 BitArray::bit 0 1 414 61
/**
 * Returns a BitArray with only the indicated bit on.
 */
48
static inline BitArray BitArray::bit(int index);

1376 5 range 0 4 1991 15 BitArray::range 0 1 415 76
/**
 * Returns a BitArray whose size bits, beginning at low_bit, are on.
 */
62
static inline BitArray BitArray::range(int low_bit, int size);

1377 16 has_max_num_bits 0 4 1991 26 BitArray::has_max_num_bits 0 1 416 0
55
static constexpr bool BitArray::has_max_num_bits(void);

1378 16 get_max_num_bits 0 4 1991 26 BitArray::get_max_num_bits 0 1 417 0
54
static constexpr int BitArray::get_max_num_bits(void);

1379 21 get_num_bits_per_word 0 4 1991 31 BitArray::get_num_bits_per_word 0 1 418 0
59
static constexpr int BitArray::get_num_bits_per_word(void);

1380 12 get_num_bits 0 4 1991 22 BitArray::get_num_bits 0 1 419 300
/**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */
54
inline std::size_t BitArray::get_num_bits(void) const;

1381 7 get_bit 0 4 1991 17 BitArray::get_bit 0 1 420 191
/**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */
47
inline bool BitArray::get_bit(int index) const;

1382 7 set_bit 0 4 1991 17 BitArray::set_bit 0 1 421 97
/**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
41
inline void BitArray::set_bit(int index);

1383 9 clear_bit 0 4 1991 19 BitArray::clear_bit 0 1 422 98
/**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
43
inline void BitArray::clear_bit(int index);

1384 10 set_bit_to 0 4 1991 20 BitArray::set_bit_to 0 1 423 84
/**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */
56
inline void BitArray::set_bit_to(int index, bool value);

1385 16 get_highest_bits 0 4 1991 26 BitArray::get_highest_bits 0 1 424 118
/**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */
51
inline bool BitArray::get_highest_bits(void) const;

1386 7 is_zero 0 4 1991 17 BitArray::is_zero 0 1 425 71
/**
 * Returns true if the entire bitmask is zero, false otherwise.
 */
35
bool BitArray::is_zero(void) const;

1387 9 is_all_on 0 4 1991 19 BitArray::is_all_on 0 1 426 70
/**
 * Returns true if the entire bitmask is one, false otherwise.
 */
37
bool BitArray::is_all_on(void) const;

1388 7 extract 0 4 1991 17 BitArray::extract 0 1 427 187
/**
 * Returns a word that represents only the indicated range of bits within this
 * BitArray, shifted to the least-significant position.  size must be <=
 * get_num_bits_per_word().
 */
73
inline BitArray::WordType BitArray::extract(int low_bit, int size) const;

1389 5 store 0 4 1991 15 BitArray::store 0 1 428 92
/**
 * Stores the indicated word into the indicated range of bits with this
 * BitArray.
 */
77
inline void BitArray::store(BitArray::WordType value, int low_bit, int size);

1390 10 has_any_of 0 4 1991 20 BitArray::has_any_of 0 1 429 82
/**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */
55
bool BitArray::has_any_of(int low_bit, int size) const;

1391 10 has_all_of 0 4 1991 20 BitArray::has_all_of 0 1 430 84
/**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */
55
bool BitArray::has_all_of(int low_bit, int size) const;

1392 9 set_range 0 4 1991 19 BitArray::set_range 0 1 431 47
/**
 * Sets the indicated range of bits on.
 */
48
void BitArray::set_range(int low_bit, int size);

1393 11 clear_range 0 4 1991 21 BitArray::clear_range 0 1 432 48
/**
 * Sets the indicated range of bits off.
 */
50
void BitArray::clear_range(int low_bit, int size);

1394 12 set_range_to 0 4 1991 22 BitArray::set_range_to 0 1 433 64
/**
 * Sets the indicated range of bits to either on or off.
 */
70
inline void BitArray::set_range_to(bool value, int low_bit, int size);

1395 15 get_num_on_bits 0 4 1991 25 BitArray::get_num_on_bits 0 1 434 127
/**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */
42
int BitArray::get_num_on_bits(void) const;

1396 16 get_num_off_bits 0 4 1991 26 BitArray::get_num_off_bits 0 1 435 127
/**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */
43
int BitArray::get_num_off_bits(void) const;

1397 17 get_lowest_on_bit 0 4 1991 27 BitArray::get_lowest_on_bit 0 1 436 101
/**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits.
 */
44
int BitArray::get_lowest_on_bit(void) const;

1398 18 get_lowest_off_bit 0 4 1991 28 BitArray::get_lowest_off_bit 0 1 437 101
/**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits.
 */
45
int BitArray::get_lowest_off_bit(void) const;

1399 18 get_highest_on_bit 0 4 1991 28 BitArray::get_highest_on_bit 0 1 438 143
/**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */
45
int BitArray::get_highest_on_bit(void) const;

1400 19 get_highest_off_bit 0 4 1991 29 BitArray::get_highest_off_bit 0 1 439 143
/**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */
46
int BitArray::get_highest_off_bit(void) const;

1401 29 get_next_higher_different_bit 0 4 1991 39 BitArray::get_next_higher_different_bit 0 1 440 287
/**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */
63
int BitArray::get_next_higher_different_bit(int low_bit) const;

1402 13 get_num_words 0 4 1991 23 BitArray::get_num_words 0 1 441 75
/**
 * Returns the number of possibly-unique words stored in the array.
 */
55
inline std::size_t BitArray::get_num_words(void) const;

1403 8 get_word 0 4 1991 18 BitArray::get_word 0 1 442 175
/**
 * Returns the nth word in the array.  It is valid for n to be greater than
 * get_num_words(), but the return value beyond get_num_words() will always be
 * the same.
 */
66
inline BitArray::MaskType BitArray::get_word(std::size_t n) const;

1404 8 set_word 0 4 1991 18 BitArray::set_word 0 1 443 113
/**
 * Replaces the nth word in the array.  If n >= get_num_words(), this
 * automatically extends the array.
 */
72
inline void BitArray::set_word(std::size_t n, BitArray::WordType value);

1405 15 invert_in_place 0 4 1991 25 BitArray::invert_in_place 0 1 444 90
/**
 * Inverts all the bits in the BitArray.  This is equivalent to array =
 * ~array.
 */
37
void BitArray::invert_in_place(void);

1406 18 has_bits_in_common 0 4 1991 28 BitArray::has_bits_in_common 0 1 445 178
/**
 * Returns true if this BitArray has any "one" bits in common with the other
 * one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */
63
bool BitArray::has_bits_in_common(BitArray const &other) const;

1407 5 clear 0 4 1991 15 BitArray::clear 0 1 446 49
/**
 * Sets all the bits in the BitArray off.
 */
34
inline void BitArray::clear(void);

1408 6 output 0 4 1991 16 BitArray::output 0 1 447 193
/**
 * Writes the BitArray out as a hex number.  For a BitArray, this is always
 * the same as output_hex(); it's too confusing for the output format to
 * change back and forth at runtime.
 */
47
void BitArray::output(std::ostream &out) const;

1409 13 output_binary 0 4 1991 23 BitArray::output_binary 0 1 448 83
/**
 * Writes the BitArray out as a binary number, with spaces every four bits.
 */
76
void BitArray::output_binary(std::ostream &out, int spaces_every = 4) const;

1410 10 output_hex 0 4 1991 20 BitArray::output_hex 0 1 449 93
/**
 * Writes the BitArray out as a hexadecimal number, with spaces every four
 * digits.
 */
73
void BitArray::output_hex(std::ostream &out, int spaces_every = 4) const;

1411 5 write 0 4 1991 15 BitArray::write 0 1 450 99
/**
 * Writes the BitArray out as a binary or a hex number, according to the
 * number of bits.
 */
68
void BitArray::write(std::ostream &out, int indent_level = 0) const;

1412 11 operator == 0 4 1991 21 BitArray::operator == 0 1 451 0
63
inline bool BitArray::operator ==(BitArray const &other) const;

1413 11 operator != 0 4 1991 21 BitArray::operator != 0 1 452 0
63
inline bool BitArray::operator !=(BitArray const &other) const;

1414 10 operator < 0 4 1991 20 BitArray::operator < 0 1 453 0
62
inline bool BitArray::operator <(BitArray const &other) const;

1415 10 compare_to 0 4 1991 20 BitArray::compare_to 0 1 454 233
/**
 * Returns a number less than zero if this BitArray sorts before the indicated
 * other BitArray, greater than zero if it sorts after, or 0 if they are
 * equivalent.  This is based on the same ordering defined by operator <.
 */
54
int BitArray::compare_to(BitArray const &other) const;

1416 10 operator & 0 4 1991 20 BitArray::operator & 0 1 455 0
66
inline BitArray BitArray::operator &(BitArray const &other) const;

1417 10 operator | 0 4 1991 20 BitArray::operator | 0 1 456 0
66
inline BitArray BitArray::operator |(BitArray const &other) const;

1418 10 operator ^ 0 4 1991 20 BitArray::operator ^ 0 1 457 0
66
inline BitArray BitArray::operator ^(BitArray const &other) const;

1419 10 operator ~ 0 68 1991 20 BitArray::operator ~ 0 1 458 0
49
inline BitArray BitArray::operator ~(void) const;

1420 11 operator << 0 4 1991 21 BitArray::operator << 0 1 459 0
55
inline BitArray BitArray::operator <<(int shift) const;

1421 11 operator >> 0 4 1991 21 BitArray::operator >> 0 1 460 0
55
inline BitArray BitArray::operator >>(int shift) const;

1422 11 operator &= 0 4 1991 21 BitArray::operator &= 0 1 461 0
50
void BitArray::operator &=(BitArray const &other);

1423 11 operator |= 0 4 1991 21 BitArray::operator |= 0 1 462 0
50
void BitArray::operator |=(BitArray const &other);

1424 11 operator ^= 0 4 1991 21 BitArray::operator ^= 0 1 463 0
50
void BitArray::operator ^=(BitArray const &other);

1425 12 operator <<= 0 4 1991 22 BitArray::operator <<= 0 1 464 0
39
void BitArray::operator <<=(int shift);

1426 12 operator >>= 0 4 1991 22 BitArray::operator >>= 0 1 465 0
39
void BitArray::operator >>=(int shift);

1427 8 __bool__ 0 4 1991 18 BitArray::__bool__ 0 1 466 0
36
bool BitArray::__bool__(void) const;

1428 12 __getstate__ 0 4 1991 22 BitArray::__getstate__ 0 1 467 0
45
PyObject *BitArray::__getstate__(void) const;

1429 12 __setstate__ 0 4 1991 22 BitArray::__setstate__ 0 1 468 0
45
void BitArray::__setstate__(PyObject *state);

1430 14 get_class_type 0 4 1991 24 BitArray::get_class_type 0 1 469 0
49
static TypeHandle BitArray::get_class_type(void);

1431 9 ~BitArray 0 4 1991 19 BitArray::~BitArray 0 0 0
26
BitArray::~BitArray(void);

1432 12 ButtonHandle 0 4 1993 26 ButtonHandle::ButtonHandle 0 4 470 471 472 473 758
// The default constructor must do nothing, because we can't guarantee
// ordering of static initializers.  If the constructor tried to initialize
// its value, it  might happen after the value had already been set
// previously by another static initializer!

/**
 * Constructs a ButtonHandle with the corresponding index number, which may
 * have been returned by an earlier call to ButtonHandle::get_index().
 */

/**
 * Constructs a ButtonHandle with the corresponding name, which is looked up
 * in the ButtonRegistry.  This exists for the purpose of being able to
 * automatically coerce a string into a ButtonHandle; for most purposes, you
 * should use either the static KeyboardButton/MouseButton getters or
 * ButtonRegistry::register_button().
 */
219
inline ButtonHandle::ButtonHandle(void) = default;
constexpr ButtonHandle::ButtonHandle(int index);
ButtonHandle::ButtonHandle(std::string const &name);
inline ButtonHandle::ButtonHandle(ButtonHandle const &) = default;

1433 11 operator == 0 4 1993 25 ButtonHandle::operator == 0 1 474 0
71
inline bool ButtonHandle::operator ==(ButtonHandle const &other) const;

1434 11 operator != 0 4 1993 25 ButtonHandle::operator != 0 1 475 0
71
inline bool ButtonHandle::operator !=(ButtonHandle const &other) const;

1435 10 operator < 0 4 1993 24 ButtonHandle::operator < 0 1 476 0
70
inline bool ButtonHandle::operator <(ButtonHandle const &other) const;

1436 11 operator <= 0 4 1993 25 ButtonHandle::operator <= 0 1 477 0
71
inline bool ButtonHandle::operator <=(ButtonHandle const &other) const;

1437 10 operator > 0 4 1993 24 ButtonHandle::operator > 0 1 478 0
70
inline bool ButtonHandle::operator >(ButtonHandle const &other) const;

1438 11 operator >= 0 4 1993 25 ButtonHandle::operator >= 0 1 479 0
71
inline bool ButtonHandle::operator >=(ButtonHandle const &other) const;

1439 10 compare_to 0 4 1993 24 ButtonHandle::compare_to 0 1 480 209
/**
 * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
 * number less than 0 if this type sorts before the other one, greater than
 * zero if it sorts after, 0 if they are equivalent.
 */
69
inline int ButtonHandle::compare_to(ButtonHandle const &other) const;

1440 8 get_hash 0 4 1993 22 ButtonHandle::get_hash 0 1 481 54
/**
 * Returns a hash code suitable for phash_map.
 */
54
inline std::size_t ButtonHandle::get_hash(void) const;

1441 8 get_name 0 4 1993 22 ButtonHandle::get_name 0 1 482 42
/**
 * Returns the name of the button.
 */
47
std::string ButtonHandle::get_name(void) const;

1442 20 has_ascii_equivalent 0 4 1993 34 ButtonHandle::has_ascii_equivalent 0 1 483 121
/**
 * Returns true if the button was created with an ASCII equivalent code (e.g.
 * for a standard keyboard button).
 */
59
inline bool ButtonHandle::has_ascii_equivalent(void) const;

1443 20 get_ascii_equivalent 0 4 1993 34 ButtonHandle::get_ascii_equivalent 0 1 484 109
/**
 * Returns the character code associated with the button, or '\0' if no ASCII
 * code was associated.
 */
59
inline char ButtonHandle::get_ascii_equivalent(void) const;

1444 9 get_alias 0 4 1993 23 ButtonHandle::get_alias 0 1 485 373
/**
 * Returns the alias (alternate name) associated with the button, if any, or
 * ButtonHandle::none() if the button has no alias.
 *
 * Each button is allowed to have one alias, and multiple different buttons
 * can refer to the same alias.  The alias should be the more general name for
 * the button, for instance, shift is an alias for lshift, but not vice-versa.
 */
49
ButtonHandle ButtonHandle::get_alias(void) const;

1445 7 matches 0 4 1993 21 ButtonHandle::matches 0 1 486 263
/**
 * Returns true if this ButtonHandle is the same as the other one, or if the
 * other one is an alias for this one.  (Does not return true if this button
 * is an alias for the other one, however.)
 *
 * This is a more general comparison than operator ==.
 */
67
inline bool ButtonHandle::matches(ButtonHandle const &other) const;

1446 9 get_index 0 4 1993 23 ButtonHandle::get_index 0 1 487 363
/**
 * Returns the integer index associated with this ButtonHandle.  Each
 * different ButtonHandle will have a different index.  However, you probably
 * shouldn't be using this method; you should just treat the ButtonHandles as
 * opaque classes.  This is provided for the convenience of non-C++ scripting
 * languages to build a hashtable of ButtonHandles.
 */
50
constexpr int ButtonHandle::get_index(void) const;

1447 6 output 0 4 1993 20 ButtonHandle::output 0 1 488 10
/**
 *
 */
58
inline void ButtonHandle::output(std::ostream &out) const;

1448 4 none 0 4 1993 18 ButtonHandle::none 0 1 489 0
55
static constexpr ButtonHandle ButtonHandle::none(void);

1449 22 operator typecast bool 0 132 1993 36 ButtonHandle::operator typecast bool 0 1 491 0
34
inline operator bool (void) const;

1450 14 get_class_type 0 4 1993 28 ButtonHandle::get_class_type 0 1 490 0
53
static TypeHandle ButtonHandle::get_class_type(void);

1451 13 ~ButtonHandle 0 4 1993 27 ButtonHandle::~ButtonHandle 0 0 0
34
ButtonHandle::~ButtonHandle(void);

1452 10 get_button 0 4 1997 26 ButtonRegistry::get_button 0 1 493 150
/**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, registers a new one and returns it.
 */
65
ButtonHandle ButtonRegistry::get_button(std::string const &name);

1453 11 find_button 0 4 1997 27 ButtonRegistry::find_button 0 1 494 144
/**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, returns ButtonHandle::none().
 */
66
ButtonHandle ButtonRegistry::find_button(std::string const &name);

1454 17 find_ascii_button 0 4 1997 33 ButtonRegistry::find_ascii_button 0 1 495 169
/**
 * Finds a ButtonHandle in the registry matching the indicated ASCII
 * equivalent character.  If there is no such ButtonHandle, returns
 * ButtonHandle::none().
 */
76
ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const;

1455 5 write 0 4 1997 21 ButtonRegistry::write 0 1 496 10
/**
 *
 */
52
void ButtonRegistry::write(std::ostream &out) const;

1456 3 ptr 0 4 1997 19 ButtonRegistry::ptr 0 1 497 134
// ptr() returns the pointer to the global ButtonRegistry object.

/**
 * Returns the pointer to the global ButtonRegistry object.
 */
56
static inline ButtonRegistry *ButtonRegistry::ptr(void);

1457 14 ButtonRegistry 0 4 1997 30 ButtonRegistry::ButtonRegistry 0 1 492 10
/**
 *
 */
72
inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default;

1458 15 ~ButtonRegistry 0 4 1997 31 ButtonRegistry::~ButtonRegistry 0 0 0
38
ButtonRegistry::~ButtonRegistry(void);

1459 15 get_num_buttons 0 4 1998 26 ButtonMap::get_num_buttons 0 1 500 76
/**
 * Returns the number of buttons that this button mapping specifies.
 */
58
inline std::size_t ButtonMap::get_num_buttons(void) const;

1460 14 get_raw_button 0 4 1998 25 ButtonMap::get_raw_button 0 1 501 76
/**
 * Returns the underlying raw button associated with the nth button.
 */
67
inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const;

1461 17 get_mapped_button 0 4 1998 28 ButtonMap::get_mapped_button 0 3 502 503 504 437
/**
 * Returns the nth mapped button, meaning the button that the nth raw button
 * is mapped to.
 */

/**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */

/**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */
229
inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const;
inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const;
inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const;

1462 23 get_mapped_button_label 0 4 1998 34 ButtonMap::get_mapped_button_label 0 3 505 506 507 837
/**
 * Returns the label associated with the nth mapped button, meaning the button
 * that the nth raw button is mapped to.
 */

/**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */

/**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */
265
inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const;
inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const;
inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const;

1463 6 output 0 4 1998 17 ButtonMap::output 0 1 508 10
/**
 *
 */
48
void ButtonMap::output(std::ostream &out) const;

1464 5 write 0 4 1998 16 ButtonMap::write 0 1 509 10
/**
 *
 */
69
void ButtonMap::write(std::ostream &out, int indent_level = 0) const;

1465 14 get_class_type 0 4 1998 25 ButtonMap::get_class_type 0 1 510 0
50
static TypeHandle ButtonMap::get_class_type(void);

1466 9 ButtonMap 0 4 1998 20 ButtonMap::ButtonMap 0 2 498 499 0
102
inline ButtonMap::ButtonMap(void) = default;
inline ButtonMap::ButtonMap(ButtonMap const &) = default;

1467 10 ~ButtonMap 0 4 1998 21 ButtonMap::~ButtonMap 0 0 0
28
ButtonMap::~ButtonMap(void);

1468 6 output 0 6 2000 22 CallbackObject::output 0 1 512 10
/**
 *
 */
61
virtual void CallbackObject::output(std::ostream &out) const;

1469 4 make 0 4 2000 20 CallbackObject::make 0 1 513 0
76
static PointerTo< CallbackObject > CallbackObject::make(PyObject *function);

1470 14 get_class_type 0 4 2000 30 CallbackObject::get_class_type 0 1 514 0
55
static TypeHandle CallbackObject::get_class_type(void);

1471 14 CallbackObject 0 4 2000 30 CallbackObject::CallbackObject 0 1 511 10
/**
 *
 */
72
inline CallbackObject::CallbackObject(CallbackObject const &) = default;

1472 15 ~CallbackObject 0 4 2000 31 CallbackObject::~CallbackObject 0 0 0
38
CallbackObject::~CallbackObject(void);

1473 19 get_cache_ref_count 0 4 2001 54 CachedTypedWritableReferenceCount::get_cache_ref_count 0 1 515 47
/**
 * Returns the current reference count.
 */
78
inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const;

1474 9 cache_ref 0 4 2001 44 CachedTypedWritableReferenceCount::cache_ref 0 1 516 108
/**
 * Explicitly increments the cache reference count and the normal reference
 * count simultaneously.
 */
69
inline void CachedTypedWritableReferenceCount::cache_ref(void) const;

1475 11 cache_unref 0 4 2001 46 CachedTypedWritableReferenceCount::cache_unref 0 1 517 202
/**
 * Explicitly decrements the cache reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */
71
inline bool CachedTypedWritableReferenceCount::cache_unref(void) const;

1476 24 test_ref_count_integrity 0 4 2001 59 CachedTypedWritableReferenceCount::test_ref_count_integrity 0 1 518 97
/**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */
84
inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const;

1477 14 get_class_type 0 4 2001 49 CachedTypedWritableReferenceCount::get_class_type 0 1 519 0
74
static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void);

1478 6 output 0 6 2002 20 CallbackData::output 0 1 520 10
/**
 *
 */
59
virtual void CallbackData::output(std::ostream &out) const;

1479 6 upcall 0 6 2002 20 CallbackData::upcall 0 1 521 159
/**
 * You should make this call during the callback if you want to continue the
 * normal function that would have been done in the absence of a callback.
 */
40
virtual void CallbackData::upcall(void);

1480 14 get_class_type 0 4 2002 28 CallbackData::get_class_type 0 1 522 0
53
static TypeHandle CallbackData::get_class_type(void);

1481 13 ~CallbackData 0 4 2002 27 CallbackData::~CallbackData 0 0 0
34
CallbackData::~CallbackData(void);

1482 20 PythonCallbackObject 0 4 2003 42 PythonCallbackObject::PythonCallbackObject 0 2 523 524 10
/**
 *
 */
177
PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct));
inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default;

1483 12 operator new 0 4 2003 34 PythonCallbackObject::operator new 0 1 525 0
144
inline void *PythonCallbackObject::operator new(std::size_t size);
inline void *PythonCallbackObject::operator new(std::size_t size, void *ptr);

1484 15 operator delete 0 4 2003 37 PythonCallbackObject::operator delete 0 0 0
128
inline void PythonCallbackObject::operator delete(void *ptr);
inline void PythonCallbackObject::operator delete(void *, void *);

1485 12 validate_ptr 0 4 2003 34 PythonCallbackObject::validate_ptr 0 0 0
71
static inline bool PythonCallbackObject::validate_ptr(void const *ptr);

1486 12 set_function 0 4 2003 34 PythonCallbackObject::set_function 0 1 526 126
/**
 * Replaces the function that is called for the callback.  runs.  The
 * parameter should be a Python callable object.
 */
60
void PythonCallbackObject::set_function(PyObject *function);

1487 12 get_function 0 4 2003 34 PythonCallbackObject::get_function 0 1 527 64
/**
 * Returns the function that is called for the callback.
 */
51
PyObject *PythonCallbackObject::get_function(void);

1488 10 __reduce__ 0 4 2003 32 PythonCallbackObject::__reduce__ 0 1 528 37
/**
 * Implements pickle support.
 */
55
PyObject *PythonCallbackObject::__reduce__(void) const;

1489 14 get_class_type 0 4 2003 36 PythonCallbackObject::get_class_type 0 1 529 0
61
static TypeHandle PythonCallbackObject::get_class_type(void);

1490 7 TimeVal 0 4 2004 16 TimeVal::TimeVal 0 2 530 531 10
/**
 *
 */
82
inline TimeVal::TimeVal(void);
inline TimeVal::TimeVal(TimeVal const &) = default;

1491 7 get_sec 0 4 2004 16 TimeVal::get_sec 0 1 532 10
/**
 *
 */
54
inline unsigned long int TimeVal::get_sec(void) const;

1492 8 get_usec 0 4 2004 17 TimeVal::get_usec 0 1 533 10
/**
 *
 */
55
inline unsigned long int TimeVal::get_usec(void) const;

1493 6 get_tv 0 20 2004 15 TimeVal::get_tv 0 0 44
getter for unsigned long int TimeVal::tv[2];
47
unsigned long int *TimeVal::get_tv(void) const;

1494 6 set_tv 0 36 2004 15 TimeVal::set_tv 0 0 44
setter for unsigned long int TimeVal::tv[2];
49
void TimeVal::set_tv(unsigned long int value[2]);

1495 8 ~TimeVal 0 4 2004 17 TimeVal::~TimeVal 0 0 0
24
TimeVal::~TimeVal(void);

1496 11 ClockObject 0 4 2007 24 ClockObject::ClockObject 0 2 534 535 22
/**
 *
 */

/**
 *
 */
126
ClockObject::ClockObject(ClockObject::Mode mode = ::ClockObject::M_normal);
ClockObject::ClockObject(ClockObject const &copy);

1497 8 set_mode 0 4 2007 21 ClockObject::set_mode 0 1 536 1841
/**
 * Changes the mode of the clock.  Normally, the clock is in mode M_normal.
 * In this mode, each call to tick() will set the value returned by
 * get_frame_time() to the current real time; thus, the clock simply reports
 * time advancing.
 *
 * Other possible modes:
 *
 * M_non_real_time - the clock ignores real time completely; at each call to
 * tick(), it pretends that exactly dt seconds have elapsed since the last
 * call to tick().  You may set the value of dt with set_dt() or
 * set_frame_rate().
 *
 * M_limited - the clock will run as fast as it can, as in M_normal, but will
 * not run faster than the rate specified by set_frame_rate().  If the
 * application would run faster than this rate, the clock will slow down the
 * application.
 *
 * M_integer - the clock will run as fast as it can, but the rate will be
 * constrained to be an integer multiple or divisor of the rate specified by
 * set_frame_rate().  The clock will slow down the application a bit to
 * guarantee this.
 *
 * M_integer_limited - a combination of M_limited and M_integer; the clock
 * will not run faster than set_frame_rate(), and if it runs slower, it will
 * run at a integer divisor of that rate.
 *
 * M_forced - the clock forces the application to run at the rate specified by
 * set_frame_rate().  If the application would run faster than this rate, the
 * clock will slow down the application; if the application would run slower
 * than this rate, the clock slows down time so that the application believes
 * it is running at the given rate.
 *
 * M_degrade - the clock runs at real time, but the application is slowed down
 * by a set factor of its frame rate, specified by set_degrade_factor().
 *
 * M_slave - the clock does not advance, but relies on the user to call
 * set_frame_time() and/or set_frame_count() each frame.
 */
51
void ClockObject::set_mode(ClockObject::Mode mode);

1498 8 get_mode 0 4 2007 21 ClockObject::get_mode 0 1 537 66
/**
 * Returns the current mode of the clock.  See set_mode().
 */
59
inline ClockObject::Mode ClockObject::get_mode(void) const;

1499 14 get_frame_time 0 4 2007 27 ClockObject::get_frame_time 0 1 538 350
/**
 * Returns the time in seconds as of the last time tick() was called
 * (typically, this will be as of the start of the current frame).
 *
 * This is generally the kind of time you want to ask for in most rendering
 * and animation contexts, since it's important that all of the animation for
 * a given frame remains in sync with each other.
 */
103
inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const;

1500 13 get_real_time 0 4 2007 26 ClockObject::get_real_time 0 1 539 434
/**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.  This is useful for doing real timing
 * measurements, e.g.  for performance statistics.
 *
 * This returns the most precise timer we have for short time intervals, but
 * it may tend to drift over the long haul.  If more accurate timekeeping is
 * needed over a long period of time, use get_long_time() instead.
 */
53
inline double ClockObject::get_real_time(void) const;

1501 13 get_long_time 0 4 2007 26 ClockObject::get_long_time 0 1 540 440
/**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.
 *
 * This is similar to get_real_time(), except that it uses the most accurate
 * counter we have over a long period of time, and so it is less likely to
 * drift.  However, it may not be very precise for measuring short intervals.
 * On Windows, for instace, this is only accurate to within about 55
 * milliseconds.
 */
53
inline double ClockObject::get_long_time(void) const;

1502 5 reset 0 4 2007 18 ClockObject::reset 0 1 541 75
/**
 * Simultaneously resets both the time and the frame count to zero.
 */
37
inline void ClockObject::reset(void);

1503 13 set_real_time 0 4 2007 26 ClockObject::set_real_time 0 1 542 316
/**
 * Resets the clock to the indicated time.  This changes only the real time of
 * the clock as reported by get_real_time(), but does not immediately change
 * the time reported by get_frame_time()--that will change after the next call
 * to tick().  Also see reset(), set_frame_time(), and set_frame_count().
 */
45
void ClockObject::set_real_time(double time);

1504 14 set_frame_time 0 4 2007 27 ClockObject::set_frame_time 0 1 543 215
/**
 * Changes the time as reported for the current frame to the indicated time.
 * Normally, the way to adjust the frame time is via tick(); this function is
 * provided only for occasional special adjustments.
 */
101
void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread());

1505 15 set_frame_count 0 4 2007 28 ClockObject::set_frame_count 0 1 544 132
/**
 * Resets the number of frames counted to the indicated number.  Also see
 * reset(), set_real_time(), and set_frame_time().
 */
106
void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread());

1506 15 get_frame_count 0 4 2007 28 ClockObject::get_frame_count 0 1 545 195
/**
 * Returns the number of times tick() has been called since the ClockObject
 * was created, or since it was last reset.  This is generally the number of
 * frames that have been rendered.
 */
101
inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const;

1507 18 get_net_frame_rate 0 4 2007 31 ClockObject::get_net_frame_rate 0 1 546 245
/**
 * Returns the average frame rate since the last reset.  This is simply the
 * total number of frames divided by the total elapsed time.  This reports the
 * virtual frame rate if the clock is in (or has been in) M_non_real_time
 * mode.
 */
107
inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;

1508 6 get_dt 0 4 2007 19 ClockObject::get_dt 0 1 547 130
/**
 * Returns the elapsed time for the previous frame: the number of seconds
 * elapsed between the last two calls to tick().
 */
95
inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const;

1509 6 set_dt 0 4 2007 19 ClockObject::set_dt 0 1 548 291
/**
 * In non-real-time mode, sets the number of seconds that should appear to
 * elapse between frames.  In forced mode or limited mode, sets our target dt.
 * In normal mode, this has no effect.
 *
 * Also see set_frame_rate(), which is a different way to specify the same
 * quantity.
 */
36
void ClockObject::set_dt(double dt);

1510 14 set_frame_rate 0 4 2007 27 ClockObject::set_frame_rate 0 1 549 291
/**
 * In non-real-time mode, sets the number of frames per second that we should
 * appear to be running.  In forced mode or limited mode, sets our target
 * frame rate.  In normal mode, this has no effect.
 *
 * Also see set_dt(), which is a different way to specify the same quantity.
 */
52
void ClockObject::set_frame_rate(double frame_rate);

1511 10 get_max_dt 0 4 2007 23 ClockObject::get_max_dt 0 1 550 106
/**
 * Returns the current maximum allowable time elapsed between any two frames.
 * See set_max_dt().
 */
50
inline double ClockObject::get_max_dt(void) const;

1512 10 set_max_dt 0 4 2007 23 ClockObject::set_max_dt 0 1 551 511
/**
 * Sets a limit on the value returned by get_dt().  If this value is less than
 * zero, no limit is imposed; otherwise, this is the maximum value that will
 * ever be returned by get_dt(), regardless of how much time has actually
 * elapsed between frames.
 *
 * This limit is only imposed in real-time mode; in non-real-time mode, the dt
 * is fixed anyway and max_dt is ignored.
 *
 * This is generally used to guarantee reasonable behavior even in the
 * presence of a very slow or chuggy frame rame.
 */
51
inline void ClockObject::set_max_dt(double max_dt);

1513 18 get_degrade_factor 0 4 2007 31 ClockObject::get_degrade_factor 0 1 552 265
/**
 * In degrade mode, returns the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */
58
inline double ClockObject::get_degrade_factor(void) const;

1514 18 set_degrade_factor 0 4 2007 31 ClockObject::set_degrade_factor 0 1 553 262
/**
 * In degrade mode, sets the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */
67
inline void ClockObject::set_degrade_factor(double degrade_factor);

1515 31 set_average_frame_rate_interval 0 4 2007 44 ClockObject::set_average_frame_rate_interval 0 1 554 393
/**
 * Specifies the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.  Changing this does not necessarily immediately
 * change the result of get_average_frame_rate(), until this interval of time
 * has elapsed again.
 *
 * Setting this to zero disables the computation of get_average_frame_rate().
 */
70
inline void ClockObject::set_average_frame_rate_interval(double time);

1516 31 get_average_frame_rate_interval 0 4 2007 44 ClockObject::get_average_frame_rate_interval 0 1 555 162
/**
 * Returns the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.
 */
71
inline double ClockObject::get_average_frame_rate_interval(void) const;

1517 22 get_average_frame_rate 0 4 2007 35 ClockObject::get_average_frame_rate 0 1 556 214
/**
 * Returns the average frame rate in number of frames per second over the last
 * get_average_frame_rate_interval() seconds.  This measures the virtual frame
 * rate if the clock is in M_non_real_time mode.
 */
104
double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;

1518 22 get_max_frame_duration 0 4 2007 35 ClockObject::get_max_frame_duration 0 1 557 105
/**
 * Returns the maximum frame duration over the last
 * get_average_frame_rate_interval() seconds.
 */
104
double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const;

1519 25 calc_frame_rate_deviation 0 4 2007 38 ClockObject::calc_frame_rate_deviation 0 1 558 539
/**
 * Returns the standard deviation of the frame times of the frames rendered
 * over the past get_average_frame_rate_interval() seconds.  This number gives
 * an estimate of the chugginess of the frame rate; if it is large, there is a
 * large variation in the frame rate; if is small, all of the frames are
 * consistent in length.
 *
 * A large value might also represent just a recent change in frame rate, for
 * instance, because the camera has just rotated from looking at a simple
 * scene to looking at a more complex scene.
 */
107
double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const;

1520 4 tick 0 4 2007 17 ClockObject::tick 0 1 559 285
/**
 * Instructs the clock that a new frame has just begun.  In normal, real-time
 * mode, get_frame_time() will henceforth report the time as of this instant
 * as the current start-of-frame time.  In non-real-time mode,
 * get_frame_time() will be incremented by the value of dt.
 */
78
void ClockObject::tick(Thread *current_thread = Thread::get_current_thread());

1521 15 sync_frame_time 0 4 2007 28 ClockObject::sync_frame_time 0 1 560 417
/**
 * Resets the frame time to the current real time.  This is similar to tick(),
 * except that it does not advance the frame counter and does not affect dt.
 * This is intended to be used in the middle of a particularly long frame to
 * compensate for the time that has already elapsed.
 *
 * In non-real-time mode, this function has no effect (because in this mode
 * all frames take the same length of time).
 */
89
void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread());

1522 12 check_errors 0 4 2007 25 ClockObject::check_errors 0 1 561 322
/**
 * Returns true if a clock error was detected since the last time
 * check_errors() was called.  A clock error means that something happened, an
 * OS or BIOS bug, for instance, that makes the current value of the clock
 * somewhat suspect, and an application may wish to resynchronize with any
 * external clocks.
 */
62
inline bool ClockObject::check_errors(Thread *current_thread);

1523 16 get_global_clock 0 4 2007 29 ClockObject::get_global_clock 0 1 562 159
/**
 * Returns a pointer to the global ClockObject.  This is the ClockObject that
 * most code should use for handling scene graph rendering and animation.
 */
63
static inline ClockObject *ClockObject::get_global_clock(void);

1524 14 get_class_type 0 4 2007 27 ClockObject::get_class_type 0 1 563 0
52
static TypeHandle ClockObject::get_class_type(void);

1525 24 parse_color_space_string 0 1 0 24 parse_color_space_string 0 1 967 0
60
ColorSpace parse_color_space_string(std::string const &str);

1526 18 format_color_space 0 1 0 18 format_color_space 0 1 968 0
46
std::string format_color_space(ColorSpace cs);

1527 14 get_model_path 0 1 0 14 get_model_path 0 1 969 0
47
ConfigVariableSearchPath &get_model_path(void);

1528 15 get_plugin_path 0 1 0 15 get_plugin_path 0 1 970 0
48
ConfigVariableSearchPath &get_plugin_path(void);

1529 9 cache_ref 0 4 2011 28 CopyOnWriteObject::cache_ref 0 1 564 62
/**
 * @see CachedTypedWritableReferenceCount::cache_ref()
 */
53
inline void CopyOnWriteObject::cache_ref(void) const;

1530 11 cache_unref 0 4 2011 30 CopyOnWriteObject::cache_unref 0 1 565 64
/**
 * @see CachedTypedWritableReferenceCount::cache_unref()
 */
55
inline bool CopyOnWriteObject::cache_unref(void) const;

1531 14 get_class_type 0 4 2011 33 CopyOnWriteObject::get_class_type 0 1 566 0
58
static TypeHandle CopyOnWriteObject::get_class_type(void);

1532 18 ~CopyOnWriteObject 0 4 2011 37 CopyOnWriteObject::~CopyOnWriteObject 0 0 0
44
CopyOnWriteObject::~CopyOnWriteObject(void);

1533 22 upcast_to_DatagramSink 0 12 2012 38 DatagramBuffer::upcast_to_DatagramSink 0 1 570 42
upcast from DatagramBuffer to DatagramSink
59
DatagramSink *DatagramBuffer::upcast_to_DatagramSink(void);

1534 26 downcast_to_DatagramBuffer 0 12 1983 40 DatagramSink::downcast_to_DatagramBuffer 0 0 44
downcast from DatagramSink to DatagramBuffer
63
DatagramBuffer *DatagramSink::downcast_to_DatagramBuffer(void);

1535 27 upcast_to_DatagramGenerator 0 12 2012 43 DatagramBuffer::upcast_to_DatagramGenerator 0 1 571 47
upcast from DatagramBuffer to DatagramGenerator
69
DatagramGenerator *DatagramBuffer::upcast_to_DatagramGenerator(void);

1536 26 downcast_to_DatagramBuffer 0 12 1976 45 DatagramGenerator::downcast_to_DatagramBuffer 0 0 49
downcast from DatagramGenerator to DatagramBuffer
68
DatagramBuffer *DatagramGenerator::downcast_to_DatagramBuffer(void);

1537 14 DatagramBuffer 0 4 2012 30 DatagramBuffer::DatagramBuffer 0 2 567 568 104
/**
 * Initializes an empty datagram buffer.
 */

/**
 * Initializes the buffer with the given data.
 */
111
inline DatagramBuffer::DatagramBuffer(void);
inline explicit DatagramBuffer::DatagramBuffer(vector_uchar data);

1538 5 clear 0 4 2012 21 DatagramBuffer::clear 0 1 569 38
/**
 * Clears the internal buffer.
 */
40
inline void DatagramBuffer::clear(void);

1539 8 get_data 0 4 2012 24 DatagramBuffer::get_data 0 0 39
/**
 * Returns the internal buffer.
 */
64
inline vector_uchar const &DatagramBuffer::get_data(void) const;

1540 8 set_data 0 4 2012 24 DatagramBuffer::set_data 0 0 52
/**
 * Replaces the data in the internal buffer.
 */
56
inline void DatagramBuffer::set_data(vector_uchar data);

1541 15 ~DatagramBuffer 0 4 2012 31 DatagramBuffer::~DatagramBuffer 0 0 0
38
DatagramBuffer::~DatagramBuffer(void);

1542 17 DatagramInputFile 0 4 2016 36 DatagramInputFile::DatagramInputFile 0 1 572 10
/**
 *
 */
50
inline DatagramInputFile::DatagramInputFile(void);

1543 4 open 0 4 2016 23 DatagramInputFile::open 0 3 573 574 575 432
/**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */

/**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */

/**
 * Starts reading from the indicated stream.  Returns true on success, false
 * on failure.  The DatagramInputFile does not take ownership of the stream;
 * you are responsible for closing or deleting it when you are done.
 */
206
bool DatagramInputFile::open(FileReference const *file);
inline bool DatagramInputFile::open(Filename const &filename);
bool DatagramInputFile::open(std::istream &in, Filename const &filename = Filename());

1544 10 get_stream 0 4 2016 29 DatagramInputFile::get_stream 0 1 576 61
/**
 * Returns the istream represented by the input file.
 */
57
inline std::istream &DatagramInputFile::get_stream(void);

1545 5 close 0 4 2016 24 DatagramInputFile::close 0 1 577 98
/**
 * Closes the file.  This is also implicitly done when the DatagramInputFile
 * destructs.
 */
36
void DatagramInputFile::close(void);

1546 11 read_header 0 4 2016 30 DatagramInputFile::read_header 0 0 257
/**
 * Reads a sequence of bytes from the beginning of the datagram file.  This
 * may be called any number of times after the file has been opened and before
 * the first datagram is read.  It may not be called once the first datagram
 * has been read.
 */
80
bool DatagramInputFile::read_header(std::string &header, std::size_t num_bytes);

1547 18 DatagramOutputFile 0 4 2017 38 DatagramOutputFile::DatagramOutputFile 0 1 578 10
/**
 *
 */
52
inline DatagramOutputFile::DatagramOutputFile(void);

1548 4 open 0 4 2017 24 DatagramOutputFile::open 0 3 579 580 581 434
/**
 * Opens the indicated filename for writing.  Returns true on success, false
 * on failure.
 */

/**
 * Opens the indicated filename for writing.  Returns true if successful,
 * false on failure.
 */

/**
 * Starts writing to the indicated stream.  Returns true on success, false on
 * failure.  The DatagramOutputFile does not take ownership of the stream; you
 * are responsible for closing or deleting it when you are done.
 */
210
bool DatagramOutputFile::open(FileReference const *file);
inline bool DatagramOutputFile::open(Filename const &filename);
bool DatagramOutputFile::open(std::ostream &out, Filename const &filename = Filename());

1549 5 close 0 4 2017 25 DatagramOutputFile::close 0 1 582 99
/**
 * Closes the file.  This is also implicitly done when the DatagramOutputFile
 * destructs.
 */
37
void DatagramOutputFile::close(void);

1550 12 write_header 0 4 2017 32 DatagramOutputFile::write_header 0 1 583 256
/**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */
65
bool DatagramOutputFile::write_header(std::string const &header);

1551 10 get_stream 0 4 2017 30 DatagramOutputFile::get_stream 0 0 62
/**
 * Returns the ostream represented by the output file.
 */
58
inline std::ostream &DatagramOutputFile::get_stream(void);

1552 13 DoubleBitMask 0 4 2019 45 DoubleBitMask< BitMaskNative >::DoubleBitMask 0 3 584 585 586 0
245
constexpr DoubleBitMask< BitMaskNative >::DoubleBitMask(void) = default;
DoubleBitMask< BitMaskNative >::DoubleBitMask(PyObject *init_value);
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &) = default;

1553 6 all_on 0 4 2019 38 DoubleBitMask< BitMaskNative >::all_on 0 1 587 0
90
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void);

1554 7 all_off 0 4 2019 39 DoubleBitMask< BitMaskNative >::all_off 0 1 588 0
91
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void);

1555 8 lower_on 0 4 2019 40 DoubleBitMask< BitMaskNative >::lower_on 0 1 589 0
99
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits);

1556 3 bit 0 4 2019 35 DoubleBitMask< BitMaskNative >::bit 0 1 590 0
92
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index);

1557 5 range 0 4 2019 37 DoubleBitMask< BitMaskNative >::range 0 1 591 0
106
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size);

1558 16 has_max_num_bits 0 4 2019 48 DoubleBitMask< BitMaskNative >::has_max_num_bits 0 1 592 0
77
static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void);

1559 16 get_max_num_bits 0 4 2019 48 DoubleBitMask< BitMaskNative >::get_max_num_bits 0 1 593 0
76
static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void);

1560 12 get_num_bits 0 4 2019 44 DoubleBitMask< BitMaskNative >::get_num_bits 0 1 594 0
71
constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void) const;

1561 7 get_bit 0 4 2019 39 DoubleBitMask< BitMaskNative >::get_bit 0 1 595 0
69
inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const;

1562 7 set_bit 0 4 2019 39 DoubleBitMask< BitMaskNative >::set_bit 0 1 596 0
63
inline void DoubleBitMask< BitMaskNative >::set_bit(int index);

1563 9 clear_bit 0 4 2019 41 DoubleBitMask< BitMaskNative >::clear_bit 0 1 597 0
65
inline void DoubleBitMask< BitMaskNative >::clear_bit(int index);

1564 10 set_bit_to 0 4 2019 42 DoubleBitMask< BitMaskNative >::set_bit_to 0 1 598 0
78
inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value);

1565 7 is_zero 0 4 2019 39 DoubleBitMask< BitMaskNative >::is_zero 0 1 599 0
64
inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const;

1566 9 is_all_on 0 4 2019 41 DoubleBitMask< BitMaskNative >::is_all_on 0 1 600 0
66
inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const;

1567 7 extract 0 4 2019 39 DoubleBitMask< BitMaskNative >::extract 0 1 601 0
85
inline uint64_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const;

1568 5 store 0 4 2019 37 DoubleBitMask< BitMaskNative >::store 0 1 602 0
89
inline void DoubleBitMask< BitMaskNative >::store(uint64_t value, int low_bit, int size);

1569 10 has_any_of 0 4 2019 42 DoubleBitMask< BitMaskNative >::has_any_of 0 1 603 0
84
inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const;

1570 10 has_all_of 0 4 2019 42 DoubleBitMask< BitMaskNative >::has_all_of 0 1 604 0
84
inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const;

1571 9 set_range 0 4 2019 41 DoubleBitMask< BitMaskNative >::set_range 0 1 605 0
77
inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size);

1572 11 clear_range 0 4 2019 43 DoubleBitMask< BitMaskNative >::clear_range 0 1 606 0
79
inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size);

1573 12 set_range_to 0 4 2019 44 DoubleBitMask< BitMaskNative >::set_range_to 0 1 607 0
92
inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size);

1574 15 get_num_on_bits 0 4 2019 47 DoubleBitMask< BitMaskNative >::get_num_on_bits 0 1 608 0
71
inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const;

1575 16 get_num_off_bits 0 4 2019 48 DoubleBitMask< BitMaskNative >::get_num_off_bits 0 1 609 0
72
inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const;

1576 17 get_lowest_on_bit 0 4 2019 49 DoubleBitMask< BitMaskNative >::get_lowest_on_bit 0 1 610 0
73
inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const;

1577 18 get_lowest_off_bit 0 4 2019 50 DoubleBitMask< BitMaskNative >::get_lowest_off_bit 0 1 611 0
74
inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const;

1578 18 get_highest_on_bit 0 4 2019 50 DoubleBitMask< BitMaskNative >::get_highest_on_bit 0 1 612 0
74
inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const;

1579 19 get_highest_off_bit 0 4 2019 51 DoubleBitMask< BitMaskNative >::get_highest_off_bit 0 1 613 0
75
inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const;

1580 29 get_next_higher_different_bit 0 4 2019 61 DoubleBitMask< BitMaskNative >::get_next_higher_different_bit 0 1 614 0
92
inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1581 15 invert_in_place 0 4 2019 47 DoubleBitMask< BitMaskNative >::invert_in_place 0 1 615 0
66
inline void DoubleBitMask< BitMaskNative >::invert_in_place(void);

1582 18 has_bits_in_common 0 4 2019 50 DoubleBitMask< BitMaskNative >::has_bits_in_common 0 1 616 0
114
inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const;

1583 5 clear 0 4 2019 37 DoubleBitMask< BitMaskNative >::clear 0 1 617 0
56
inline void DoubleBitMask< BitMaskNative >::clear(void);

1584 6 output 0 4 2019 38 DoubleBitMask< BitMaskNative >::output 0 1 618 0
69
void DoubleBitMask< BitMaskNative >::output(std::ostream &out) const;

1585 13 output_binary 0 4 2019 45 DoubleBitMask< BitMaskNative >::output_binary 0 1 619 0
98
void DoubleBitMask< BitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const;

1586 10 output_hex 0 4 2019 42 DoubleBitMask< BitMaskNative >::output_hex 0 1 620 0
95
void DoubleBitMask< BitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const;

1587 5 write 0 4 2019 37 DoubleBitMask< BitMaskNative >::write 0 1 621 0
90
void DoubleBitMask< BitMaskNative >::write(std::ostream &out, int indent_level = 0) const;

1588 11 operator == 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator == 0 1 622 0
107
inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const;

1589 11 operator != 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator != 0 1 623 0
107
inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const;

1590 10 operator < 0 4 2019 42 DoubleBitMask< BitMaskNative >::operator < 0 1 624 0
106
inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const;

1591 10 compare_to 0 4 2019 42 DoubleBitMask< BitMaskNative >::compare_to 0 1 625 0
105
inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const;

1592 10 operator & 0 4 2019 42 DoubleBitMask< BitMaskNative >::operator & 0 1 626 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const;

1593 10 operator | 0 4 2019 42 DoubleBitMask< BitMaskNative >::operator | 0 1 627 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const;

1594 10 operator ^ 0 4 2019 42 DoubleBitMask< BitMaskNative >::operator ^ 0 1 628 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const;

1595 10 operator ~ 0 68 2019 42 DoubleBitMask< BitMaskNative >::operator ~ 0 1 629 0
93
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const;

1596 11 operator << 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator << 0 1 630 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const;

1597 11 operator >> 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator >> 0 1 631 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const;

1598 11 operator &= 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator &= 0 1 632 0
101
inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other);

1599 11 operator |= 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator |= 0 1 633 0
101
inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other);

1600 11 operator ^= 0 4 2019 43 DoubleBitMask< BitMaskNative >::operator ^= 0 1 634 0
101
inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other);

1601 12 operator <<= 0 4 2019 44 DoubleBitMask< BitMaskNative >::operator <<= 0 1 635 0
68
inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift);

1602 12 operator >>= 0 4 2019 44 DoubleBitMask< BitMaskNative >::operator >>= 0 1 636 0
68
inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift);

1603 8 __bool__ 0 4 2019 40 DoubleBitMask< BitMaskNative >::__bool__ 0 1 637 0
58
bool DoubleBitMask< BitMaskNative >::__bool__(void) const;

1604 7 __int__ 0 4 2019 39 DoubleBitMask< BitMaskNative >::__int__ 0 1 638 0
62
PyObject *DoubleBitMask< BitMaskNative >::__int__(void) const;

1605 10 __reduce__ 0 4 2019 42 DoubleBitMask< BitMaskNative >::__reduce__ 0 1 639 0
75
PyObject *DoubleBitMask< BitMaskNative >::__reduce__(PyObject *self) const;

1606 14 get_class_type 0 4 2019 46 DoubleBitMask< BitMaskNative >::get_class_type 0 1 640 0
71
static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void);

1607 14 ~DoubleBitMask 0 4 2019 46 DoubleBitMask< BitMaskNative >::~DoubleBitMask 0 0 0
53
DoubleBitMask< BitMaskNative >::~DoubleBitMask(void);

1608 13 DoubleBitMask 0 4 2021 51 DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask 0 3 641 642 643 0
269
constexpr DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void) = default;
DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(PyObject *init_value);
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &) = default;

1609 6 all_on 0 4 2021 44 DoubleBitMask< DoubleBitMaskNative >::all_on 0 1 644 0
102
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void);

1610 7 all_off 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::all_off 0 1 645 0
103
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void);

1611 8 lower_on 0 4 2021 46 DoubleBitMask< DoubleBitMaskNative >::lower_on 0 1 646 0
111
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits);

1612 3 bit 0 4 2021 41 DoubleBitMask< DoubleBitMaskNative >::bit 0 1 647 0
104
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index);

1613 5 range 0 4 2021 43 DoubleBitMask< DoubleBitMaskNative >::range 0 1 648 0
118
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size);

1614 16 has_max_num_bits 0 4 2021 54 DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits 0 1 649 0
83
static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void);

1615 16 get_max_num_bits 0 4 2021 54 DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits 0 1 650 0
82
static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void);

1616 12 get_num_bits 0 4 2021 50 DoubleBitMask< DoubleBitMaskNative >::get_num_bits 0 1 651 0
77
constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void) const;

1617 7 get_bit 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::get_bit 0 1 652 0
75
inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const;

1618 7 set_bit 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::set_bit 0 1 653 0
69
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index);

1619 9 clear_bit 0 4 2021 47 DoubleBitMask< DoubleBitMaskNative >::clear_bit 0 1 654 0
71
inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index);

1620 10 set_bit_to 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::set_bit_to 0 1 655 0
84
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value);

1621 7 is_zero 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::is_zero 0 1 656 0
70
inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const;

1622 9 is_all_on 0 4 2021 47 DoubleBitMask< DoubleBitMaskNative >::is_all_on 0 1 657 0
72
inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const;

1623 7 extract 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::extract 0 1 658 0
91
inline uint64_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const;

1624 5 store 0 4 2021 43 DoubleBitMask< DoubleBitMaskNative >::store 0 1 659 0
95
inline void DoubleBitMask< DoubleBitMaskNative >::store(uint64_t value, int low_bit, int size);

1625 10 has_any_of 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::has_any_of 0 1 660 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const;

1626 10 has_all_of 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::has_all_of 0 1 661 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const;

1627 9 set_range 0 4 2021 47 DoubleBitMask< DoubleBitMaskNative >::set_range 0 1 662 0
83
inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size);

1628 11 clear_range 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::clear_range 0 1 663 0
85
inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size);

1629 12 set_range_to 0 4 2021 50 DoubleBitMask< DoubleBitMaskNative >::set_range_to 0 1 664 0
98
inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size);

1630 15 get_num_on_bits 0 4 2021 53 DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits 0 1 665 0
77
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const;

1631 16 get_num_off_bits 0 4 2021 54 DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits 0 1 666 0
78
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const;

1632 17 get_lowest_on_bit 0 4 2021 55 DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit 0 1 667 0
79
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const;

1633 18 get_lowest_off_bit 0 4 2021 56 DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit 0 1 668 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const;

1634 18 get_highest_on_bit 0 4 2021 56 DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit 0 1 669 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const;

1635 19 get_highest_off_bit 0 4 2021 57 DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit 0 1 670 0
81
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const;

1636 29 get_next_higher_different_bit 0 4 2021 67 DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit 0 1 671 0
98
inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1637 15 invert_in_place 0 4 2021 53 DoubleBitMask< DoubleBitMaskNative >::invert_in_place 0 1 672 0
72
inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void);

1638 18 has_bits_in_common 0 4 2021 56 DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common 0 1 673 0
126
inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1639 5 clear 0 4 2021 43 DoubleBitMask< DoubleBitMaskNative >::clear 0 1 674 0
62
inline void DoubleBitMask< DoubleBitMaskNative >::clear(void);

1640 6 output 0 4 2021 44 DoubleBitMask< DoubleBitMaskNative >::output 0 1 675 0
75
void DoubleBitMask< DoubleBitMaskNative >::output(std::ostream &out) const;

1641 13 output_binary 0 4 2021 51 DoubleBitMask< DoubleBitMaskNative >::output_binary 0 1 676 0
104
void DoubleBitMask< DoubleBitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const;

1642 10 output_hex 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::output_hex 0 1 677 0
101
void DoubleBitMask< DoubleBitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const;

1643 5 write 0 4 2021 43 DoubleBitMask< DoubleBitMaskNative >::write 0 1 678 0
96
void DoubleBitMask< DoubleBitMaskNative >::write(std::ostream &out, int indent_level = 0) const;

1644 11 operator == 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator == 0 1 679 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1645 11 operator != 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator != 0 1 680 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1646 10 operator < 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::operator < 0 1 681 0
118
inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1647 10 compare_to 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::compare_to 0 1 682 0
117
inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1648 10 operator & 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::operator & 0 1 683 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1649 10 operator | 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::operator | 0 1 684 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1650 10 operator ^ 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::operator ^ 0 1 685 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1651 10 operator ~ 0 68 2021 48 DoubleBitMask< DoubleBitMaskNative >::operator ~ 0 1 686 0
105
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const;

1652 11 operator << 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator << 0 1 687 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const;

1653 11 operator >> 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator >> 0 1 688 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const;

1654 11 operator &= 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator &= 0 1 689 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other);

1655 11 operator |= 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator |= 0 1 690 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other);

1656 11 operator ^= 0 4 2021 49 DoubleBitMask< DoubleBitMaskNative >::operator ^= 0 1 691 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other);

1657 12 operator <<= 0 4 2021 50 DoubleBitMask< DoubleBitMaskNative >::operator <<= 0 1 692 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift);

1658 12 operator >>= 0 4 2021 50 DoubleBitMask< DoubleBitMaskNative >::operator >>= 0 1 693 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift);

1659 8 __bool__ 0 4 2021 46 DoubleBitMask< DoubleBitMaskNative >::__bool__ 0 1 694 0
64
bool DoubleBitMask< DoubleBitMaskNative >::__bool__(void) const;

1660 7 __int__ 0 4 2021 45 DoubleBitMask< DoubleBitMaskNative >::__int__ 0 1 695 0
68
PyObject *DoubleBitMask< DoubleBitMaskNative >::__int__(void) const;

1661 10 __reduce__ 0 4 2021 48 DoubleBitMask< DoubleBitMaskNative >::__reduce__ 0 1 696 0
81
PyObject *DoubleBitMask< DoubleBitMaskNative >::__reduce__(PyObject *self) const;

1662 14 get_class_type 0 4 2021 52 DoubleBitMask< DoubleBitMaskNative >::get_class_type 0 1 697 0
77
static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void);

1663 14 ~DoubleBitMask 0 4 2021 52 DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask 0 0 0
59
DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask(void);

1664 6 lstick 0 4 2024 21 GamepadButton::lstick 0 1 700 0
48
static ButtonHandle GamepadButton::lstick(void);

1665 6 rstick 0 4 2024 21 GamepadButton::rstick 0 1 701 0
48
static ButtonHandle GamepadButton::rstick(void);

1666 9 lshoulder 0 4 2024 24 GamepadButton::lshoulder 0 1 702 0
51
static ButtonHandle GamepadButton::lshoulder(void);

1667 9 rshoulder 0 4 2024 24 GamepadButton::rshoulder 0 1 703 0
51
static ButtonHandle GamepadButton::rshoulder(void);

1668 8 ltrigger 0 4 2024 23 GamepadButton::ltrigger 0 1 704 0
50
static ButtonHandle GamepadButton::ltrigger(void);

1669 8 rtrigger 0 4 2024 23 GamepadButton::rtrigger 0 1 705 0
50
static ButtonHandle GamepadButton::rtrigger(void);

1670 5 lgrip 0 4 2024 20 GamepadButton::lgrip 0 1 706 0
47
static ButtonHandle GamepadButton::lgrip(void);

1671 5 rgrip 0 4 2024 20 GamepadButton::rgrip 0 1 707 0
47
static ButtonHandle GamepadButton::rgrip(void);

1672 9 dpad_left 0 4 2024 24 GamepadButton::dpad_left 0 1 708 0
51
static ButtonHandle GamepadButton::dpad_left(void);

1673 10 dpad_right 0 4 2024 25 GamepadButton::dpad_right 0 1 709 0
52
static ButtonHandle GamepadButton::dpad_right(void);

1674 7 dpad_up 0 4 2024 22 GamepadButton::dpad_up 0 1 710 0
49
static ButtonHandle GamepadButton::dpad_up(void);

1675 9 dpad_down 0 4 2024 24 GamepadButton::dpad_down 0 1 711 0
51
static ButtonHandle GamepadButton::dpad_down(void);

1676 4 back 0 4 2024 19 GamepadButton::back 0 1 712 0
46
static ButtonHandle GamepadButton::back(void);

1677 5 guide 0 4 2024 20 GamepadButton::guide 0 1 713 0
47
static ButtonHandle GamepadButton::guide(void);

1678 5 start 0 4 2024 20 GamepadButton::start 0 1 714 0
47
static ButtonHandle GamepadButton::start(void);

1679 4 next 0 4 2024 19 GamepadButton::next 0 1 715 0
46
static ButtonHandle GamepadButton::next(void);

1680 8 previous 0 4 2024 23 GamepadButton::previous 0 1 716 0
50
static ButtonHandle GamepadButton::previous(void);

1681 6 face_a 0 4 2024 21 GamepadButton::face_a 0 1 717 0
48
static ButtonHandle GamepadButton::face_a(void);

1682 6 face_b 0 4 2024 21 GamepadButton::face_b 0 1 718 0
48
static ButtonHandle GamepadButton::face_b(void);

1683 6 face_c 0 4 2024 21 GamepadButton::face_c 0 1 719 0
48
static ButtonHandle GamepadButton::face_c(void);

1684 6 face_x 0 4 2024 21 GamepadButton::face_x 0 1 720 0
48
static ButtonHandle GamepadButton::face_x(void);

1685 6 face_y 0 4 2024 21 GamepadButton::face_y 0 1 721 0
48
static ButtonHandle GamepadButton::face_y(void);

1686 6 face_z 0 4 2024 21 GamepadButton::face_z 0 1 722 0
48
static ButtonHandle GamepadButton::face_z(void);

1687 6 face_1 0 4 2024 21 GamepadButton::face_1 0 1 723 0
48
static ButtonHandle GamepadButton::face_1(void);

1688 6 face_2 0 4 2024 21 GamepadButton::face_2 0 1 724 0
48
static ButtonHandle GamepadButton::face_2(void);

1689 7 trigger 0 4 2024 22 GamepadButton::trigger 0 1 725 74
// Flight stick buttons, takes zero-based index.  First is always trigger.
49
static ButtonHandle GamepadButton::trigger(void);

1690 8 joystick 0 4 2024 23 GamepadButton::joystick 0 1 726 169
/**
 * Returns the ButtonHandle associated with the particular numbered joystick
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */
63
static ButtonHandle GamepadButton::joystick(int button_number);

1691 6 hat_up 0 4 2024 21 GamepadButton::hat_up 0 1 727 0
48
static ButtonHandle GamepadButton::hat_up(void);

1692 8 hat_down 0 4 2024 23 GamepadButton::hat_down 0 1 728 0
50
static ButtonHandle GamepadButton::hat_down(void);

1693 8 hat_left 0 4 2024 23 GamepadButton::hat_left 0 1 729 0
50
static ButtonHandle GamepadButton::hat_left(void);

1694 9 hat_right 0 4 2024 24 GamepadButton::hat_right 0 1 730 0
51
static ButtonHandle GamepadButton::hat_right(void);

1695 13 GamepadButton 0 4 2024 28 GamepadButton::GamepadButton 0 2 698 699 0
122
inline GamepadButton::GamepadButton(void) = default;
inline GamepadButton::GamepadButton(GamepadButton const &) = default;

1696 14 ~GamepadButton 0 4 2024 29 GamepadButton::~GamepadButton 0 0 0
36
GamepadButton::~GamepadButton(void);

1697 9 ascii_key 0 4 2027 25 KeyboardButton::ascii_key 0 1 733 144
/**
 * Returns the ButtonHandle associated with the particular ASCII character, if
 * there is one, or ButtonHandle::none() if there is not.
 */
69
static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent);

1698 5 space 0 4 2027 21 KeyboardButton::space 0 1 734 0
48
static ButtonHandle KeyboardButton::space(void);

1699 9 backspace 0 4 2027 25 KeyboardButton::backspace 0 1 735 0
52
static ButtonHandle KeyboardButton::backspace(void);

1700 3 tab 0 4 2027 19 KeyboardButton::tab 0 1 736 0
46
static ButtonHandle KeyboardButton::tab(void);

1701 5 enter 0 4 2027 21 KeyboardButton::enter 0 1 737 0
48
static ButtonHandle KeyboardButton::enter(void);

1702 6 escape 0 4 2027 22 KeyboardButton::escape 0 1 738 0
49
static ButtonHandle KeyboardButton::escape(void);

1703 2 f1 0 4 2027 18 KeyboardButton::f1 0 1 739 0
45
static ButtonHandle KeyboardButton::f1(void);

1704 2 f2 0 4 2027 18 KeyboardButton::f2 0 1 740 0
45
static ButtonHandle KeyboardButton::f2(void);

1705 2 f3 0 4 2027 18 KeyboardButton::f3 0 1 741 0
45
static ButtonHandle KeyboardButton::f3(void);

1706 2 f4 0 4 2027 18 KeyboardButton::f4 0 1 742 0
45
static ButtonHandle KeyboardButton::f4(void);

1707 2 f5 0 4 2027 18 KeyboardButton::f5 0 1 743 0
45
static ButtonHandle KeyboardButton::f5(void);

1708 2 f6 0 4 2027 18 KeyboardButton::f6 0 1 744 0
45
static ButtonHandle KeyboardButton::f6(void);

1709 2 f7 0 4 2027 18 KeyboardButton::f7 0 1 745 0
45
static ButtonHandle KeyboardButton::f7(void);

1710 2 f8 0 4 2027 18 KeyboardButton::f8 0 1 746 0
45
static ButtonHandle KeyboardButton::f8(void);

1711 2 f9 0 4 2027 18 KeyboardButton::f9 0 1 747 0
45
static ButtonHandle KeyboardButton::f9(void);

1712 3 f10 0 4 2027 19 KeyboardButton::f10 0 1 748 0
46
static ButtonHandle KeyboardButton::f10(void);

1713 3 f11 0 4 2027 19 KeyboardButton::f11 0 1 749 0
46
static ButtonHandle KeyboardButton::f11(void);

1714 3 f12 0 4 2027 19 KeyboardButton::f12 0 1 750 0
46
static ButtonHandle KeyboardButton::f12(void);

1715 3 f13 0 4 2027 19 KeyboardButton::f13 0 1 751 59
// PC keyboards don't have these four buttons, but Macs do.
46
static ButtonHandle KeyboardButton::f13(void);

1716 3 f14 0 4 2027 19 KeyboardButton::f14 0 1 752 0
46
static ButtonHandle KeyboardButton::f14(void);

1717 3 f15 0 4 2027 19 KeyboardButton::f15 0 1 753 0
46
static ButtonHandle KeyboardButton::f15(void);

1718 3 f16 0 4 2027 19 KeyboardButton::f16 0 1 754 0
46
static ButtonHandle KeyboardButton::f16(void);

1719 4 left 0 4 2027 20 KeyboardButton::left 0 1 755 0
47
static ButtonHandle KeyboardButton::left(void);

1720 5 right 0 4 2027 21 KeyboardButton::right 0 1 756 0
48
static ButtonHandle KeyboardButton::right(void);

1721 2 up 0 4 2027 18 KeyboardButton::up 0 1 757 0
45
static ButtonHandle KeyboardButton::up(void);

1722 4 down 0 4 2027 20 KeyboardButton::down 0 1 758 0
47
static ButtonHandle KeyboardButton::down(void);

1723 7 page_up 0 4 2027 23 KeyboardButton::page_up 0 1 759 0
50
static ButtonHandle KeyboardButton::page_up(void);

1724 9 page_down 0 4 2027 25 KeyboardButton::page_down 0 1 760 0
52
static ButtonHandle KeyboardButton::page_down(void);

1725 4 home 0 4 2027 20 KeyboardButton::home 0 1 761 0
47
static ButtonHandle KeyboardButton::home(void);

1726 3 end 0 4 2027 19 KeyboardButton::end 0 1 762 0
46
static ButtonHandle KeyboardButton::end(void);

1727 6 insert 0 4 2027 22 KeyboardButton::insert 0 1 763 0
49
static ButtonHandle KeyboardButton::insert(void);

1728 3 del 0 4 2027 19 KeyboardButton::del 0 1 764 27
// delete is a C++ keyword.
46
static ButtonHandle KeyboardButton::del(void);

1729 4 help 0 4 2027 20 KeyboardButton::help 0 1 765 27
// delete is a C++ keyword.
47
static ButtonHandle KeyboardButton::help(void);

1730 4 menu 0 4 2027 20 KeyboardButton::menu 0 1 766 0
47
static ButtonHandle KeyboardButton::menu(void);

1731 5 shift 0 4 2027 21 KeyboardButton::shift 0 1 767 0
48
static ButtonHandle KeyboardButton::shift(void);

1732 7 control 0 4 2027 23 KeyboardButton::control 0 1 768 0
50
static ButtonHandle KeyboardButton::control(void);

1733 3 alt 0 4 2027 19 KeyboardButton::alt 0 1 769 0
46
static ButtonHandle KeyboardButton::alt(void);

1734 4 meta 0 4 2027 20 KeyboardButton::meta 0 1 770 0
47
static ButtonHandle KeyboardButton::meta(void);

1735 9 caps_lock 0 4 2027 25 KeyboardButton::caps_lock 0 1 771 0
52
static ButtonHandle KeyboardButton::caps_lock(void);

1736 10 shift_lock 0 4 2027 26 KeyboardButton::shift_lock 0 1 772 0
53
static ButtonHandle KeyboardButton::shift_lock(void);

1737 8 num_lock 0 4 2027 24 KeyboardButton::num_lock 0 1 773 0
51
static ButtonHandle KeyboardButton::num_lock(void);

1738 11 scroll_lock 0 4 2027 27 KeyboardButton::scroll_lock 0 1 774 0
54
static ButtonHandle KeyboardButton::scroll_lock(void);

1739 12 print_screen 0 4 2027 28 KeyboardButton::print_screen 0 1 775 0
55
static ButtonHandle KeyboardButton::print_screen(void);

1740 5 pause 0 4 2027 21 KeyboardButton::pause 0 1 776 0
48
static ButtonHandle KeyboardButton::pause(void);

1741 6 lshift 0 4 2027 22 KeyboardButton::lshift 0 1 777 0
49
static ButtonHandle KeyboardButton::lshift(void);

1742 6 rshift 0 4 2027 22 KeyboardButton::rshift 0 1 778 0
49
static ButtonHandle KeyboardButton::rshift(void);

1743 8 lcontrol 0 4 2027 24 KeyboardButton::lcontrol 0 1 779 0
51
static ButtonHandle KeyboardButton::lcontrol(void);

1744 8 rcontrol 0 4 2027 24 KeyboardButton::rcontrol 0 1 780 0
51
static ButtonHandle KeyboardButton::rcontrol(void);

1745 4 lalt 0 4 2027 20 KeyboardButton::lalt 0 1 781 0
47
static ButtonHandle KeyboardButton::lalt(void);

1746 4 ralt 0 4 2027 20 KeyboardButton::ralt 0 1 782 0
47
static ButtonHandle KeyboardButton::ralt(void);

1747 5 lmeta 0 4 2027 21 KeyboardButton::lmeta 0 1 783 0
48
static ButtonHandle KeyboardButton::lmeta(void);

1748 5 rmeta 0 4 2027 21 KeyboardButton::rmeta 0 1 784 0
48
static ButtonHandle KeyboardButton::rmeta(void);

1749 14 KeyboardButton 0 4 2027 30 KeyboardButton::KeyboardButton 0 2 731 732 0
127
inline KeyboardButton::KeyboardButton(void) = default;
inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default;

1750 15 ~KeyboardButton 0 4 2027 31 KeyboardButton::~KeyboardButton 0 0 0
38
KeyboardButton::~KeyboardButton(void);

1751 13 load_prc_file 0 1 0 13 load_prc_file 0 1 971 1206
/**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */

/**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */
52
ConfigPage *load_prc_file(Filename const &filename);

1752 18 load_prc_file_data 0 1 0 18 load_prc_file_data 0 1 972 794
/**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */

/**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */
81
ConfigPage *load_prc_file_data(std::string const &name, std::string const &data);

1753 15 unload_prc_file 0 1 0 15 unload_prc_file 0 1 973 0
39
bool unload_prc_file(ConfigPage *page);

1754 18 hash_prc_variables 0 1 0 18 hash_prc_variables 0 1 974 0
39
void hash_prc_variables(HashVal &hash);

1755 15 ModifierButtons 0 4 2028 32 ModifierButtons::ModifierButtons 0 2 785 786 22
/**
 *
 */

/**
 *
 */
102
ModifierButtons::ModifierButtons(void);
ModifierButtons::ModifierButtons(ModifierButtons const &copy);

1756 16 ~ModifierButtons 0 4 2028 33 ModifierButtons::~ModifierButtons 0 0 10
/**
 *
 */
40
ModifierButtons::~ModifierButtons(void);

1757 10 operator = 0 4 2028 27 ModifierButtons::operator = 0 1 787 0
69
inline void ModifierButtons::operator =(ModifierButtons const &copy);

1758 11 operator == 0 4 2028 28 ModifierButtons::operator == 0 1 788 0
77
inline bool ModifierButtons::operator ==(ModifierButtons const &other) const;

1759 11 operator != 0 4 2028 28 ModifierButtons::operator != 0 1 789 0
77
inline bool ModifierButtons::operator !=(ModifierButtons const &other) const;

1760 10 operator < 0 4 2028 27 ModifierButtons::operator < 0 1 790 0
76
inline bool ModifierButtons::operator <(ModifierButtons const &other) const;

1761 10 operator & 0 4 2028 27 ModifierButtons::operator & 0 1 791 0
87
inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const;

1762 10 operator | 0 4 2028 27 ModifierButtons::operator | 0 1 792 0
87
inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const;

1763 11 operator &= 0 4 2028 28 ModifierButtons::operator &= 0 1 793 0
64
void ModifierButtons::operator &=(ModifierButtons const &other);

1764 11 operator |= 0 4 2028 28 ModifierButtons::operator |= 0 1 794 0
64
void ModifierButtons::operator |=(ModifierButtons const &other);

1765 15 set_button_list 0 4 2028 32 ModifierButtons::set_button_list 0 1 795 374
/**
 * Sets the list of buttons to watch to be the same as that of the other
 * ModifierButtons object.  This makes the lists pointer equivalent (until one
 * or the other is later modified).
 *
 * This will preserve the state of any button that was on the original list
 * and is also on the new lists.  Any other buttons will get reset to the
 * default state of "up".
 */
68
void ModifierButtons::set_button_list(ModifierButtons const &other);

1766 7 matches 0 4 2028 24 ModifierButtons::matches 0 1 796 232
/**
 * Returns true if the set of buttons indicated as down by this
 * ModifierButtons object is the same set of buttons indicated as down by the
 * other ModifierButtons object.  The buttons indicated as up are not
 * relevant.
 */
66
bool ModifierButtons::matches(ModifierButtons const &other) const;

1767 10 add_button 0 4 2028 27 ModifierButtons::add_button 0 1 797 248
/**
 * Adds the indicated button to the set of buttons that will be monitored for
 * upness and downness.  Returns true if the button was added, false if it was
 * already being monitored or if too many buttons are currently being
 * monitored.
 */
54
bool ModifierButtons::add_button(ButtonHandle button);

1768 10 has_button 0 4 2028 27 ModifierButtons::has_button 0 1 798 109
/**
 * Returns true if the indicated button is in the set of buttons being
 * monitored, false otherwise.
 */
60
bool ModifierButtons::has_button(ButtonHandle button) const;

1769 13 remove_button 0 4 2028 30 ModifierButtons::remove_button 0 1 799 313
/**
 * Removes the indicated button from the set of buttons being monitored.
 * Returns true if the button was removed, false if it was not being monitored
 * in the first place.
 *
 * Unlike the other methods, you cannot remove a button by removing its alias;
 * you have to remove exactly the button itself.
 */
57
bool ModifierButtons::remove_button(ButtonHandle button);

1770 15 get_num_buttons 0 4 2028 32 ModifierButtons::get_num_buttons 0 1 800 143
/**
 * Returns the number of buttons that the ModifierButtons object is monitoring
 * (e.g.  the number of buttons passed to add_button()).
 */
56
inline int ModifierButtons::get_num_buttons(void) const;

1771 10 get_button 0 4 2028 27 ModifierButtons::get_button 0 1 801 185
/**
 * Returns the nth button that the ModifierButtons object is monitoring (the
 * nth button passed to add_button()).  This must be in the range 0 <= index <
 * get_num_buttons().
 */
65
inline ButtonHandle ModifierButtons::get_button(int index) const;

1772 11 button_down 0 4 2028 28 ModifierButtons::button_down 0 1 802 305
/**
 * Records that a particular button has been pressed.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */
55
bool ModifierButtons::button_down(ButtonHandle button);

1773 9 button_up 0 4 2028 26 ModifierButtons::button_up 0 1 803 306
/**
 * Records that a particular button has been released.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */
53
bool ModifierButtons::button_up(ButtonHandle button);

1774 14 all_buttons_up 0 4 2028 31 ModifierButtons::all_buttons_up 0 1 804 66
/**
 * Marks all monitored buttons as being in the "up" state.
 */
50
inline void ModifierButtons::all_buttons_up(void);

1775 7 is_down 0 4 2028 24 ModifierButtons::is_down 0 2 805 806 264
/**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up.
 */

/**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up or if it is not in the set of buttons being tracked.
 */
112
bool ModifierButtons::is_down(ButtonHandle button) const;
inline bool ModifierButtons::is_down(int index) const;

1776 11 is_any_down 0 4 2028 28 ModifierButtons::is_any_down 0 1 807 109
/**
 * Returns true if any of the tracked button are known to be down, or false if
 * all of them are up.
 */
53
inline bool ModifierButtons::is_any_down(void) const;

1777 10 get_prefix 0 4 2028 27 ModifierButtons::get_prefix 0 1 808 150
/**
 * Returns a string which can be used to prefix any button name or event name
 * with the unique set of modifier buttons currently being held.
 */
52
std::string ModifierButtons::get_prefix(void) const;

1778 6 output 0 4 2028 23 ModifierButtons::output 0 1 809 69
/**
 * Writes a one-line summary of the buttons known to be down.
 */
54
void ModifierButtons::output(std::ostream &out) const;

1779 5 write 0 4 2028 22 ModifierButtons::write 0 1 810 123
/**
 * Writes a multi-line summary including all of the buttons being monitored
 * and which ones are known to be down.
 */
53
void ModifierButtons::write(std::ostream &out) const;

1780 6 button 0 4 2029 19 MouseButton::button 0 1 813 166
/**
 * Returns the ButtonHandle associated with the particular numbered mouse
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */
59
static ButtonHandle MouseButton::button(int button_number);

1781 3 one 0 4 2029 16 MouseButton::one 0 1 814 75
/**
 * Returns the ButtonHandle associated with the first mouse button.
 */
43
static ButtonHandle MouseButton::one(void);

1782 3 two 0 4 2029 16 MouseButton::two 0 1 815 76
/**
 * Returns the ButtonHandle associated with the second mouse button.
 */
43
static ButtonHandle MouseButton::two(void);

1783 5 three 0 4 2029 18 MouseButton::three 0 1 816 75
/**
 * Returns the ButtonHandle associated with the third mouse button.
 */
45
static ButtonHandle MouseButton::three(void);

1784 4 four 0 4 2029 17 MouseButton::four 0 1 817 76
/**
 * Returns the ButtonHandle associated with the fourth mouse button.
 */
44
static ButtonHandle MouseButton::four(void);

1785 4 five 0 4 2029 17 MouseButton::five 0 1 818 75
/**
 * Returns the ButtonHandle associated with the fifth mouse button.
 */
44
static ButtonHandle MouseButton::five(void);

1786 8 wheel_up 0 4 2029 21 MouseButton::wheel_up 0 1 819 98
/**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * upwards.
 */
48
static ButtonHandle MouseButton::wheel_up(void);

1787 10 wheel_down 0 4 2029 23 MouseButton::wheel_down 0 1 820 100
/**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * downwards.
 */
50
static ButtonHandle MouseButton::wheel_down(void);

1788 10 wheel_left 0 4 2029 23 MouseButton::wheel_left 0 1 821 148
/**
 * Returns the ButtonHandle generated when the mouse is scrolled to the left.
 * Usually, you'll only find the horizontal scroll on laptops.
 */
50
static ButtonHandle MouseButton::wheel_left(void);

1789 11 wheel_right 0 4 2029 24 MouseButton::wheel_right 0 1 822 149
/**
 * Returns the ButtonHandle generated when the mouse is scrolled to the right.
 * Usually, you'll only find the horizontal scroll on laptops.
 */
51
static ButtonHandle MouseButton::wheel_right(void);

1790 15 is_mouse_button 0 4 2029 28 MouseButton::is_mouse_button 0 1 823 117
/**
 * Returns true if the indicated ButtonHandle is a mouse button, false if it
 * is some other kind of button.
 */
62
static bool MouseButton::is_mouse_button(ButtonHandle button);

1791 11 MouseButton 0 4 2029 24 MouseButton::MouseButton 0 2 811 812 0
112
inline MouseButton::MouseButton(void) = default;
inline MouseButton::MouseButton(MouseButton const &) = default;

1792 12 ~MouseButton 0 4 2029 25 MouseButton::~MouseButton 0 0 0
32
MouseButton::~MouseButton(void);

1793 5 get_x 0 4 2031 18 PointerData::get_x 0 1 826 10
/**
 *
 */
45
inline double PointerData::get_x(void) const;

1794 5 get_y 0 4 2031 18 PointerData::get_y 0 1 827 10
/**
 *
 */
45
inline double PointerData::get_y(void) const;

1795 13 get_in_window 0 4 2031 26 PointerData::get_in_window 0 1 828 157
/**
 * If this returns false, the pointer is not currently present in the window
 * and the values returned by get_x() and get_y() may not be meaningful.
 */
51
inline bool PointerData::get_in_window(void) const;

1796 8 get_type 0 4 2031 21 PointerData::get_type 0 0 47
/**
 * Returns the type of pointing device.
 */
53
inline PointerType PointerData::get_type(void) const;

1797 6 get_id 0 4 2031 19 PointerData::get_id 0 0 273
/**
 * Returns a unique identifier for this pointer.  This is for tracking
 * individual fingers.  This value should not be assumed to have a specific
 * meaning other than that there will not be two different pointers active
 * simultaneously with the same identifier.
 */
43
inline int PointerData::get_id(void) const;

1798 12 get_pressure 0 4 2031 25 PointerData::get_pressure 0 0 119
/**
 * Returns the pressure of the pointer.  For mice, this will be 1.0 if any
 * button is pressed, 0.0 otherwise.
 */
52
inline double PointerData::get_pressure(void) const;

1799 11 PointerData 0 4 2031 24 PointerData::PointerData 0 2 824 825 0
112
inline PointerData::PointerData(void) = default;
inline PointerData::PointerData(PointerData const &) = default;

1800 12 ~PointerData 0 4 2031 25 PointerData::~PointerData 0 0 0
32
PointerData::~PointerData(void);

1801 18 get_node_ref_count 0 4 2033 44 NodeCachedReferenceCount::get_node_ref_count 0 1 829 47
/**
 * Returns the current reference count.
 */
68
inline int NodeCachedReferenceCount::get_node_ref_count(void) const;

1802 8 node_ref 0 4 2033 34 NodeCachedReferenceCount::node_ref 0 1 830 349
/**
 * Explicitly increments the reference count.
 *
 * This function is const, even though it changes the object, because
 * generally fiddling with an object's reference count isn't considered part
 * of fiddling with the object.  An object might be const in other ways, but
 * we still need to accurately count the number of references to it.
 */
59
inline void NodeCachedReferenceCount::node_ref(void) const;

1803 10 node_unref 0 4 2033 36 NodeCachedReferenceCount::node_unref 0 1 831 201
/**
 * Explicitly decrements the node reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */
61
inline bool NodeCachedReferenceCount::node_unref(void) const;

1804 24 test_ref_count_integrity 0 4 2033 50 NodeCachedReferenceCount::test_ref_count_integrity 0 1 832 97
/**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */
75
inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const;

1805 19 get_referenced_bits 0 4 2033 45 NodeCachedReferenceCount::get_referenced_bits 0 1 833 293
/**
 * Returns the union of the values defined in the Referenced enum that
 * represents the various things that appear to be holding a pointer to this
 * object.
 *
 * If R_node is included, at least one node is holding a pointer; if R_cache
 * is included, at least one cache element is.
 */
69
inline int NodeCachedReferenceCount::get_referenced_bits(void) const;

1806 14 get_class_type 0 4 2033 40 NodeCachedReferenceCount::get_class_type 0 1 834 0
65
static TypeHandle NodeCachedReferenceCount::get_class_type(void);

1807 11 SparseArray 0 4 2035 24 SparseArray::SparseArray 0 3 835 836 837 22
/**
 *
 */

/**
 *
 */
150
inline SparseArray::SparseArray(void);
SparseArray::SparseArray(BitArray const &from);
inline SparseArray::SparseArray(SparseArray const &) = default;

1808 6 all_on 0 4 2035 19 SparseArray::all_on 0 1 838 72
/**
 * Returns a SparseArray with an infinite array of bits, all on.
 */
52
static inline SparseArray SparseArray::all_on(void);

1809 7 all_off 0 4 2035 20 SparseArray::all_off 0 1 839 56
/**
 * Returns a SparseArray whose bits are all off.
 */
53
static inline SparseArray SparseArray::all_off(void);

1810 8 lower_on 0 4 2035 21 SparseArray::lower_on 0 1 840 65
/**
 * Returns a SparseArray whose lower on_bits bits are on.
 */
61
static inline SparseArray SparseArray::lower_on(int on_bits);

1811 3 bit 0 4 2035 16 SparseArray::bit 0 1 841 64
/**
 * Returns a SparseArray with only the indicated bit on.
 */
54
static inline SparseArray SparseArray::bit(int index);

1812 5 range 0 4 2035 18 SparseArray::range 0 1 842 79
/**
 * Returns a SparseArray whose size bits, beginning at low_bit, are on.
 */
68
static inline SparseArray SparseArray::range(int low_bit, int size);

1813 16 has_max_num_bits 0 4 2035 29 SparseArray::has_max_num_bits 0 1 843 393
/**
 * Returns true if there is a maximum number of bits that may be stored in
 * this structure, false otherwise.  If this returns true, the number may be
 * queried in get_max_num_bits().
 *
 * This method always returns false.  The SparseArray has no maximum number of
 * bits.  This method is defined so generic programming algorithms can use
 * BitMask or SparseArray interchangeably.
 */
55
static inline bool SparseArray::has_max_num_bits(void);

1814 16 get_max_num_bits 0 4 2035 29 SparseArray::get_max_num_bits 0 1 844 428
/**
 * If get_max_num_bits() returned true, this method may be called to return
 * the maximum number of bits that may be stored in this structure.  It is an
 * error to call this if get_max_num_bits() return false.
 *
 * It is always an error to call this method.  The SparseArray has no maximum
 * number of bits.  This method is defined so generic programming algorithms
 * can use BitMask or SparseArray interchangeably.
 */
54
static inline int SparseArray::get_max_num_bits(void);

1815 12 get_num_bits 0 4 2035 25 SparseArray::get_num_bits 0 1 845 300
/**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */
49
inline int SparseArray::get_num_bits(void) const;

1816 7 get_bit 0 4 2035 20 SparseArray::get_bit 0 1 846 191
/**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */
50
inline bool SparseArray::get_bit(int index) const;

1817 7 set_bit 0 4 2035 20 SparseArray::set_bit 0 1 847 97
/**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
44
inline void SparseArray::set_bit(int index);

1818 9 clear_bit 0 4 2035 22 SparseArray::clear_bit 0 1 848 98
/**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */
46
inline void SparseArray::clear_bit(int index);

1819 10 set_bit_to 0 4 2035 23 SparseArray::set_bit_to 0 1 849 84
/**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */
59
inline void SparseArray::set_bit_to(int index, bool value);

1820 16 get_highest_bits 0 4 2035 29 SparseArray::get_highest_bits 0 1 850 118
/**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */
54
inline bool SparseArray::get_highest_bits(void) const;

1821 7 is_zero 0 4 2035 20 SparseArray::is_zero 0 1 851 71
/**
 * Returns true if the entire bitmask is zero, false otherwise.
 */
45
inline bool SparseArray::is_zero(void) const;

1822 9 is_all_on 0 4 2035 22 SparseArray::is_all_on 0 1 852 70
/**
 * Returns true if the entire bitmask is one, false otherwise.
 */
47
inline bool SparseArray::is_all_on(void) const;

1823 10 has_any_of 0 4 2035 23 SparseArray::has_any_of 0 1 853 82
/**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */
65
inline bool SparseArray::has_any_of(int low_bit, int size) const;

1824 10 has_all_of 0 4 2035 23 SparseArray::has_all_of 0 1 854 84
/**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */
65
inline bool SparseArray::has_all_of(int low_bit, int size) const;

1825 9 set_range 0 4 2035 22 SparseArray::set_range 0 1 855 47
/**
 * Sets the indicated range of bits on.
 */
58
inline void SparseArray::set_range(int low_bit, int size);

1826 11 clear_range 0 4 2035 24 SparseArray::clear_range 0 1 856 48
/**
 * Sets the indicated range of bits off.
 */
60
inline void SparseArray::clear_range(int low_bit, int size);

1827 12 set_range_to 0 4 2035 25 SparseArray::set_range_to 0 1 857 64
/**
 * Sets the indicated range of bits to either on or off.
 */
73
inline void SparseArray::set_range_to(bool value, int low_bit, int size);

1828 15 get_num_on_bits 0 4 2035 28 SparseArray::get_num_on_bits 0 1 858 127
/**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */
45
int SparseArray::get_num_on_bits(void) const;

1829 16 get_num_off_bits 0 4 2035 29 SparseArray::get_num_off_bits 0 1 859 127
/**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */
46
int SparseArray::get_num_off_bits(void) const;

1830 17 get_lowest_on_bit 0 4 2035 30 SparseArray::get_lowest_on_bit 0 1 860 146
/**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there are an infinite number of 1 bits.
 */
47
int SparseArray::get_lowest_on_bit(void) const;

1831 18 get_lowest_off_bit 0 4 2035 31 SparseArray::get_lowest_off_bit 0 1 861 146
/**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there are an infinite number of 1 bits.
 */
48
int SparseArray::get_lowest_off_bit(void) const;

1832 18 get_highest_on_bit 0 4 2035 31 SparseArray::get_highest_on_bit 0 1 862 143
/**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */
48
int SparseArray::get_highest_on_bit(void) const;

1833 19 get_highest_off_bit 0 4 2035 32 SparseArray::get_highest_off_bit 0 1 863 143
/**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */
49
int SparseArray::get_highest_off_bit(void) const;

1834 29 get_next_higher_different_bit 0 4 2035 42 SparseArray::get_next_higher_different_bit 0 1 864 287
/**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */
66
int SparseArray::get_next_higher_different_bit(int low_bit) const;

1835 15 invert_in_place 0 4 2035 28 SparseArray::invert_in_place 0 1 865 93
/**
 * Inverts all the bits in the SparseArray.  This is equivalent to array =
 * ~array.
 */
47
inline void SparseArray::invert_in_place(void);

1836 18 has_bits_in_common 0 4 2035 31 SparseArray::has_bits_in_common 0 1 866 181
/**
 * Returns true if this SparseArray has any "one" bits in common with the
 * other one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */
69
bool SparseArray::has_bits_in_common(SparseArray const &other) const;

1837 5 clear 0 4 2035 18 SparseArray::clear 0 1 867 52
/**
 * Sets all the bits in the SparseArray off.
 */
37
inline void SparseArray::clear(void);

1838 6 output 0 4 2035 19 SparseArray::output 0 1 868 10
/**
 *
 */
50
void SparseArray::output(std::ostream &out) const;

1839 11 operator == 0 4 2035 24 SparseArray::operator == 0 1 869 0
69
inline bool SparseArray::operator ==(SparseArray const &other) const;

1840 11 operator != 0 4 2035 24 SparseArray::operator != 0 1 870 0
69
inline bool SparseArray::operator !=(SparseArray const &other) const;

1841 10 operator < 0 4 2035 23 SparseArray::operator < 0 1 871 0
68
inline bool SparseArray::operator <(SparseArray const &other) const;

1842 10 compare_to 0 4 2035 23 SparseArray::compare_to 0 1 872 242
/**
 * Returns a number less than zero if this SparseArray sorts before the
 * indicated other SparseArray, greater than zero if it sorts after, or 0 if
 * they are equivalent.  This is based on the same ordering defined by
 * operator <.
 */
60
int SparseArray::compare_to(SparseArray const &other) const;

1843 10 operator & 0 4 2035 23 SparseArray::operator & 0 1 873 0
75
inline SparseArray SparseArray::operator &(SparseArray const &other) const;

1844 10 operator | 0 4 2035 23 SparseArray::operator | 0 1 874 0
75
inline SparseArray SparseArray::operator |(SparseArray const &other) const;

1845 10 operator ^ 0 4 2035 23 SparseArray::operator ^ 0 1 875 0
75
inline SparseArray SparseArray::operator ^(SparseArray const &other) const;

1846 10 operator ~ 0 68 2035 23 SparseArray::operator ~ 0 1 876 0
55
inline SparseArray SparseArray::operator ~(void) const;

1847 11 operator << 0 4 2035 24 SparseArray::operator << 0 1 877 0
61
inline SparseArray SparseArray::operator <<(int shift) const;

1848 11 operator >> 0 4 2035 24 SparseArray::operator >> 0 1 878 0
61
inline SparseArray SparseArray::operator >>(int shift) const;

1849 11 operator &= 0 4 2035 24 SparseArray::operator &= 0 1 879 0
56
void SparseArray::operator &=(SparseArray const &other);

1850 11 operator |= 0 4 2035 24 SparseArray::operator |= 0 1 880 0
56
void SparseArray::operator |=(SparseArray const &other);

1851 11 operator ^= 0 4 2035 24 SparseArray::operator ^= 0 1 881 0
56
void SparseArray::operator ^=(SparseArray const &other);

1852 12 operator <<= 0 4 2035 25 SparseArray::operator <<= 0 1 882 0
49
inline void SparseArray::operator <<=(int shift);

1853 12 operator >>= 0 4 2035 25 SparseArray::operator >>= 0 1 883 0
49
inline void SparseArray::operator >>=(int shift);

1854 10 is_inverse 0 4 2035 23 SparseArray::is_inverse 0 1 884 330
/**
 * If this is true, the SparseArray is actually defined as a list of subranges
 * of integers that are *not* in the set.  If this is false (the default),
 * then the subranges define the integers that *are* in the set.  This affects
 * the interpretation of the values returned by iterating through
 * get_num_subranges().
 */
48
inline bool SparseArray::is_inverse(void) const;

1855 17 get_num_subranges 0 4 2035 30 SparseArray::get_num_subranges 0 1 885 237
/**
 * Returns the number of separate subranges stored in the SparseArray.  You
 * can use this limit to iterate through the subranges, calling
 * get_subrange_begin() and get_subrange_end() for each one.
 *
 * Also see is_inverse().
 */
62
inline std::size_t SparseArray::get_num_subranges(void) const;

1856 18 get_subrange_begin 0 4 2035 31 SparseArray::get_subrange_begin 0 1 886 94
/**
 * Returns the first numeric element in the nth subrange.
 *
 * Also see is_inverse().
 */
64
inline int SparseArray::get_subrange_begin(std::size_t n) const;

1857 16 get_subrange_end 0 4 2035 29 SparseArray::get_subrange_end 0 1 887 104
/**
 * Returns the last numeric element, plus one, in the nth subrange.
 *
 * Also see is_inverse().
 */
62
inline int SparseArray::get_subrange_end(std::size_t n) const;

1858 8 __bool__ 0 4 2035 21 SparseArray::__bool__ 0 1 888 0
39
bool SparseArray::__bool__(void) const;

1859 12 __getstate__ 0 4 2035 25 SparseArray::__getstate__ 0 1 889 0
48
PyObject *SparseArray::__getstate__(void) const;

1860 12 __setstate__ 0 4 2035 25 SparseArray::__setstate__ 0 1 890 0
48
void SparseArray::__setstate__(PyObject *state);

1861 14 get_class_type 0 4 2035 27 SparseArray::get_class_type 0 1 891 0
52
static TypeHandle SparseArray::get_class_type(void);

1862 12 ~SparseArray 0 4 2035 25 SparseArray::~SparseArray 0 0 0
32
SparseArray::~SparseArray(void);

1863 14 get_value_type 0 6 2036 30 ParamValueBase::get_value_type 0 1 892 52
/**
 * Returns the type of the underlying value.
 */
69
virtual inline TypeHandle ParamValueBase::get_value_type(void) const;

1864 6 output 0 6 2036 22 ParamValueBase::output 0 1 893 0
65
virtual void ParamValueBase::output(std::ostream &out) const = 0;

1865 14 get_class_type 0 4 2036 30 ParamValueBase::get_class_type 0 1 894 0
55
static TypeHandle ParamValueBase::get_class_type(void);

1866 18 ParamTypedRefCount 0 4 2037 38 ParamTypedRefCount::ParamTypedRefCount 0 1 895 10
/**
 *
 */
80
inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value);

1867 9 get_value 0 4 2037 29 ParamTypedRefCount::get_value 0 1 896 55
/**
 * Retrieves the value stored in the parameter.
 */
70
inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const;

1868 14 get_class_type 0 4 2037 34 ParamTypedRefCount::get_class_type 0 1 897 0
59
static TypeHandle ParamTypedRefCount::get_class_type(void);

1869 10 ParamValue 0 4 2039 32 ParamValue< string >::ParamValue 0 1 898 0
66
inline ParamValue< string >::ParamValue(std::string const &value);

1870 9 set_value 0 4 2039 31 ParamValue< string >::set_value 0 1 899 0
134
inline void ParamValue< string >::set_value(std::string const &value);
inline void ParamValue< string >::set_value(Type const &value);

1871 9 get_value 0 4 2039 31 ParamValue< string >::get_value 0 1 900 0
70
inline std::string const &ParamValue< string >::get_value(void) const;

1872 14 get_class_type 0 4 2039 36 ParamValue< string >::get_class_type 0 1 901 0
61
static TypeHandle ParamValue< string >::get_class_type(void);

1873 10 ParamValue 0 4 2042 33 ParamValue< wstring >::ParamValue 0 1 902 0
68
inline ParamValue< wstring >::ParamValue(std::wstring const &value);

1874 9 set_value 0 4 2042 32 ParamValue< wstring >::set_value 0 1 903 0
137
inline void ParamValue< wstring >::set_value(std::wstring const &value);
inline void ParamValue< wstring >::set_value(Type const &value);

1875 9 get_value 0 4 2042 32 ParamValue< wstring >::get_value 0 1 904 0
72
inline std::wstring const &ParamValue< wstring >::get_value(void) const;

1876 14 get_class_type 0 4 2042 37 ParamValue< wstring >::get_class_type 0 1 905 0
62
static TypeHandle ParamValue< wstring >::get_class_type(void);

1877 10 ParamValue 0 4 2044 36 ParamValue< LVecBase2d >::ParamValue 0 1 906 0
69
inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value);

1878 9 set_value 0 4 2044 35 ParamValue< LVecBase2d >::set_value 0 1 907 0
141
inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value);
inline void ParamValue< LVecBase2d >::set_value(Type const &value);

1879 9 get_value 0 4 2044 35 ParamValue< LVecBase2d >::get_value 0 1 908 0
73
inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const;

1880 14 get_class_type 0 4 2044 40 ParamValue< LVecBase2d >::get_class_type 0 1 909 0
65
static TypeHandle ParamValue< LVecBase2d >::get_class_type(void);

1881 10 ParamValue 0 4 2046 36 ParamValue< LVecBase2f >::ParamValue 0 1 910 0
69
inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value);

1882 9 set_value 0 4 2046 35 ParamValue< LVecBase2f >::set_value 0 1 911 0
141
inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value);
inline void ParamValue< LVecBase2f >::set_value(Type const &value);

1883 9 get_value 0 4 2046 35 ParamValue< LVecBase2f >::get_value 0 1 912 0
73
inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const;

1884 14 get_class_type 0 4 2046 40 ParamValue< LVecBase2f >::get_class_type 0 1 913 0
65
static TypeHandle ParamValue< LVecBase2f >::get_class_type(void);

1885 10 ParamValue 0 4 2048 36 ParamValue< LVecBase2i >::ParamValue 0 1 914 0
69
inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value);

1886 9 set_value 0 4 2048 35 ParamValue< LVecBase2i >::set_value 0 1 915 0
141
inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value);
inline void ParamValue< LVecBase2i >::set_value(Type const &value);

1887 9 get_value 0 4 2048 35 ParamValue< LVecBase2i >::get_value 0 1 916 0
73
inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const;

1888 14 get_class_type 0 4 2048 40 ParamValue< LVecBase2i >::get_class_type 0 1 917 0
65
static TypeHandle ParamValue< LVecBase2i >::get_class_type(void);

1889 10 ParamValue 0 4 2050 36 ParamValue< LVecBase3d >::ParamValue 0 1 918 0
69
inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value);

1890 9 set_value 0 4 2050 35 ParamValue< LVecBase3d >::set_value 0 1 919 0
141
inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value);
inline void ParamValue< LVecBase3d >::set_value(Type const &value);

1891 9 get_value 0 4 2050 35 ParamValue< LVecBase3d >::get_value 0 1 920 0
73
inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const;

1892 14 get_class_type 0 4 2050 40 ParamValue< LVecBase3d >::get_class_type 0 1 921 0
65
static TypeHandle ParamValue< LVecBase3d >::get_class_type(void);

1893 10 ParamValue 0 4 2052 36 ParamValue< LVecBase3f >::ParamValue 0 1 922 0
69
inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value);

1894 9 set_value 0 4 2052 35 ParamValue< LVecBase3f >::set_value 0 1 923 0
141
inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value);
inline void ParamValue< LVecBase3f >::set_value(Type const &value);

1895 9 get_value 0 4 2052 35 ParamValue< LVecBase3f >::get_value 0 1 924 0
73
inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const;

1896 14 get_class_type 0 4 2052 40 ParamValue< LVecBase3f >::get_class_type 0 1 925 0
65
static TypeHandle ParamValue< LVecBase3f >::get_class_type(void);

1897 10 ParamValue 0 4 2054 36 ParamValue< LVecBase3i >::ParamValue 0 1 926 0
69
inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value);

1898 9 set_value 0 4 2054 35 ParamValue< LVecBase3i >::set_value 0 1 927 0
141
inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value);
inline void ParamValue< LVecBase3i >::set_value(Type const &value);

1899 9 get_value 0 4 2054 35 ParamValue< LVecBase3i >::get_value 0 1 928 0
73
inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const;

1900 14 get_class_type 0 4 2054 40 ParamValue< LVecBase3i >::get_class_type 0 1 929 0
65
static TypeHandle ParamValue< LVecBase3i >::get_class_type(void);

1901 10 ParamValue 0 4 2056 36 ParamValue< LVecBase4d >::ParamValue 0 1 930 0
69
inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value);

1902 9 set_value 0 4 2056 35 ParamValue< LVecBase4d >::set_value 0 1 931 0
141
inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value);
inline void ParamValue< LVecBase4d >::set_value(Type const &value);

1903 9 get_value 0 4 2056 35 ParamValue< LVecBase4d >::get_value 0 1 932 0
73
inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const;

1904 14 get_class_type 0 4 2056 40 ParamValue< LVecBase4d >::get_class_type 0 1 933 0
65
static TypeHandle ParamValue< LVecBase4d >::get_class_type(void);

1905 10 ParamValue 0 4 2058 36 ParamValue< LVecBase4f >::ParamValue 0 1 934 0
69
inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value);

1906 9 set_value 0 4 2058 35 ParamValue< LVecBase4f >::set_value 0 1 935 0
141
inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value);
inline void ParamValue< LVecBase4f >::set_value(Type const &value);

1907 9 get_value 0 4 2058 35 ParamValue< LVecBase4f >::get_value 0 1 936 0
73
inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const;

1908 14 get_class_type 0 4 2058 40 ParamValue< LVecBase4f >::get_class_type 0 1 937 0
65
static TypeHandle ParamValue< LVecBase4f >::get_class_type(void);

1909 10 ParamValue 0 4 2060 36 ParamValue< LVecBase4i >::ParamValue 0 1 938 0
69
inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value);

1910 9 set_value 0 4 2060 35 ParamValue< LVecBase4i >::set_value 0 1 939 0
141
inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value);
inline void ParamValue< LVecBase4i >::set_value(Type const &value);

1911 9 get_value 0 4 2060 35 ParamValue< LVecBase4i >::get_value 0 1 940 0
73
inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const;

1912 14 get_class_type 0 4 2060 40 ParamValue< LVecBase4i >::get_class_type 0 1 941 0
65
static TypeHandle ParamValue< LVecBase4i >::get_class_type(void);

1913 10 ParamValue 0 4 2062 35 ParamValue< LMatrix3d >::ParamValue 0 1 942 0
67
inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value);

1914 9 set_value 0 4 2062 34 ParamValue< LMatrix3d >::set_value 0 1 943 0
138
inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value);
inline void ParamValue< LMatrix3d >::set_value(Type const &value);

1915 9 get_value 0 4 2062 34 ParamValue< LMatrix3d >::get_value 0 1 944 0
71
inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const;

1916 14 get_class_type 0 4 2062 39 ParamValue< LMatrix3d >::get_class_type 0 1 945 0
64
static TypeHandle ParamValue< LMatrix3d >::get_class_type(void);

1917 10 ParamValue 0 4 2064 35 ParamValue< LMatrix3f >::ParamValue 0 1 946 0
67
inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value);

1918 9 set_value 0 4 2064 34 ParamValue< LMatrix3f >::set_value 0 1 947 0
138
inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value);
inline void ParamValue< LMatrix3f >::set_value(Type const &value);

1919 9 get_value 0 4 2064 34 ParamValue< LMatrix3f >::get_value 0 1 948 0
71
inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const;

1920 14 get_class_type 0 4 2064 39 ParamValue< LMatrix3f >::get_class_type 0 1 949 0
64
static TypeHandle ParamValue< LMatrix3f >::get_class_type(void);

1921 10 ParamValue 0 4 2066 35 ParamValue< LMatrix4d >::ParamValue 0 1 950 0
67
inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value);

1922 9 set_value 0 4 2066 34 ParamValue< LMatrix4d >::set_value 0 1 951 0
138
inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value);
inline void ParamValue< LMatrix4d >::set_value(Type const &value);

1923 9 get_value 0 4 2066 34 ParamValue< LMatrix4d >::get_value 0 1 952 0
71
inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const;

1924 14 get_class_type 0 4 2066 39 ParamValue< LMatrix4d >::get_class_type 0 1 953 0
64
static TypeHandle ParamValue< LMatrix4d >::get_class_type(void);

1925 10 ParamValue 0 4 2068 35 ParamValue< LMatrix4f >::ParamValue 0 1 954 0
67
inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value);

1926 9 set_value 0 4 2068 34 ParamValue< LMatrix4f >::set_value 0 1 955 0
138
inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value);
inline void ParamValue< LMatrix4f >::set_value(Type const &value);

1927 9 get_value 0 4 2068 34 ParamValue< LMatrix4f >::get_value 0 1 956 0
71
inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const;

1928 14 get_class_type 0 4 2068 39 ParamValue< LMatrix4f >::get_class_type 0 1 957 0
64
static TypeHandle ParamValue< LMatrix4f >::get_class_type(void);

1929 14 get_class_type 0 4 2075 36 WritableConfigurable::get_class_type 0 1 958 0
61
static TypeHandle WritableConfigurable::get_class_type(void);

1930 21 ~WritableConfigurable 0 4 2075 43 WritableConfigurable::~WritableConfigurable 0 0 0
50
WritableConfigurable::~WritableConfigurable(void);

1931 17 UniqueIdAllocator 0 4 2076 36 UniqueIdAllocator::UniqueIdAllocator 0 1 959 56
/**
 * Create a free id pool in the range [min:max].
 */
83
explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min = 0, uint32_t max = 20);

1932 18 ~UniqueIdAllocator 0 4 2076 37 UniqueIdAllocator::~UniqueIdAllocator 0 0 10
/**
 *
 */
44
UniqueIdAllocator::~UniqueIdAllocator(void);

1933 8 allocate 0 4 2076 27 UniqueIdAllocator::allocate 0 1 960 134
/**
 * Returns an id between _min and _max (that were passed to the constructor).
 * IndexEnd is returned if no ids are available.
 */
43
uint32_t UniqueIdAllocator::allocate(void);

1934 18 initial_reserve_id 0 4 2076 37 UniqueIdAllocator::initial_reserve_id 0 1 961 518
/**
 * This may be called to mark a particular id as having already been allocated
 * (for instance, by a prior pass).  The specified id is removed from the
 * available pool.
 *
 * Because of the limitations of this algorithm, this is most efficient when
 * it is called before the first call to allocate(), and when all the calls to
 * initial_reserve_id() are made in descending order by id.  However, this is
 * a performance warning only; if performance is not an issue, any id may be
 * reserved at any time.
 */
56
void UniqueIdAllocator::initial_reserve_id(uint32_t id);

1935 12 is_allocated 0 4 2076 31 UniqueIdAllocator::is_allocated 0 1 962 119
/**
 * Checks the allocated state of an index. Returns true for
 * indices that are currently allocated and in use.
 */
53
bool UniqueIdAllocator::is_allocated(uint32_t index);

1936 4 free 0 4 2076 23 UniqueIdAllocator::free 0 1 963 278
/**
 * Free an allocated index (index must be between _min and _max that were
 * passed to the constructor).
 *
 * Since 1.11.0, returns true if the index has been freed successfully
 * or false if the index has not been allocated yet, instead of
 * triggering an assertion.
 */
45
bool UniqueIdAllocator::free(uint32_t index);

1937 13 fraction_used 0 4 2076 32 UniqueIdAllocator::fraction_used 0 1 964 117
/**
 * return the decimal fraction of the pool that is used.  The range is 0 to
 * 1.0 (e.g.  75% would be 0.75).
 */
57
PN_stdfloat UniqueIdAllocator::fraction_used(void) const;

1938 6 output 0 4 2076 25 UniqueIdAllocator::output 0 1 965 42
/**
 * ...intended for debugging only.
 */
56
void UniqueIdAllocator::output(std::ostream &out) const;

1939 5 write 0 4 2076 24 UniqueIdAllocator::write 0 1 966 42
/**
 * ...intended for debugging only.
 */
55
void UniqueIdAllocator::write(std::ostream &out) const;

1940 39 py_decode_TypedWritable_from_bam_stream 0 1 0 39 py_decode_TypedWritable_from_bam_stream 0 1 975 203
/**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This hooks into the native pickle and cPickle modules, but it cannot
 * properly handle self-referential BAM objects.
 */
98
PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, vector_uchar const &data);

1941 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 0 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 976 398
/**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides
 * additional support for the missing persistent-state object needed to
 * properly support self-referential BAM objects written to the pickle stream.
 * This hooks into the pickle and cPickle modules implemented in
 * direct/src/stdpy.
 */
127
PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, vector_uchar const &data);

976
1 0 0 7 10 2080 995 0 0 1 4 copy 1 2078  
2 0 0 7 10 2080 995 0 0 1 4 copy 1 2081  
3 0 0 4 11 2083 0 0 0 1 4 this 3 2080  
4 0 0 6 12 2084 0 0 0 1 4 this 3 2078  
5 0 0 6 13 2085 0 0 0 2 4 this 3 2078  1 n 1 2084  
6 0 0 6 14 2085 0 0 0 2 4 this 3 2078  1 n 1 2084  
7 0 0 6 15 1978 0 0 0 1 4 this 3 2078  
8 0 0 6 16 1978 0 0 0 3 4 this 3 2078  1 n 1 2084  5 count 1 2084  
9 0 0 6 17 1949 0 0 0 1 4 this 3 2078  
10 0 0 6 18 1949 0 0 0 1 4 this 3 2078  
11 0 0 6 19 2084 0 0 0 2 4 this 3 2078  6 param0 0 2085  
12 0 0 6 20 1978 0 0 0 1 4 this 3 2078  
13 0 0 6 21 1949 0 0 0 3 4 this 3 2078  4 view 1 2086  5 flags 1 1949  
14 0 0 4 22 2083 0 0 0 2 4 this 3 2078  4 view 1 2086  
15 0 0 6 8 1950 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 2089  5 other 1 2089  
16 0 0 6 9 1950 0 0 0 2 4 this 3 2089  5 other 1 2089  
17 0 0 4 5 2083 0 0 0 1 4 this 3 2091  
18 0 0 4 6 2083 0 0 0 2 4 this 3 2092  3 out 1 2094  
19 0 0 7 25 2095 1016 0 0 1 4 copy 1 2081  
20 0 0 7 25 2095 1016 0 0 1 6 source 1 1978  
21 0 0 7 25 2095 1016 0 0 1 11 type_handle 1 2096  
22 0 0 7 26 2095 1016 0 0 2 1 n 1 2084  11 type_handle 1 2096  
23 0 0 4 27 2083 0 0 0 1 4 this 3 2095  
24 0 0 6 28 2084 0 0 0 1 4 this 3 2081  
25 0 0 4 29 2083 0 0 0 2 4 this 3 2095  1 x 1 2085  
26 0 0 4 30 2083 0 0 0 1 4 this 3 2095  
27 0 0 6 31 2085 0 0 0 2 4 this 3 2081  1 n 1 2084  
28 0 0 4 32 2083 0 0 0 3 4 this 3 2095  1 n 1 2084  5 value 1 2085  
29 0 0 6 33 2085 0 0 0 2 4 this 3 2081  1 n 1 2084  
30 0 0 4 34 2083 0 0 0 3 4 this 3 2095  1 n 1 2084  5 value 1 2085  
31 0 0 6 35 1978 0 0 0 1 4 this 3 2081  
32 0 0 4 36 2083 0 0 0 2 4 this 3 2095  4 data 1 1978  
33 0 0 6 37 1978 0 0 0 3 4 this 3 2081  1 n 1 2084  5 count 1 2084  
34 0 0 4 38 2083 0 0 0 4 4 this 3 2095  1 n 1 2084  5 count 1 2084  4 data 1 2098  
35 0 0 6 39 1949 0 0 0 1 4 this 3 2081  
36 0 0 6 40 1949 0 0 0 1 4 this 3 2081  
37 0 0 6 41 2084 0 0 0 2 4 this 3 2081  6 param0 0 2085  
38 0 0 6 42 1978 0 0 0 1 4 this 3 2081  
39 0 0 6 43 1949 0 0 0 3 4 this 3 2095  4 view 1 2086  5 flags 1 1949  
40 0 0 4 44 2083 0 0 0 2 4 this 3 2081  4 view 1 2086  
41 0 0 4 48 2083 0 0 69 /**
 * Runs the entire animation from beginning to end and stops.
 */ 1 4 this 3 2099  
42 0 0 4 48 2083 0 0 406 /**
 * Runs the animation from the frame "from" to and including the frame "to",
 * at which point the animation is stopped.  Both "from" and "to" frame
 * numbers may be outside the range (0, get_num_frames()) and the animation
 * will follow the range correctly, reporting numbers modulo get_num_frames().
 * For instance, play(0, get_num_frames() * 2) will play the animation twice
 * and then stop.
 */ 3 4 this 3 2099  4 from 1 1948  2 to 1 1948  
43 0 0 4 49 2083 0 0 169 /**
 * Starts the entire animation looping.  If restart is true, the animation is
 * restarted from the beginning; otherwise, it continues from the current
 * frame.
 */ 2 4 this 3 2099  7 restart 1 1950  
44 0 0 4 49 2083 0 0 221 /**
 * Loops the animation from the frame "from" to and including the frame "to",
 * indefinitely.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */ 4 4 this 3 2099  7 restart 1 1950  4 from 1 1948  2 to 1 1948  
45 0 0 4 50 2083 0 0 224 /**
 * Starts the entire animation bouncing back and forth between its first frame
 * and last frame.  If restart is true, the animation is restarted from the
 * beginning; otherwise, it continues from the current frame.
 */ 2 4 this 3 2099  7 restart 1 1950  
46 0 0 4 50 2083 0 0 143 /**
 * Loops the animation from the frame "from" to and including the frame "to",
 * and then back in the opposite direction, indefinitely.
 */ 4 4 this 3 2099  7 restart 1 1950  4 from 1 1948  2 to 1 1948  
47 0 0 4 51 2083 0 0 130 /**
 * Stops a currently playing or looping animation right where it is.  The
 * animation remains posed at the current frame.
 */ 1 4 this 3 2099  
48 0 0 4 52 2083 0 0 72 /**
 * Sets the animation to the indicated frame and holds it there.
 */ 2 4 this 3 2099  5 frame 1 1948  
49 0 0 4 53 2083 0 0 243 /**
 * Changes the rate at which the animation plays.  1.0 is the normal speed,
 * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to
 * pause the animation, and a negative value will play the animation
 * backwards.
 */ 2 4 this 3 2099  9 play_rate 1 1948  
50 0 0 6 54 1948 0 0 79 /**
 * Returns the rate at which the animation plays.  See set_play_rate().
 */ 1 4 this 3 2100  
51 0 0 6 55 1948 0 0 234 /**
 * Returns the native frame rate of the animation.  This is the number of
 * frames per second that will elapse when the play_rate is set to 1.0.  It is
 * a fixed property of the animation and may not be adjusted by the user.
 */ 1 4 this 3 2100  
52 0 0 6 56 1949 0 0 278 /**
 * Returns the number of frames in the animation.  This is a property of the
 * animation and may not be directly adjusted by the user (although it may
 * change without warning with certain kinds of animations, since this is a
 * virtual method that may be overridden).
 */ 1 4 this 3 2100  
53 0 0 6 57 1949 0 0 116 /**
 * Returns the current integer frame number.  This number will be in the range
 * 0 <= f < get_num_frames().
 */ 1 4 this 3 2100  
54 0 0 6 58 1949 0 0 330 /**
 * Returns the current integer frame number + 1, constrained to the range 0 <=
 * f < get_num_frames().
 *
 * If the play mode is PM_play, this will clamp to the same value as
 * get_frame() at the end of the animation.  If the play mode is any other
 * value, this will wrap around to frame 0 at the end of the animation.
 */ 1 4 this 3 2100  
55 0 0 6 59 1948 0 0 314 /**
 * Returns the fractional part of the current frame.  Normally, this is in the
 * range 0.0 <= f < 1.0, but in the one special case of an animation playing
 * to its end frame and stopping, it might exactly equal 1.0.
 *
 * It will always be true that get_full_frame() + get_frac() ==
 * get_full_fframe().
 */ 1 4 this 3 2100  
56 0 0 6 60 1949 0 0 372 /**
 * Returns the current integer frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_fframe(), this return value will
 * never exceed the value passed to to_frame in the play() method.
 */ 1 4 this 3 2100  
57 0 0 6 61 1948 0 0 490 /**
 * Returns the current floating-point frame number.
 *
 * Unlike the value returned by get_frame(), this frame number may extend
 * beyond the range of get_num_frames() if the frame range passed to play(),
 * loop(), etc.  did.
 *
 * Unlike the value returned by get_full_frame(), this return value may equal
 * (to_frame + 1.0), when the animation has played to its natural end.
 * However, in this case the return value of get_full_frame() will be
 * to_frame, not (to_frame + 1).
 */ 1 4 this 3 2100  
58 0 0 6 62 1950 0 0 208 /**
 * Returns true if the animation is currently playing, false if it is stopped
 * (e.g.  because stop() or pose() was called, or because it reached the end
 * of the animation after play() was called).
 */ 1 4 this 3 2100  
59 0 0 4 63 2083 0 0 10 /**
 *
 */ 2 4 this 3 2100  3 out 1 2094  
60 0 0 7 76 2096 0 0 0 0 
61 0 0 7 79 2102 1055 0 55 /**
 * Creates an UpdateSeq in the 'initial' state.
 */ 0 
62 0 0 7 79 2102 1055 0 10 /**
 *
 */ 1 4 copy 1 2103  
63 0 0 7 80 2102 1055 0 0 0 
64 0 0 7 81 2102 1055 0 0 0 
65 0 0 7 82 2102 1055 0 0 0 
66 0 0 6 83 2102 0 0 10 /**
 *
 */ 2 4 this 3 2102  4 copy 1 2103  
67 0 0 4 84 2083 0 0 55 /**
 * Resets the UpdateSeq to the 'initial' state.
 */ 1 4 this 3 2102  
68 0 0 6 85 1950 0 0 67 /**
 * Returns true if the UpdateSeq is in the 'initial' state.
 */ 1 4 this 3 2103  
69 0 0 6 86 1950 0 0 63 /**
 * Returns true if the UpdateSeq is in the 'old' state.
 */ 1 4 this 3 2103  
70 0 0 6 87 1950 0 0 65 /**
 * Returns true if the UpdateSeq is in the 'fresh' state.
 */ 1 4 this 3 2103  
71 0 0 6 88 1950 0 0 105 /**
 * Returns true if the UpdateSeq is in any special states, i.e.  'initial',
 * 'old', or 'fresh'.
 */ 1 4 this 3 2103  
72 0 0 6 89 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
73 0 0 6 90 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
74 0 0 6 91 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
75 0 0 6 92 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
76 0 0 6 93 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
77 0 0 6 94 1950 0 0 0 2 4 this 3 2103  5 other 1 2103  
78 0 0 7 95 2102 1055 0 0 1 4 this 3 2102  
79 0 0 7 96 2102 1055 0 0 2 4 this 3 2102  6 param0 0 1949  
80 0 0 6 97 1953 0 0 107 /**
 * Returns the internal integer value associated with the UpdateSeq.  Useful
 * for debugging only.
 */ 1 4 this 3 2103  
81 0 0 4 102 2083 0 0 10 /**
 *
 */ 2 4 this 3 2103  3 out 1 2094  
82 0 0 4 106 2083 0 0 308 /**
 * This internal function is intended to be called by each class's
 * make_from_bam() method to read in all of the relevant data from the BamFile
 * for the new object.  It is also called directly by the BamReader to re-read
 * the data for an object that has been placed on the stream for an update.
 */ 3 4 this 3 1965  4 scan 1 2105  7 manager 1 2107  
83 0 0 4 107 2083 0 0 345 /**
 * Increments the bam_modified counter, so that this object will be
 * invalidated and retransmitted on any open bam streams.  This should
 * normally not need to be called by user code; it should be called internally
 * when the object has been changed in a way that legitimately requires its
 * retransmission to any connected clients.
 */ 1 4 this 3 1965  
84 0 0 7 108 2102 1055 0 140 /**
 * Returns the current bam_modified counter.  This counter is normally
 * incremented automatically whenever the object is modified.
 */ 1 4 this 3 2108  
85 0 0 6 109 1978 0 0 0 1 4 this 3 2108  
86 0 0 6 110 1978 0 0 0 2 4 this 3 2108  7 pickler 1 1978  
87 0 0 6 111 2014 0 0 423 /**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and returns that data as a bytes object.  Returns an empty bytes
 * object on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */ 1 4 this 3 2108  
88 0 0 6 111 1950 0 0 429 /**
 * Converts the TypedWritable object into a single stream of data using a
 * BamWriter, and stores that data in the indicated string.  Returns true on
 * success, false on failure.
 *
 * This is a convenience method particularly useful for cases when you are
 * only serializing a single object.  If you have many objects to process, it
 * is more efficient to use the same BamWriter to serialize all of them
 * together.
 */ 3 4 this 3 2108  4 data 1 2110  6 writer 1 2111  
89 0 0 7 113 2096 0 0 0 0 
90 0 0 7 120 2112 1070 0 491 /**
 * Reads the bytes created by a previous call to encode_to_bam_stream(), and
 * extracts and returns the single object on those bytes.  Returns NULL on
 * error.
 *
 * This method is intended to replace decode_raw_from_bam_stream() when you
 * know the stream in question returns an object of type
 * TypedWritableReferenceCount, allowing for easier reference count
 * management.  Note that the caller is still responsible for maintaining the
 * reference count on the return value.
 */ 2 4 data 1 2014  6 reader 1 2107  
91 0 0 7 121 2096 0 0 0 0 
92 0 0 6 115 1965 0 0 0 1 4 this 3 2112  
93 0 0 7 118 2113 0 0 0 1 4 this 3 2112  
94 0 0 7 130 2116 1075 0 179 /**
 * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a
 * data pointer set, even though one may have been assigned to the original
 * via set_data().
 */ 1 4 this 3 2114  
95 0 0 6 131 1950 0 0 0 2 4 this 3 2114  5 other 1 2114  
96 0 0 6 132 2117 0 0 237 /**
 * Returns the full pathname to the source file that originally generated this
 * cache request.  In some cases, for instance in the case of a of a multipage
 * texture like "cube_#.png", this may not not a true filename on disk.
 */ 1 4 this 3 2114  
97 0 0 6 133 2117 0 0 230 /**
 * Returns the name of the cache file as hashed from the source_pathname.
 * This will be relative to the root of the cache directory, and it will not
 * include any suffixes that may be appended to resolve hash conflicts.
 */ 1 4 this 3 2114  
98 0 0 6 134 1964 0 0 204 /**
 * Returns the file timestamp of the original source file that generated this
 * cache record, if available.  In some cases the original file timestamp is
 * not available, and this will return 0.
 */ 1 4 this 3 2114  
99 0 0 6 135 1964 0 0 84 /**
 * Returns the time at which this particular record was recorded or updated.
 */ 1 4 this 3 2114  
100 0 0 6 143 1949 0 0 75 /**
 * Returns the number of source files that contribute to the cache.
 */ 1 4 this 3 2114  
101 0 0 6 144 2117 0 0 94 /**
 * Returns the full pathname of the nth source files that contributes to the
 * cache.
 */ 2 4 this 3 2114  1 n 1 1949  
102 0 0 6 145 1950 0 0 124 /**
 * Returns true if all of the dependent files are still the same as when the
 * cache was recorded, false otherwise.
 */ 1 4 this 3 2114  
103 0 0 4 146 2083 0 0 80 /**
 * Empties the list of files that contribute to the data in this record.
 */ 1 4 this 3 2116  
104 0 0 4 147 2083 0 0 225 /**
 * Adds the indicated file to the list of files that will be loaded to
 * generate the data in this record.  This should be called once for the
 * primary source file, and again for each secondary source file, if any.
 */ 2 4 this 3 2116  8 pathname 1 2117  
105 0 0 4 147 2083 0 0 82 /**
 * Variant of add_dependent_file that takes an already opened VirtualFile.
 */ 2 4 this 3 2116  4 file 1 2118  
106 0 0 6 148 1950 0 0 130 /**
 * Returns true if this cache record has an in-memory data object associated--
 * that is, the object stored in the cache.
 */ 1 4 this 3 2114  
107 0 0 4 149 2083 0 0 147 /**
 * Removes the in-memory data object associated with this record, if any.
 * This does not affect the on-disk representation of the record.
 */ 1 4 this 3 2116  
108 0 0 6 150 1965 0 0 139 /**
 * Returns a pointer to the data stored in the record, or NULL if there is no
 * data.  The pointer is not removed from the record.
 */ 1 4 this 3 2114  
109 0 0 4 152 2083 0 0 104 /**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritable.
 */ 2 4 this 3 2116  3 ptr 1 1965  
110 0 0 4 152 2083 0 0 573 /**
 * Stores a new data object on the record.  You should pass the same pointer
 * twice, to both parameters; this allows the C++ typecasting to automatically
 * convert the pointer into both a TypedWritable and a ReferenceCount pointer,
 * so that the BamCacheRecord object can reliably manage the reference counts.
 *
 * You may pass 0 or NULL as the second parameter.  If you do this, the
 * BamCacheRecord will not manage the object's reference count; it will be up
 * to you to ensure the object is not deleted during the lifetime of the
 * BamCacheRecord object.
 */ 3 4 this 3 2116  3 ptr 1 1965  7 ref_ptr 1 2113  
111 0 0 4 152 2083 0 0 115 /**
 * This variant on set_data() is provided just to allow Python code to pass a
 * 0 as the second parameter.
 */ 3 4 this 3 2116  3 ptr 1 1965  5 dummy 1 1949  
112 0 0 4 152 2083 0 0 118 /**
 * This variant on set_data() is provided to easily pass objects deriving from
 * TypedWritableReferenceCount.
 */ 2 4 this 3 2116  3 ptr 1 2112  
113 0 0 4 155 2083 0 0 10 /**
 *
 */ 2 4 this 3 2114  3 out 1 2094  
114 0 0 4 156 2083 0 0 10 /**
 *
 */ 3 4 this 3 2114  3 out 1 2094  12 indent_level 1 1949  
115 0 0 7 157 2096 0 0 0 0 
116 0 0 7 124 2112 1070 0 0 1 4 this 3 2116  
117 0 0 7 159 2121 1096 0 10 /**
 *
 */ 0 
118 0 0 4 161 2083 0 0 347 /**
 * Changes the state of the active flag.  "active" means that the cache should
 * be consulted automatically on loads, "not active" means that objects should
 * be loaded directly without consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */ 2 4 this 3 2121  4 flag 1 1950  
119 0 0 6 162 1950 0 0 381 /**
 * Returns true if the BamCache is currently active, false if it is not.
 * "active" means that the cache should be consulted automatically on loads,
 * "not active" means that objects should be loaded directly without
 * consulting the cache.
 *
 * This represents the global flag.  Also see the individual cache_models,
 * cache_textures, cache_compressed_textures flags.
 */ 1 4 this 3 2122  
120 0 0 4 163 2083 0 0 118 /**
 * Indicates whether model files (e.g.  egg files and bam files) will be
 * stored in the cache, as bam files.
 */ 2 4 this 3 2121  4 flag 1 1950  
121 0 0 6 164 1950 0 0 172 /**
 * Returns whether model files (e.g.  egg files and bam files) will be stored
 * in the cache, as bam files.
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2122  
122 0 0 4 165 2083 0 0 101 /**
 * Indicates whether texture files will be stored in the cache, as
 * uncompressed txo files.
 */ 2 4 this 3 2121  4 flag 1 1950  
123 0 0 6 166 1950 0 0 174 /**
 * Returns whether texture files (e.g.  egg files and bam files) will be
 * stored in the cache, as txo files.
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2122  
124 0 0 4 167 2083 0 0 722 /**
 * Indicates whether compressed texture files will be stored in the cache, as
 * compressed txo files.  The compressed data may either be generated in-CPU,
 * via the squish library, or it may be extracted from the GSG after the
 * texture has been loaded.
 *
 * This may be set in conjunction with set_cache_textures(), or independently
 * of it.  If set_cache_textures() is true and this is false, all textures
 * will be cached in their uncompressed form.  If set_cache_textures() is
 * false and this is true, only compressed textures will be cached, and they
 * will be cached in their compressed form.  If both are true, all textures
 * will be cached, in their uncompressed or compressed form appropriately.
 */ 2 4 this 3 2121  4 flag 1 1950  
125 0 0 6 168 1950 0 0 202 /**
 * Returns whether compressed texture files will be stored in the cache, as
 * compressed txo files.  See set_cache_compressed_textures().
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2122  
126 0 0 4 169 2083 0 0 184 /**
 * Indicates whether compiled shader programs will be stored in the cache, as
 * binary .sho files.  This may not be supported by all shader languages or
 * graphics renderers.
 */ 2 4 this 3 2121  4 flag 1 1950  
127 0 0 6 170 1950 0 0 196 /**
 * Returns whether compiled shader programs will be stored in the cache, as
 * binary .txo files.  See set_cache_compiled_shaders().
 *
 * This also returns false if get_active() is false.
 */ 1 4 this 3 2122  
128 0 0 4 171 2083 0 0 372 /**
 * Changes the current root pathname of the cache.  This specifies where the
 * cache files are stored on disk.  This should name a directory that is on a
 * disk local to the machine (not on a network-mounted disk), for instance,
 * /tmp/panda-cache or /c/panda-cache.
 *
 * If the directory does not already exist, it will be created as a result of
 * this call.
 */ 2 4 this 3 2121  4 root 1 2117  
129 0 0 7 172 2124 0 0 75 /**
 * Returns the current root pathname of the cache.  See set_root().
 */ 1 4 this 3 2122  
130 0 0 4 173 2083 0 0 86 /**
 * Specifies the time in seconds between automatic flushes of the cache index.
 */ 2 4 this 3 2121  10 flush_time 1 1949  
131 0 0 6 174 1949 0 0 84 /**
 * Returns the time in seconds between automatic flushes of the cache index.
 */ 1 4 this 3 2122  
132 0 0 4 175 2083 0 0 430 /**
 * Specifies the maximum size, in kilobytes, which the cache is allowed to
 * grow to.  If a newly cached file would exceed this size, an older file is
 * removed from the cache.
 *
 * Note that in the case of multiple different processes simultaneously
 * operating on the same cache directory, the actual cache size may slightly
 * exceed this value from time to time due to latency in checking between the
 * processes.
 */ 2 4 this 3 2121  10 max_kbytes 1 1949  
133 0 0 6 176 1949 0 0 121 /**
 * Returns the maximum size, in kilobytes, which the cache is allowed to grow
 * to.  See set_cache_max_kbytes().
 */ 1 4 this 3 2122  
134 0 0 4 177 2083 0 0 252 /**
 * Can be used to put the cache in read-only mode, or take it out of read-only
 * mode.  Note that if you put it into read-write mode, and it discovers that
 * it does not have write access, it will put itself right back into read-only
 * mode.
 */ 2 4 this 3 2121  2 ro 1 1950  
135 0 0 6 178 1950 0 0 230 /**
 * Returns true if the cache is in read-only mode.  Normally, the cache starts
 * in read-write mode.  It can put itself into read-only mode automatically if
 * it discovers that it does not have write access to the cache.
 */ 1 4 this 3 2122  
136 0 0 7 179 2116 1075 0 782 /**
 * Looks up a file in the cache.
 *
 * If the file is cacheable, then regardless of whether the file is found in
 * the cache or not, this returns a BamCacheRecord.  On the other hand, if the
 * file cannot be cached, returns NULL.
 *
 * If record->has_data() returns true, then the file was found in the cache,
 * and you may call record->extract_data() to get the object.  If
 * record->has_data() returns false, then the file was not found in the cache
 * or the cache was stale; and you should reload the source file (calling
 * record->add_dependent_file() for each file loaded, including the original
 * source file), and then call record->set_data() to record the resulting
 * loaded object; and finally, you should call store() to write the cached
 * record to disk.
 */ 3 4 this 3 2121  15 source_filename 1 2117  15 cache_extension 1 2098  
137 0 0 6 180 1950 0 0 212 /**
 * Flushes a cache entry to disk.  You must have retrieved the cache record
 * via a prior call to lookup(), and then stored the data via
 * record->set_data().  Returns true on success, false on failure.
 */ 2 4 this 3 2121  6 record 1 2116  
138 0 0 4 181 2083 0 0 92 /**
 * Flushes the index if enough time has elapsed since the index was last
 * flushed.
 */ 1 4 this 3 2121  
139 0 0 4 182 2083 0 0 48 /**
 * Ensures the index is written to disk.
 */ 1 4 this 3 2121  
140 0 0 4 183 2083 0 0 63 /**
 * Writes the contents of the index to standard output.
 */ 3 4 this 3 2122  3 out 1 2094  12 indent_level 1 1949  
141 0 0 6 184 2121 0 0 124 /**
 * Returns a pointer to the global BamCache object, which is used
 * automatically by the ModelPool and TexturePool.
 */ 0 
142 0 0 4 185 2083 0 0 84 /**
 * If there is a global BamCache object, calls consider_flush_index() on it.
 */ 0 
143 0 0 4 186 2083 0 0 75 /**
 * If there is a global BamCache object, calls flush_index() on it.
 */ 0 
144 0 0 7 200 2125 1124 0 0 0 
145 0 0 7 200 2125 1124 0 0 1 6 param0 0 2126  
146 0 0 7 205 2129 1135 0 0 1 6 param0 0 2128  
147 0 0 7 205 2129 1135 0 10 /**
 *
 */ 1 5 flags 1 1949  
148 0 0 7 205 2129 1135 0 10 /**
 *
 */ 2 5 flags 1 1949  13 texture_flags 1 1949  
149 0 0 4 206 2083 0 0 10 /**
 *
 */ 2 4 this 3 2129  5 flags 1 1949  
150 0 0 6 207 1949 0 0 10 /**
 *
 */ 1 4 this 3 2128  
151 0 0 4 209 2083 0 0 10 /**
 *
 */ 2 4 this 3 2129  5 flags 1 1949  
152 0 0 6 210 1949 0 0 10 /**
 *
 */ 1 4 this 3 2128  
153 0 0 4 211 2083 0 0 459 /**
 * Specifies the expected number of views to load for the texture.  This is
 * ignored unless TF_multiview is included in texture_flags.  This must be
 * specified when loading a 3-d multiview texture or 2-d texture array, in
 * which case it is used to differentiate z levels from separate views; it
 * may be zero in the case of 2-d textures or cube maps, in which case the
 * number of views can be inferred from the number of images found on disk.
 */ 2 4 this 3 2129  9 num_views 1 1949  
154 0 0 6 212 1949 0 0 39 /**
 * See set_texture_num_views().
 */ 1 4 this 3 2128  
155 0 0 4 215 2083 0 0 209 /**
 * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a
 * texture is scaled from disk when it is subsequently loaded.  Set it to
 * ATS_unspecified to restore the default behavior.
 */ 2 4 this 3 2129  5 scale 1 1951  
156 0 0 6 216 1951 0 0 40 /**
 * See set_auto_texture_scale().
 */ 1 4 this 3 2128  
157 0 0 4 218 2083 0 0 10 /**
 *
 */ 2 4 this 3 2128  3 out 1 2094  
158 0 0 7 221 2107 1137 0 38 // The primary interface for a caller. 1 6 source 1 1975  
159 0 0 4 223 2083 0 0 142 /**
 * Changes the source of future datagrams for this BamReader.  This also
 * implicitly calls init() if it has not already been called.
 */ 2 4 this 3 2107  6 source 1 1975  
160 0 0 6 224 1975 0 0 100 /**
 * Returns the current source of the BamReader as set by set_source() or the
 * constructor.
 */ 1 4 this 3 2107  
161 0 0 6 225 1950 0 0 210 /**
 * Initializes the BamReader prior to reading any objects from its source.
 * This includes reading the Bam header.
 *
 * This returns true if the BamReader successfully initialized, false
 * otherwise.
 */ 1 4 this 3 2107  
162 0 0 4 226 2083 0 0 1007 /**
 * Associates an arbitrary block of data with the indicated object (or NULL),
 * and the indicated name.
 *
 * This is intended to provide a place for temporary storage for objects
 * reading themselves from the bam file.  To use it, inherit from
 * BamReader::AuxData and store whatever data you like there.  Then associate
 * your AuxData with the object as it is being read with set_aux_data().  You
 * may later set the aux data to NULL to remove it; or it will automatically
 * be removed (and deleted) after finalize() is called for the object in
 * question.
 *
 * If the TypedWritable pointer is NULL, the the aux data is stored globally
 * for the BamReader in general.  This pointer is available to any bam
 * objects, and will not be automatically removed until the BamReader itself
 * destructs.
 *
 * In either case, the name is just an arbitrary user-defined key.  If there
 * is already a data pointer stored for the obj/name pair, that data pointer
 * will be replaced (and deleted).
 */ 4 4 this 3 2107  3 obj 1 1965  4 name 1 2098  4 data 1 2130  
163 0 0 7 227 2130 0 0 173 /**
 * Returns the pointer previously associated with the bam reader by a previous
 * call to set_aux_data(), or NULL if data with the indicated key has not been
 * set.
 */ 3 4 this 3 2132  3 obj 1 1965  4 name 1 2098  
164 0 0 6 228 2117 0 0 199 /**
 * If a BAM is a file, then the BamReader should contain the name of the file.
 * This enables the reader to interpret pathnames in the BAM as relative to
 * the directory containing the BAM.
 */ 1 4 this 3 2132  
165 0 0 6 229 2128 0 0 98 /**
 * Returns the LoaderOptions passed to the loader when the model was
 * requested, if any.
 */ 1 4 this 3 2132  
166 0 0 4 230 2083 0 0 58 /**
 * Specifies the LoaderOptions for this BamReader.
 */ 2 4 this 3 2107  7 options 1 2128  
167 0 0 6 231 1965 0 0 1059 /**
 * Reads a single object from the Bam file.  If the object type is known, a
 * new object of the appropriate type is created and returned; otherwise, NULL
 * is returned.  NULL is also returned when the end of the file is reached.
 * is_eof() may be called to differentiate between these two cases.
 *
 * This may be called repeatedly to extract out all the objects in the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is retrieved directly from the Bam file:
 * the root of the scene graph.  The remaining objects will all be retrieved
 * recursively by the first object.
 *
 * Note that the object returned may not yet be complete.  In particular, some
 * of its pointers may not be filled in; you must call resolve() to fill in
 * all the available pointers before you can safely use any objects returned
 * by read_object().
 *
 * This flavor of read_object() requires the caller to know what type of
 * object it has received in order to properly manage the reference counts.
 */ 1 4 this 3 2107  
168 0 0 6 232 1950 0 0 138 /**
 * Returns true if the reader has reached end-of-file, false otherwise.  This
 * call is only valid after a call to read_object().
 */ 1 4 this 3 2132  
169 0 0 6 233 1950 0 0 565 /**
 * This may be called at any time during processing of the Bam file to resolve
 * all the known pointers so far.  It is usually called at the end of the
 * processing, after all objects have been read, which is generally the best
 * time to call it.
 *
 * This must be called at least once after reading a particular object via
 * get_object() in order to validate that object.
 *
 * The return value is true if all objects have been resolved, or false if
 * some objects are still outstanding (in which case you will need to call
 * resolve() again later).
 */ 1 4 this 3 2107  
170 0 0 6 234 1950 0 0 406 /**
 * Indicates that an object recently read from the bam stream should be
 * replaced with a new object.  Any future occurrences of the original object
 * in the stream will henceforth return the new object instead.
 *
 * The return value is true if the replacement was successfully made, or false
 * if the object was not read from the stream (or if change_pointer had
 * already been called on it).
 */ 3 4 this 3 2107  12 orig_pointer 1 2108  11 new_pointer 1 2108  
171 0 0 6 235 1949 0 0 81 /**
 * Returns the major version number of the Bam file currently being read.
 */ 1 4 this 3 2132  
172 0 0 6 236 1949 0 0 81 /**
 * Returns the minor version number of the Bam file currently being read.
 */ 1 4 this 3 2132  
173 0 0 6 237 1968 0 0 254 /**
 * Returns the endian preference indicated by the Bam file currently being
 * read.  This does not imply that every number is stored using the indicated
 * convention, but individual objects may choose to respect this flag when
 * recording data.
 */ 1 4 this 3 2132  
174 0 0 6 238 1950 0 0 220 /**
 * Returns true if the file stores all "standard" floats as 64-bit doubles, or
 * false if they are 32-bit floats.  This is determined by the compilation
 * flags of the version of Panda that generated this file.
 */ 1 4 this 3 2132  
175 0 0 6 239 1949 0 0 174 /**
 * Returns the major version number of Bam files supported by the current code
 * base.  This must match get_file_major_ver() in order to successfully read a
 * file.
 */ 1 4 this 3 2132  
176 0 0 6 240 1949 0 0 184 /**
 * Returns the minor version number of Bam files supported by the current code
 * base.  This must match or exceed get_file_minor_ver() in order to
 * successfully read a file.
 */ 1 4 this 3 2132  
177 0 0 6 241 1978 0 0 0 1 4 this 3 2132  
178 0 0 4 254 2083 0 0 0 2 6 handle 1 2096  4 func 1 1978  
179 0 0 7 256 2111 1159 0 0 1 6 param0 0 2134  
180 0 0 7 256 2111 1159 0 10 /**
 *
 */ 1 6 target 1 1982  
181 0 0 4 258 2083 0 0 153 /**
 * Changes the destination of future datagrams written by the BamWriter.  This
 * also implicitly calls init() if it has not already been called.
 */ 2 4 this 3 2111  6 target 1 1982  
182 0 0 6 259 1982 0 0 100 /**
 * Returns the current target of the BamWriter as set by set_target() or the
 * constructor.
 */ 1 4 this 3 2111  
183 0 0 6 260 1950 0 0 220 /**
 * Initializes the BamWriter prior to writing any objects to its output
 * stream.  This includes writing out the Bam header.
 *
 * This returns true if the BamWriter successfully initialized, false
 * otherwise.
 */ 1 4 this 3 2111  
184 0 0 6 261 2117 0 0 197 /**
 * If a BAM is a file, then the BamWriter should contain the name of the file.
 * This enables the writer to convert pathnames in the BAM to relative to the
 * directory containing the BAM.
 */ 1 4 this 3 2134  
185 0 0 6 262 1950 0 0 736 /**
 * Writes a single object to the Bam file, so that the
 * BamReader::read_object() can later correctly restore the object and all its
 * pointers.
 *
 * This implicitly also writes any additional objects this object references
 * (if they haven't already been written), so that pointers may be fully
 * resolved.
 *
 * This may be called repeatedly to write a sequence of objects to the Bam
 * file, but typically (especially for scene graph files, indicated with the
 * .bam extension), only one object is written directly from the Bam file: the
 * root of the scene graph.  The remaining objects will all be written
 * recursively by the first object.
 *
 * Returns true if the object is successfully written, false otherwise.
 */ 2 4 this 3 2111  3 obj 1 2108  
186 0 0 6 263 1950 0 0 170 /**
 * Returns true if the object has previously been written (or at least
 * requested to be written) to the bam file, or false if we've never heard of
 * it before.
 */ 2 4 this 3 2134  3 obj 1 2108  
187 0 0 4 264 2083 0 0 85 /**
 * Ensures that all data written thus far is manifested on the output stream.
 */ 1 4 this 3 2111  
188 0 0 6 265 1949 0 0 84 /**
 * Returns the major version number of the Bam file currently being written.
 */ 1 4 this 3 2134  
189 0 0 6 266 1949 0 0 84 /**
 * Returns the minor version number of the Bam file currently being written.
 */ 1 4 this 3 2134  
190 0 0 4 267 2083 0 0 232 /**
 * Changes the minor .bam version to write.  This should be called before
 * init().  Each Panda version has only a fairly narrow range of versions it
 * is able to write; consult the .bam documentation for more information.
 */ 2 4 this 3 2111  9 minor_ver 1 1949  
191 0 0 6 268 1968 0 0 257 /**
 * Returns the endian preference indicated by the Bam file currently being
 * written.  This does not imply that every number is stored using the
 * indicated convention, but individual objects may choose to respect this
 * flag when recording data.
 */ 1 4 this 3 2134  
192 0 0 6 269 1950 0 0 248 /**
 * Returns true if the file will store all "standard" floats as 64-bit
 * doubles, or false if they are 32-bit floats.  This isn't runtime settable;
 * it's based on the compilation flags of the version of Panda that generated
 * this file.
 */ 1 4 this 3 2134  
193 0 0 6 270 1970 0 0 196 /**
 * Returns the BamTextureMode preference indicated by the Bam file currently
 * being written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */ 1 4 this 3 2134  
194 0 0 4 271 2083 0 0 187 /**
 * Changes the BamTextureMode preference for the Bam file currently being
 * written.  Texture objects written to this Bam file will be encoded
 * according to the specified mode.
 */ 2 4 this 3 2111  17 file_texture_mode 1 1970  
195 0 0 6 272 1965 0 0 165 /**
 * Returns the root node of the part of the scene graph we are currently
 * writing out.  This is used for determining what to make NodePaths relative
 * to.
 */ 1 4 this 3 2134  
196 0 0 4 273 2083 0 0 160 /**
 * Sets the root node of the part of the scene graph we are currently writing
 * out.  NodePaths written to this bam file will be relative to this node.
 */ 2 4 this 3 2111  9 root_node 1 1965  
197 0 0 7 283 2136 1240 0 0 0 
198 0 0 7 283 2136 1240 0 0 1 6 param0 0 2137  
199 0 0 7 283 2136 1240 0 0 1 10 init_value 1 2139  
200 0 0 7 284 2136 1240 0 0 0 
201 0 0 7 285 2136 1240 0 0 0 
202 0 0 7 286 2136 1240 0 0 1 7 on_bits 1 1949  
203 0 0 7 287 2136 1240 0 0 1 5 index 1 1949  
204 0 0 7 288 2136 1240 0 0 2 7 low_bit 1 1949  4 size 1 1949  
205 0 0 6 289 1950 0 0 0 0 
206 0 0 6 290 1949 0 0 0 0 
207 0 0 6 291 1949 0 0 0 1 4 this 3 2137  
208 0 0 6 292 1950 0 0 0 2 4 this 3 2137  5 index 1 1949  
209 0 0 4 293 2083 0 0 0 2 4 this 3 2136  5 index 1 1949  
210 0 0 4 294 2083 0 0 0 2 4 this 3 2136  5 index 1 1949  
211 0 0 4 295 2083 0 0 0 3 4 this 3 2136  5 index 1 1949  5 value 1 1950  
212 0 0 6 296 1950 0 0 0 1 4 this 3 2137  
213 0 0 6 297 1950 0 0 0 1 4 this 3 2137  
214 0 0 6 298 2139 0 0 0 3 4 this 3 2137  7 low_bit 1 1949  4 size 1 1949  
215 0 0 4 299 2083 0 0 0 4 4 this 3 2136  5 value 1 2139  7 low_bit 1 1949  4 size 1 1949  
216 0 0 6 300 1950 0 0 0 3 4 this 3 2137  7 low_bit 1 1949  4 size 1 1949  
217 0 0 6 301 1950 0 0 0 3 4 this 3 2137  7 low_bit 1 1949  4 size 1 1949  
218 0 0 4 302 2083 0 0 0 3 4 this 3 2136  7 low_bit 1 1949  4 size 1 1949  
219 0 0 4 303 2083 0 0 0 3 4 this 3 2136  7 low_bit 1 1949  4 size 1 1949  
220 0 0 4 304 2083 0 0 0 4 4 this 3 2136  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
221 0 0 6 305 2139 0 0 0 1 4 this 3 2137  
222 0 0 4 306 2083 0 0 0 2 4 this 3 2136  5 value 1 2139  
223 0 0 6 307 1949 0 0 0 1 4 this 3 2137  
224 0 0 6 308 1949 0 0 0 1 4 this 3 2137  
225 0 0 6 309 1949 0 0 0 1 4 this 3 2137  
226 0 0 6 310 1949 0 0 0 1 4 this 3 2137  
227 0 0 6 311 1949 0 0 0 1 4 this 3 2137  
228 0 0 6 312 1949 0 0 0 1 4 this 3 2137  
229 0 0 6 313 1949 0 0 0 2 4 this 3 2137  7 low_bit 1 1949  
230 0 0 4 314 2083 0 0 0 1 4 this 3 2136  
231 0 0 6 315 1950 0 0 0 2 4 this 3 2137  5 other 1 2137  
232 0 0 4 316 2083 0 0 0 1 4 this 3 2136  
233 0 0 4 317 2083 0 0 0 2 4 this 3 2137  3 out 1 2094  
234 0 0 4 318 2083 0 0 0 3 4 this 3 2137  3 out 1 2094  12 spaces_every 1 1949  
235 0 0 4 319 2083 0 0 0 3 4 this 3 2137  3 out 1 2094  12 spaces_every 1 1949  
236 0 0 4 320 2083 0 0 0 3 4 this 3 2137  3 out 1 2094  12 indent_level 1 1949  
237 0 0 6 321 1950 0 0 0 2 4 this 3 2137  5 other 1 2137  
238 0 0 6 322 1950 0 0 0 2 4 this 3 2137  5 other 1 2137  
239 0 0 6 323 1950 0 0 0 2 4 this 3 2137  5 other 1 2137  
240 0 0 6 324 1949 0 0 0 2 4 this 3 2137  5 other 1 2137  
241 0 0 7 325 2136 1240 0 0 2 4 this 3 2137  5 other 1 2137  
242 0 0 7 326 2136 1240 0 0 2 4 this 3 2137  5 other 1 2137  
243 0 0 7 327 2136 1240 0 0 2 4 this 3 2137  5 other 1 2137  
244 0 0 7 328 2136 1240 0 0 1 4 this 3 2137  
245 0 0 7 329 2136 1240 0 0 2 4 this 3 2137  5 shift 1 1949  
246 0 0 7 330 2136 1240 0 0 2 4 this 3 2137  5 shift 1 1949  
247 0 0 6 331 2136 0 0 0 2 4 this 3 2136  5 other 1 2137  
248 0 0 6 332 2136 0 0 0 2 4 this 3 2136  5 other 1 2137  
249 0 0 6 333 2136 0 0 0 2 4 this 3 2136  5 other 1 2137  
250 0 0 6 334 2136 0 0 0 2 4 this 3 2136  5 shift 1 1949  
251 0 0 6 335 2136 0 0 0 2 4 this 3 2136  5 shift 1 1949  
252 0 0 4 336 2083 0 0 0 1 4 this 3 2136  
253 0 0 4 337 2083 0 0 0 1 4 this 3 2136  
254 0 0 7 338 2136 1240 0 0 1 4 this 3 2137  
255 0 0 7 339 2136 1240 0 0 1 4 this 3 2137  
256 0 0 7 340 2136 1240 0 0 1 4 this 3 2137  
257 0 0 7 340 2136 1240 0 0 2 4 this 3 2137  5 other 1 2137  
258 0 0 7 340 2136 1240 0 0 2 4 this 3 2137  5 index 1 1949  
259 0 0 7 341 2136 1240 0 0 1 4 this 3 2137  
260 0 0 7 341 2136 1240 0 0 2 4 this 3 2137  5 other 1 2137  
261 0 0 7 341 2136 1240 0 0 2 4 this 3 2137  5 index 1 1949  
262 0 0 6 342 1949 0 0 0 1 4 this 3 2137  
263 0 0 6 343 1950 0 0 0 1 4 this 3 2137  
264 0 0 6 344 1978 0 0 0 1 4 this 3 2137  
265 0 0 6 345 1978 0 0 0 1 4 this 3 2137  
266 0 0 7 346 2096 0 0 0 0 
267 0 0 7 350 2140 1305 0 0 0 
268 0 0 7 350 2140 1305 0 0 1 6 param0 0 2141  
269 0 0 7 350 2140 1305 0 0 1 10 init_value 1 2143  
270 0 0 7 351 2140 1305 0 0 0 
271 0 0 7 352 2140 1305 0 0 0 
272 0 0 7 353 2140 1305 0 0 1 7 on_bits 1 1949  
273 0 0 7 354 2140 1305 0 0 1 5 index 1 1949  
274 0 0 7 355 2140 1305 0 0 2 7 low_bit 1 1949  4 size 1 1949  
275 0 0 6 356 1950 0 0 0 0 
276 0 0 6 357 1949 0 0 0 0 
277 0 0 6 358 1949 0 0 0 1 4 this 3 2141  
278 0 0 6 359 1950 0 0 0 2 4 this 3 2141  5 index 1 1949  
279 0 0 4 360 2083 0 0 0 2 4 this 3 2140  5 index 1 1949  
280 0 0 4 361 2083 0 0 0 2 4 this 3 2140  5 index 1 1949  
281 0 0 4 362 2083 0 0 0 3 4 this 3 2140  5 index 1 1949  5 value 1 1950  
282 0 0 6 363 1950 0 0 0 1 4 this 3 2141  
283 0 0 6 364 1950 0 0 0 1 4 this 3 2141  
284 0 0 6 365 2143 0 0 0 3 4 this 3 2141  7 low_bit 1 1949  4 size 1 1949  
285 0 0 4 366 2083 0 0 0 4 4 this 3 2140  5 value 1 2143  7 low_bit 1 1949  4 size 1 1949  
286 0 0 6 367 1950 0 0 0 3 4 this 3 2141  7 low_bit 1 1949  4 size 1 1949  
287 0 0 6 368 1950 0 0 0 3 4 this 3 2141  7 low_bit 1 1949  4 size 1 1949  
288 0 0 4 369 2083 0 0 0 3 4 this 3 2140  7 low_bit 1 1949  4 size 1 1949  
289 0 0 4 370 2083 0 0 0 3 4 this 3 2140  7 low_bit 1 1949  4 size 1 1949  
290 0 0 4 371 2083 0 0 0 4 4 this 3 2140  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
291 0 0 6 372 2143 0 0 0 1 4 this 3 2141  
292 0 0 4 373 2083 0 0 0 2 4 this 3 2140  5 value 1 2143  
293 0 0 6 374 1949 0 0 0 1 4 this 3 2141  
294 0 0 6 375 1949 0 0 0 1 4 this 3 2141  
295 0 0 6 376 1949 0 0 0 1 4 this 3 2141  
296 0 0 6 377 1949 0 0 0 1 4 this 3 2141  
297 0 0 6 378 1949 0 0 0 1 4 this 3 2141  
298 0 0 6 379 1949 0 0 0 1 4 this 3 2141  
299 0 0 6 380 1949 0 0 0 2 4 this 3 2141  7 low_bit 1 1949  
300 0 0 4 381 2083 0 0 0 1 4 this 3 2140  
301 0 0 6 382 1950 0 0 0 2 4 this 3 2141  5 other 1 2141  
302 0 0 4 383 2083 0 0 0 1 4 this 3 2140  
303 0 0 4 384 2083 0 0 0 2 4 this 3 2141  3 out 1 2094  
304 0 0 4 385 2083 0 0 0 3 4 this 3 2141  3 out 1 2094  12 spaces_every 1 1949  
305 0 0 4 386 2083 0 0 0 3 4 this 3 2141  3 out 1 2094  12 spaces_every 1 1949  
306 0 0 4 387 2083 0 0 0 3 4 this 3 2141  3 out 1 2094  12 indent_level 1 1949  
307 0 0 6 388 1950 0 0 0 2 4 this 3 2141  5 other 1 2141  
308 0 0 6 389 1950 0 0 0 2 4 this 3 2141  5 other 1 2141  
309 0 0 6 390 1950 0 0 0 2 4 this 3 2141  5 other 1 2141  
310 0 0 6 391 1949 0 0 0 2 4 this 3 2141  5 other 1 2141  
311 0 0 7 392 2140 1305 0 0 2 4 this 3 2141  5 other 1 2141  
312 0 0 7 393 2140 1305 0 0 2 4 this 3 2141  5 other 1 2141  
313 0 0 7 394 2140 1305 0 0 2 4 this 3 2141  5 other 1 2141  
314 0 0 7 395 2140 1305 0 0 1 4 this 3 2141  
315 0 0 7 396 2140 1305 0 0 2 4 this 3 2141  5 shift 1 1949  
316 0 0 7 397 2140 1305 0 0 2 4 this 3 2141  5 shift 1 1949  
317 0 0 6 398 2140 0 0 0 2 4 this 3 2140  5 other 1 2141  
318 0 0 6 399 2140 0 0 0 2 4 this 3 2140  5 other 1 2141  
319 0 0 6 400 2140 0 0 0 2 4 this 3 2140  5 other 1 2141  
320 0 0 6 401 2140 0 0 0 2 4 this 3 2140  5 shift 1 1949  
321 0 0 6 402 2140 0 0 0 2 4 this 3 2140  5 shift 1 1949  
322 0 0 4 403 2083 0 0 0 1 4 this 3 2140  
323 0 0 4 404 2083 0 0 0 1 4 this 3 2140  
324 0 0 7 405 2140 1305 0 0 1 4 this 3 2141  
325 0 0 7 406 2140 1305 0 0 1 4 this 3 2141  
326 0 0 7 407 2140 1305 0 0 1 4 this 3 2141  
327 0 0 7 407 2140 1305 0 0 2 4 this 3 2141  5 other 1 2141  
328 0 0 7 407 2140 1305 0 0 2 4 this 3 2141  5 index 1 1949  
329 0 0 7 408 2140 1305 0 0 1 4 this 3 2141  
330 0 0 7 408 2140 1305 0 0 2 4 this 3 2141  5 other 1 2141  
331 0 0 7 408 2140 1305 0 0 2 4 this 3 2141  5 index 1 1949  
332 0 0 6 409 1949 0 0 0 1 4 this 3 2141  
333 0 0 6 410 1950 0 0 0 1 4 this 3 2141  
334 0 0 6 411 1978 0 0 0 1 4 this 3 2141  
335 0 0 6 412 1978 0 0 0 1 4 this 3 2141  
336 0 0 7 413 2096 0 0 0 0 
337 0 0 7 417 2145 1370 0 0 0 
338 0 0 7 417 2145 1370 0 0 1 6 param0 0 2146  
339 0 0 7 417 2145 1370 0 0 1 10 init_value 1 2148  
340 0 0 7 418 2145 1370 0 0 0 
341 0 0 7 419 2145 1370 0 0 0 
342 0 0 7 420 2145 1370 0 0 1 7 on_bits 1 1949  
343 0 0 7 421 2145 1370 0 0 1 5 index 1 1949  
344 0 0 7 422 2145 1370 0 0 2 7 low_bit 1 1949  4 size 1 1949  
345 0 0 6 423 1950 0 0 0 0 
346 0 0 6 424 1949 0 0 0 0 
347 0 0 6 425 1949 0 0 0 1 4 this 3 2146  
348 0 0 6 426 1950 0 0 0 2 4 this 3 2146  5 index 1 1949  
349 0 0 4 427 2083 0 0 0 2 4 this 3 2145  5 index 1 1949  
350 0 0 4 428 2083 0 0 0 2 4 this 3 2145  5 index 1 1949  
351 0 0 4 429 2083 0 0 0 3 4 this 3 2145  5 index 1 1949  5 value 1 1950  
352 0 0 6 430 1950 0 0 0 1 4 this 3 2146  
353 0 0 6 431 1950 0 0 0 1 4 this 3 2146  
354 0 0 6 432 2148 0 0 0 3 4 this 3 2146  7 low_bit 1 1949  4 size 1 1949  
355 0 0 4 433 2083 0 0 0 4 4 this 3 2145  5 value 1 2148  7 low_bit 1 1949  4 size 1 1949  
356 0 0 6 434 1950 0 0 0 3 4 this 3 2146  7 low_bit 1 1949  4 size 1 1949  
357 0 0 6 435 1950 0 0 0 3 4 this 3 2146  7 low_bit 1 1949  4 size 1 1949  
358 0 0 4 436 2083 0 0 0 3 4 this 3 2145  7 low_bit 1 1949  4 size 1 1949  
359 0 0 4 437 2083 0 0 0 3 4 this 3 2145  7 low_bit 1 1949  4 size 1 1949  
360 0 0 4 438 2083 0 0 0 4 4 this 3 2145  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
361 0 0 6 439 2148 0 0 0 1 4 this 3 2146  
362 0 0 4 440 2083 0 0 0 2 4 this 3 2145  5 value 1 2148  
363 0 0 6 441 1949 0 0 0 1 4 this 3 2146  
364 0 0 6 442 1949 0 0 0 1 4 this 3 2146  
365 0 0 6 443 1949 0 0 0 1 4 this 3 2146  
366 0 0 6 444 1949 0 0 0 1 4 this 3 2146  
367 0 0 6 445 1949 0 0 0 1 4 this 3 2146  
368 0 0 6 446 1949 0 0 0 1 4 this 3 2146  
369 0 0 6 447 1949 0 0 0 2 4 this 3 2146  7 low_bit 1 1949  
370 0 0 4 448 2083 0 0 0 1 4 this 3 2145  
371 0 0 6 449 1950 0 0 0 2 4 this 3 2146  5 other 1 2146  
372 0 0 4 450 2083 0 0 0 1 4 this 3 2145  
373 0 0 4 451 2083 0 0 0 2 4 this 3 2146  3 out 1 2094  
374 0 0 4 452 2083 0 0 0 3 4 this 3 2146  3 out 1 2094  12 spaces_every 1 1949  
375 0 0 4 453 2083 0 0 0 3 4 this 3 2146  3 out 1 2094  12 spaces_every 1 1949  
376 0 0 4 454 2083 0 0 0 3 4 this 3 2146  3 out 1 2094  12 indent_level 1 1949  
377 0 0 6 455 1950 0 0 0 2 4 this 3 2146  5 other 1 2146  
378 0 0 6 456 1950 0 0 0 2 4 this 3 2146  5 other 1 2146  
379 0 0 6 457 1950 0 0 0 2 4 this 3 2146  5 other 1 2146  
380 0 0 6 458 1949 0 0 0 2 4 this 3 2146  5 other 1 2146  
381 0 0 7 459 2145 1370 0 0 2 4 this 3 2146  5 other 1 2146  
382 0 0 7 460 2145 1370 0 0 2 4 this 3 2146  5 other 1 2146  
383 0 0 7 461 2145 1370 0 0 2 4 this 3 2146  5 other 1 2146  
384 0 0 7 462 2145 1370 0 0 1 4 this 3 2146  
385 0 0 7 463 2145 1370 0 0 2 4 this 3 2146  5 shift 1 1949  
386 0 0 7 464 2145 1370 0 0 2 4 this 3 2146  5 shift 1 1949  
387 0 0 6 465 2145 0 0 0 2 4 this 3 2145  5 other 1 2146  
388 0 0 6 466 2145 0 0 0 2 4 this 3 2145  5 other 1 2146  
389 0 0 6 467 2145 0 0 0 2 4 this 3 2145  5 other 1 2146  
390 0 0 6 468 2145 0 0 0 2 4 this 3 2145  5 shift 1 1949  
391 0 0 6 469 2145 0 0 0 2 4 this 3 2145  5 shift 1 1949  
392 0 0 4 470 2083 0 0 0 1 4 this 3 2145  
393 0 0 4 471 2083 0 0 0 1 4 this 3 2145  
394 0 0 7 472 2145 1370 0 0 1 4 this 3 2146  
395 0 0 7 473 2145 1370 0 0 1 4 this 3 2146  
396 0 0 7 474 2145 1370 0 0 1 4 this 3 2146  
397 0 0 7 474 2145 1370 0 0 2 4 this 3 2146  5 other 1 2146  
398 0 0 7 474 2145 1370 0 0 2 4 this 3 2146  5 index 1 1949  
399 0 0 7 475 2145 1370 0 0 1 4 this 3 2146  
400 0 0 7 475 2145 1370 0 0 2 4 this 3 2146  5 other 1 2146  
401 0 0 7 475 2145 1370 0 0 2 4 this 3 2146  5 index 1 1949  
402 0 0 6 476 1949 0 0 0 1 4 this 3 2146  
403 0 0 6 477 1950 0 0 0 1 4 this 3 2146  
404 0 0 6 478 1978 0 0 0 1 4 this 3 2146  
405 0 0 6 479 1978 0 0 0 1 4 this 3 2146  
406 0 0 7 480 2096 0 0 0 0 
407 0 0 7 486 2149 1431 0 10 /**
 *
 */ 0 
408 0 0 7 486 2149 1431 0 0 1 6 param0 0 2150  
409 0 0 7 486 2149 1431 0 0 1 10 init_value 1 1978  
410 0 0 7 486 2149 1431 0 10 /**
 *
 */ 1 4 from 1 2152  
411 0 0 7 487 2149 1431 0 69 /**
 * Returns a BitArray with an infinite array of bits, all on.
 */ 0 
412 0 0 7 488 2149 1431 0 53 /**
 * Returns a BitArray whose bits are all off.
 */ 0 
413 0 0 7 489 2149 1431 0 62 /**
 * Returns a BitArray whose lower on_bits bits are on.
 */ 1 7 on_bits 1 1949  
414 0 0 7 490 2149 1431 0 61 /**
 * Returns a BitArray with only the indicated bit on.
 */ 1 5 index 1 1949  
415 0 0 7 491 2149 1431 0 76 /**
 * Returns a BitArray whose size bits, beginning at low_bit, are on.
 */ 2 7 low_bit 1 1949  4 size 1 1949  
416 0 0 6 492 1950 0 0 0 0 
417 0 0 6 493 1949 0 0 0 0 
418 0 0 6 494 1949 0 0 0 0 
419 0 0 6 495 2154 0 0 300 /**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */ 1 4 this 3 2150  
420 0 0 6 496 1950 0 0 191 /**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */ 2 4 this 3 2150  5 index 1 1949  
421 0 0 4 497 2083 0 0 97 /**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2149  5 index 1 1949  
422 0 0 4 498 2083 0 0 98 /**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2149  5 index 1 1949  
423 0 0 4 499 2083 0 0 84 /**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */ 3 4 this 3 2149  5 index 1 1949  5 value 1 1950  
424 0 0 6 500 1950 0 0 118 /**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */ 1 4 this 3 2150  
425 0 0 6 501 1950 0 0 71 /**
 * Returns true if the entire bitmask is zero, false otherwise.
 */ 1 4 this 3 2150  
426 0 0 6 502 1950 0 0 70 /**
 * Returns true if the entire bitmask is one, false otherwise.
 */ 1 4 this 3 2150  
427 0 0 6 503 2155 0 0 187 /**
 * Returns a word that represents only the indicated range of bits within this
 * BitArray, shifted to the least-significant position.  size must be <=
 * get_num_bits_per_word().
 */ 3 4 this 3 2150  7 low_bit 1 1949  4 size 1 1949  
428 0 0 4 504 2083 0 0 92 /**
 * Stores the indicated word into the indicated range of bits with this
 * BitArray.
 */ 4 4 this 3 2149  5 value 1 2155  7 low_bit 1 1949  4 size 1 1949  
429 0 0 6 505 1950 0 0 82 /**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */ 3 4 this 3 2150  7 low_bit 1 1949  4 size 1 1949  
430 0 0 6 506 1950 0 0 84 /**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */ 3 4 this 3 2150  7 low_bit 1 1949  4 size 1 1949  
431 0 0 4 507 2083 0 0 47 /**
 * Sets the indicated range of bits on.
 */ 3 4 this 3 2149  7 low_bit 1 1949  4 size 1 1949  
432 0 0 4 508 2083 0 0 48 /**
 * Sets the indicated range of bits off.
 */ 3 4 this 3 2149  7 low_bit 1 1949  4 size 1 1949  
433 0 0 4 509 2083 0 0 64 /**
 * Sets the indicated range of bits to either on or off.
 */ 4 4 this 3 2149  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
434 0 0 6 510 1949 0 0 127 /**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */ 1 4 this 3 2150  
435 0 0 6 511 1949 0 0 127 /**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */ 1 4 this 3 2150  
436 0 0 6 512 1949 0 0 101 /**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits.
 */ 1 4 this 3 2150  
437 0 0 6 513 1949 0 0 101 /**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits.
 */ 1 4 this 3 2150  
438 0 0 6 514 1949 0 0 143 /**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2150  
439 0 0 6 515 1949 0 0 143 /**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2150  
440 0 0 6 516 1949 0 0 287 /**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */ 2 4 this 3 2150  7 low_bit 1 1949  
441 0 0 6 517 2154 0 0 75 /**
 * Returns the number of possibly-unique words stored in the array.
 */ 1 4 this 3 2150  
442 0 0 7 518 2157 0 0 175 /**
 * Returns the nth word in the array.  It is valid for n to be greater than
 * get_num_words(), but the return value beyond get_num_words() will always be
 * the same.
 */ 2 4 this 3 2150  1 n 1 2154  
443 0 0 4 519 2083 0 0 113 /**
 * Replaces the nth word in the array.  If n >= get_num_words(), this
 * automatically extends the array.
 */ 3 4 this 3 2149  1 n 1 2154  5 value 1 2155  
444 0 0 4 520 2083 0 0 90 /**
 * Inverts all the bits in the BitArray.  This is equivalent to array =
 * ~array.
 */ 1 4 this 3 2149  
445 0 0 6 521 1950 0 0 178 /**
 * Returns true if this BitArray has any "one" bits in common with the other
 * one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */ 2 4 this 3 2150  5 other 1 2150  
446 0 0 4 522 2083 0 0 49 /**
 * Sets all the bits in the BitArray off.
 */ 1 4 this 3 2149  
447 0 0 4 523 2083 0 0 193 /**
 * Writes the BitArray out as a hex number.  For a BitArray, this is always
 * the same as output_hex(); it's too confusing for the output format to
 * change back and forth at runtime.
 */ 2 4 this 3 2150  3 out 1 2094  
448 0 0 4 524 2083 0 0 83 /**
 * Writes the BitArray out as a binary number, with spaces every four bits.
 */ 3 4 this 3 2150  3 out 1 2094  12 spaces_every 1 1949  
449 0 0 4 525 2083 0 0 93 /**
 * Writes the BitArray out as a hexadecimal number, with spaces every four
 * digits.
 */ 3 4 this 3 2150  3 out 1 2094  12 spaces_every 1 1949  
450 0 0 4 526 2083 0 0 99 /**
 * Writes the BitArray out as a binary or a hex number, according to the
 * number of bits.
 */ 3 4 this 3 2150  3 out 1 2094  12 indent_level 1 1949  
451 0 0 6 527 1950 0 0 0 2 4 this 3 2150  5 other 1 2150  
452 0 0 6 528 1950 0 0 0 2 4 this 3 2150  5 other 1 2150  
453 0 0 6 529 1950 0 0 0 2 4 this 3 2150  5 other 1 2150  
454 0 0 6 530 1949 0 0 233 /**
 * Returns a number less than zero if this BitArray sorts before the indicated
 * other BitArray, greater than zero if it sorts after, or 0 if they are
 * equivalent.  This is based on the same ordering defined by operator <.
 */ 2 4 this 3 2150  5 other 1 2150  
455 0 0 7 531 2149 1431 0 0 2 4 this 3 2150  5 other 1 2150  
456 0 0 7 532 2149 1431 0 0 2 4 this 3 2150  5 other 1 2150  
457 0 0 7 533 2149 1431 0 0 2 4 this 3 2150  5 other 1 2150  
458 0 0 7 534 2149 1431 0 0 1 4 this 3 2150  
459 0 0 7 535 2149 1431 0 0 2 4 this 3 2150  5 shift 1 1949  
460 0 0 7 536 2149 1431 0 0 2 4 this 3 2150  5 shift 1 1949  
461 0 0 6 537 2149 0 0 0 2 4 this 3 2149  5 other 1 2150  
462 0 0 6 538 2149 0 0 0 2 4 this 3 2149  5 other 1 2150  
463 0 0 6 539 2149 0 0 0 2 4 this 3 2149  5 other 1 2150  
464 0 0 6 540 2149 0 0 0 2 4 this 3 2149  5 shift 1 1949  
465 0 0 6 541 2149 0 0 0 2 4 this 3 2149  5 shift 1 1949  
466 0 0 6 542 1950 0 0 0 1 4 this 3 2150  
467 0 0 6 543 1978 0 0 0 1 4 this 3 2150  
468 0 0 4 544 2083 0 0 0 2 4 this 3 2149  5 state 1 1978  
469 0 0 7 545 2096 0 0 0 0 
470 0 0 7 548 2158 1451 0 259 // The default constructor must do nothing, because we can't guarantee
// ordering of static initializers.  If the constructor tried to initialize
// its value, it  might happen after the value had already been set
// previously by another static initializer! 0 
471 0 0 7 548 2158 1451 0 0 1 6 param0 0 2159  
472 0 0 7 548 2158 1451 0 154 /**
 * Constructs a ButtonHandle with the corresponding index number, which may
 * have been returned by an earlier call to ButtonHandle::get_index().
 */ 1 5 index 1 1949  
473 0 0 7 548 2158 1451 0 341 /**
 * Constructs a ButtonHandle with the corresponding name, which is looked up
 * in the ButtonRegistry.  This exists for the purpose of being able to
 * automatically coerce a string into a ButtonHandle; for most purposes, you
 * should use either the static KeyboardButton/MouseButton getters or
 * ButtonRegistry::register_button().
 */ 1 4 name 1 2098  
474 0 0 6 549 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
475 0 0 6 550 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
476 0 0 6 551 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
477 0 0 6 552 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
478 0 0 6 553 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
479 0 0 6 554 1950 0 0 0 2 4 this 3 2159  5 other 1 2159  
480 0 0 6 555 1949 0 0 209 /**
 * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a
 * number less than 0 if this type sorts before the other one, greater than
 * zero if it sorts after, 0 if they are equivalent.
 */ 2 4 this 3 2159  5 other 1 2159  
481 0 0 6 556 2154 0 0 54 /**
 * Returns a hash code suitable for phash_map.
 */ 1 4 this 3 2159  
482 0 0 6 557 2098 0 0 42 /**
 * Returns the name of the button.
 */ 1 4 this 3 2159  
483 0 0 6 558 1950 0 0 121 /**
 * Returns true if the button was created with an ASCII equivalent code (e.g.
 * for a standard keyboard button).
 */ 1 4 this 3 2159  
484 0 0 6 559 1996 0 0 109 /**
 * Returns the character code associated with the button, or '\0' if no ASCII
 * code was associated.
 */ 1 4 this 3 2159  
485 0 0 7 560 2158 1451 0 373 /**
 * Returns the alias (alternate name) associated with the button, if any, or
 * ButtonHandle::none() if the button has no alias.
 *
 * Each button is allowed to have one alias, and multiple different buttons
 * can refer to the same alias.  The alias should be the more general name for
 * the button, for instance, shift is an alias for lshift, but not vice-versa.
 */ 1 4 this 3 2159  
486 0 0 6 561 1950 0 0 263 /**
 * Returns true if this ButtonHandle is the same as the other one, or if the
 * other one is an alias for this one.  (Does not return true if this button
 * is an alias for the other one, however.)
 *
 * This is a more general comparison than operator ==.
 */ 2 4 this 3 2159  5 other 1 2159  
487 0 0 6 562 1949 0 0 363 /**
 * Returns the integer index associated with this ButtonHandle.  Each
 * different ButtonHandle will have a different index.  However, you probably
 * shouldn't be using this method; you should just treat the ButtonHandles as
 * opaque classes.  This is provided for the convenience of non-C++ scripting
 * languages to build a hashtable of ButtonHandles.
 */ 1 4 this 3 2159  
488 0 0 4 563 2083 0 0 10 /**
 *
 */ 2 4 this 3 2159  3 out 1 2094  
489 0 0 7 564 2158 1451 0 0 0 
490 0 0 7 573 2096 0 0 0 0 
491 0 0 6 565 1950 0 0 0 1 4 this 3 2159  
492 0 0 7 581 2163 1458 0 0 1 6 param0 0 2161  
493 0 0 7 576 2158 1451 0 150 /**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, registers a new one and returns it.
 */ 2 4 this 3 2163  4 name 1 2098  
494 0 0 7 577 2158 1451 0 144 /**
 * Finds a ButtonHandle in the registry matching the indicated name.  If there
 * is no such ButtonHandle, returns ButtonHandle::none().
 */ 2 4 this 3 2163  4 name 1 2098  
495 0 0 7 578 2158 1451 0 169 /**
 * Finds a ButtonHandle in the registry matching the indicated ASCII
 * equivalent character.  If there is no such ButtonHandle, returns
 * ButtonHandle::none().
 */ 2 4 this 3 2161  16 ascii_equivalent 1 1996  
496 0 0 4 579 2083 0 0 10 /**
 *
 */ 2 4 this 3 2161  3 out 1 2094  
497 0 0 6 580 2163 0 0 67 /**
 * Returns the pointer to the global ButtonRegistry object.
 */ 0 
498 0 0 7 592 2164 1467 0 0 0 
499 0 0 7 592 2164 1467 0 0 1 6 param0 0 2165  
500 0 0 6 585 2154 0 0 76 /**
 * Returns the number of buttons that this button mapping specifies.
 */ 1 4 this 3 2165  
501 0 0 7 586 2158 1451 0 76 /**
 * Returns the underlying raw button associated with the nth button.
 */ 2 4 this 3 2165  1 i 1 2154  
502 0 0 7 587 2158 1451 0 166 /**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */ 2 4 this 3 2165  3 raw 1 2158  
503 0 0 7 587 2158 1451 0 101 /**
 * Returns the nth mapped button, meaning the button that the nth raw button
 * is mapped to.
 */ 2 4 this 3 2165  1 i 1 2154  
504 0 0 7 587 2158 1451 0 166 /**
 * Returns the button that the given button is mapped to, or
 * ButtonHandle::none() if this map does not specify a mapped button for the
 * given raw button.
 */ 2 4 this 3 2165  8 raw_name 1 2098  
505 0 0 6 588 2098 0 0 353 /**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */ 2 4 this 3 2165  3 raw 1 2158  
506 0 0 6 588 2098 0 0 127 /**
 * Returns the label associated with the nth mapped button, meaning the button
 * that the nth raw button is mapped to.
 */ 2 4 this 3 2165  1 i 1 2154  
507 0 0 6 588 2098 0 0 353 /**
 * If the button map specifies a special name for the button (eg.  if the
 * operating system or keyboard device has a localized name describing the
 * key), returns it, or the empty string otherwise.
 *
 * Note that this is not the same as get_mapped_button().get_name(), which
 * returns the name of the Panda event associated with the button.
 */ 2 4 this 3 2165  8 raw_name 1 2098  
508 0 0 4 589 2083 0 0 10 /**
 *
 */ 2 4 this 3 2165  3 out 1 2094  
509 0 0 4 590 2083 0 0 10 /**
 *
 */ 3 4 this 3 2165  3 out 1 2094  12 indent_level 1 1949  
510 0 0 7 591 2096 0 0 0 0 
511 0 0 7 598 2169 1472 0 0 1 6 param0 0 2167  
512 0 0 4 595 2083 0 0 10 /**
 *
 */ 2 4 this 3 2167  3 out 1 2094  
513 0 0 7 596 2169 1472 0 0 1 8 function 1 1978  
514 0 0 7 597 2096 0 0 0 0 
515 0 0 6 601 1949 0 0 47 /**
 * Returns the current reference count.
 */ 1 4 this 3 2170  
516 0 0 4 602 2083 0 0 108 /**
 * Explicitly increments the cache reference count and the normal reference
 * count simultaneously.
 */ 1 4 this 3 2170  
517 0 0 6 603 1950 0 0 202 /**
 * Explicitly decrements the cache reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */ 1 4 this 3 2170  
518 0 0 6 604 1950 0 0 97 /**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */ 1 4 this 3 2170  
519 0 0 7 606 2096 0 0 0 0 
520 0 0 4 608 2083 0 0 10 /**
 *
 */ 2 4 this 3 2172  3 out 1 2094  
521 0 0 4 609 2083 0 0 159 /**
 * You should make this call during the callback if you want to continue the
 * normal function that would have been done in the absence of a callback.
 */ 1 4 this 3 2174  
522 0 0 7 610 2096 0 0 0 0 
523 0 0 7 613 2175 1472 0 10 /**
 *
 */ 1 8 function 1 1978  
524 0 0 7 613 2175 1472 0 0 1 6 param0 0 2176  
525 0 0 4 614 2083 0 0 0 2 4 this 3 2175  4 size 1 2154  
526 0 0 4 617 2083 0 0 126 /**
 * Replaces the function that is called for the callback.  runs.  The
 * parameter should be a Python callable object.
 */ 2 4 this 3 2175  8 function 1 1978  
527 0 0 6 618 1978 0 0 64 /**
 * Returns the function that is called for the callback.
 */ 1 4 this 3 2175  
528 0 0 6 619 1978 0 0 37 /**
 * Implements pickle support.
 */ 1 4 this 3 2176  
529 0 0 7 621 2096 0 0 0 0 
530 0 0 7 623 2178 1495 0 10 /**
 *
 */ 0 
531 0 0 7 623 2178 1495 0 0 1 6 param0 0 2179  
532 0 0 6 624 2006 0 0 10 /**
 *
 */ 1 4 this 3 2179  
533 0 0 6 625 2006 0 0 10 /**
 *
 */ 1 4 this 3 2179  
534 0 0 7 634 2183 0 0 10 /**
 *
 */ 1 4 copy 1 2181  
535 0 0 7 634 2183 0 0 10 /**
 *
 */ 1 4 mode 1 2008  
536 0 0 4 635 2083 0 0 1841 /**
 * Changes the mode of the clock.  Normally, the clock is in mode M_normal.
 * In this mode, each call to tick() will set the value returned by
 * get_frame_time() to the current real time; thus, the clock simply reports
 * time advancing.
 *
 * Other possible modes:
 *
 * M_non_real_time - the clock ignores real time completely; at each call to
 * tick(), it pretends that exactly dt seconds have elapsed since the last
 * call to tick().  You may set the value of dt with set_dt() or
 * set_frame_rate().
 *
 * M_limited - the clock will run as fast as it can, as in M_normal, but will
 * not run faster than the rate specified by set_frame_rate().  If the
 * application would run faster than this rate, the clock will slow down the
 * application.
 *
 * M_integer - the clock will run as fast as it can, but the rate will be
 * constrained to be an integer multiple or divisor of the rate specified by
 * set_frame_rate().  The clock will slow down the application a bit to
 * guarantee this.
 *
 * M_integer_limited - a combination of M_limited and M_integer; the clock
 * will not run faster than set_frame_rate(), and if it runs slower, it will
 * run at a integer divisor of that rate.
 *
 * M_forced - the clock forces the application to run at the rate specified by
 * set_frame_rate().  If the application would run faster than this rate, the
 * clock will slow down the application; if the application would run slower
 * than this rate, the clock slows down time so that the application believes
 * it is running at the given rate.
 *
 * M_degrade - the clock runs at real time, but the application is slowed down
 * by a set factor of its frame rate, specified by set_degrade_factor().
 *
 * M_slave - the clock does not advance, but relies on the user to call
 * set_frame_time() and/or set_frame_count() each frame.
 */ 2 4 this 3 2183  4 mode 1 2008  
537 0 0 6 636 2008 0 0 66 /**
 * Returns the current mode of the clock.  See set_mode().
 */ 1 4 this 3 2181  
538 0 0 6 638 1948 0 0 350 /**
 * Returns the time in seconds as of the last time tick() was called
 * (typically, this will be as of the start of the current frame).
 *
 * This is generally the kind of time you want to ask for in most rendering
 * and animation contexts, since it's important that all of the animation for
 * a given frame remains in sync with each other.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
539 0 0 6 639 1948 0 0 434 /**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.  This is useful for doing real timing
 * measurements, e.g.  for performance statistics.
 *
 * This returns the most precise timer we have for short time intervals, but
 * it may tend to drift over the long haul.  If more accurate timekeeping is
 * needed over a long period of time, use get_long_time() instead.
 */ 1 4 this 3 2181  
540 0 0 6 640 1948 0 0 440 /**
 * Returns the actual number of seconds elapsed since the ClockObject was
 * created, or since it was last reset.
 *
 * This is similar to get_real_time(), except that it uses the most accurate
 * counter we have over a long period of time, and so it is less likely to
 * drift.  However, it may not be very precise for measuring short intervals.
 * On Windows, for instace, this is only accurate to within about 55
 * milliseconds.
 */ 1 4 this 3 2181  
541 0 0 4 641 2083 0 0 75 /**
 * Simultaneously resets both the time and the frame count to zero.
 */ 1 4 this 3 2183  
542 0 0 4 642 2083 0 0 316 /**
 * Resets the clock to the indicated time.  This changes only the real time of
 * the clock as reported by get_real_time(), but does not immediately change
 * the time reported by get_frame_time()--that will change after the next call
 * to tick().  Also see reset(), set_frame_time(), and set_frame_count().
 */ 2 4 this 3 2183  4 time 1 1948  
543 0 0 4 643 2083 0 0 215 /**
 * Changes the time as reported for the current frame to the indicated time.
 * Normally, the way to adjust the frame time is via tick(); this function is
 * provided only for occasional special adjustments.
 */ 3 4 this 3 2183  4 time 1 1948  14 current_thread 1 2184  
544 0 0 4 644 2083 0 0 132 /**
 * Resets the number of frames counted to the indicated number.  Also see
 * reset(), set_real_time(), and set_frame_time().
 */ 3 4 this 3 2183  11 frame_count 1 1949  14 current_thread 1 2184  
545 0 0 6 645 1949 0 0 195 /**
 * Returns the number of times tick() has been called since the ClockObject
 * was created, or since it was last reset.  This is generally the number of
 * frames that have been rendered.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
546 0 0 6 646 1948 0 0 245 /**
 * Returns the average frame rate since the last reset.  This is simply the
 * total number of frames divided by the total elapsed time.  This reports the
 * virtual frame rate if the clock is in (or has been in) M_non_real_time
 * mode.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
547 0 0 6 651 1948 0 0 130 /**
 * Returns the elapsed time for the previous frame: the number of seconds
 * elapsed between the last two calls to tick().
 */ 2 4 this 3 2181  14 current_thread 1 2184  
548 0 0 4 652 2083 0 0 291 /**
 * In non-real-time mode, sets the number of seconds that should appear to
 * elapse between frames.  In forced mode or limited mode, sets our target dt.
 * In normal mode, this has no effect.
 *
 * Also see set_frame_rate(), which is a different way to specify the same
 * quantity.
 */ 2 4 this 3 2183  2 dt 1 1948  
549 0 0 4 653 2083 0 0 291 /**
 * In non-real-time mode, sets the number of frames per second that we should
 * appear to be running.  In forced mode or limited mode, sets our target
 * frame rate.  In normal mode, this has no effect.
 *
 * Also see set_dt(), which is a different way to specify the same quantity.
 */ 2 4 this 3 2183  10 frame_rate 1 1948  
550 0 0 6 655 1948 0 0 106 /**
 * Returns the current maximum allowable time elapsed between any two frames.
 * See set_max_dt().
 */ 1 4 this 3 2181  
551 0 0 4 656 2083 0 0 511 /**
 * Sets a limit on the value returned by get_dt().  If this value is less than
 * zero, no limit is imposed; otherwise, this is the maximum value that will
 * ever be returned by get_dt(), regardless of how much time has actually
 * elapsed between frames.
 *
 * This limit is only imposed in real-time mode; in non-real-time mode, the dt
 * is fixed anyway and max_dt is ignored.
 *
 * This is generally used to guarantee reasonable behavior even in the
 * presence of a very slow or chuggy frame rame.
 */ 2 4 this 3 2183  6 max_dt 1 1948  
552 0 0 6 658 1948 0 0 265 /**
 * In degrade mode, returns the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */ 1 4 this 3 2181  
553 0 0 4 659 2083 0 0 262 /**
 * In degrade mode, sets the ratio by which the performance is degraded.  A
 * value of 2.0 causes the clock to be slowed down by a factor of two
 * (reducing performance to 1/2 what would be otherwise).
 *
 * This has no effect if mode is not M_degrade.
 */ 2 4 this 3 2183  14 degrade_factor 1 1948  
554 0 0 4 661 2083 0 0 393 /**
 * Specifies the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.  Changing this does not necessarily immediately
 * change the result of get_average_frame_rate(), until this interval of time
 * has elapsed again.
 *
 * Setting this to zero disables the computation of get_average_frame_rate().
 */ 2 4 this 3 2183  4 time 1 1948  
555 0 0 6 662 1948 0 0 162 /**
 * Returns the interval of time (in seconds) over which
 * get_average_frame_rate() averages the number of frames per second to
 * compute the frame rate.
 */ 1 4 this 3 2181  
556 0 0 6 664 1948 0 0 214 /**
 * Returns the average frame rate in number of frames per second over the last
 * get_average_frame_rate_interval() seconds.  This measures the virtual frame
 * rate if the clock is in M_non_real_time mode.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
557 0 0 6 665 1948 0 0 105 /**
 * Returns the maximum frame duration over the last
 * get_average_frame_rate_interval() seconds.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
558 0 0 6 666 1948 0 0 539 /**
 * Returns the standard deviation of the frame times of the frames rendered
 * over the past get_average_frame_rate_interval() seconds.  This number gives
 * an estimate of the chugginess of the frame rate; if it is large, there is a
 * large variation in the frame rate; if is small, all of the frames are
 * consistent in length.
 *
 * A large value might also represent just a recent change in frame rate, for
 * instance, because the camera has just rotated from looking at a simple
 * scene to looking at a more complex scene.
 */ 2 4 this 3 2181  14 current_thread 1 2184  
559 0 0 4 669 2083 0 0 285 /**
 * Instructs the clock that a new frame has just begun.  In normal, real-time
 * mode, get_frame_time() will henceforth report the time as of this instant
 * as the current start-of-frame time.  In non-real-time mode,
 * get_frame_time() will be incremented by the value of dt.
 */ 2 4 this 3 2183  14 current_thread 1 2184  
560 0 0 4 670 2083 0 0 417 /**
 * Resets the frame time to the current real time.  This is similar to tick(),
 * except that it does not advance the frame counter and does not affect dt.
 * This is intended to be used in the middle of a particularly long frame to
 * compensate for the time that has already elapsed.
 *
 * In non-real-time mode, this function has no effect (because in this mode
 * all frames take the same length of time).
 */ 2 4 this 3 2183  14 current_thread 1 2184  
561 0 0 6 671 1950 0 0 322 /**
 * Returns true if a clock error was detected since the last time
 * check_errors() was called.  A clock error means that something happened, an
 * OS or BIOS bug, for instance, that makes the current value of the clock
 * somewhat suspect, and an application may wish to resynchronize with any
 * external clocks.
 */ 2 4 this 3 2183  14 current_thread 1 2184  
562 0 0 7 672 2183 0 0 159 /**
 * Returns a pointer to the global ClockObject.  This is the ClockObject that
 * most code should use for handling scene graph rendering and animation.
 */ 0 
563 0 0 7 673 2096 0 0 0 0 
564 0 0 4 681 2083 0 0 62 /**
 * @see CachedTypedWritableReferenceCount::cache_ref()
 */ 1 4 this 3 2186  
565 0 0 6 682 1950 0 0 64 /**
 * @see CachedTypedWritableReferenceCount::cache_unref()
 */ 1 4 this 3 2186  
566 0 0 7 683 2096 0 0 0 0 
567 0 0 7 690 2188 1541 0 48 /**
 * Initializes an empty datagram buffer.
 */ 0 
568 0 0 7 690 2188 1541 0 54 /**
 * Initializes the buffer with the given data.
 */ 1 4 data 1 2014  
569 0 0 4 691 2083 0 0 38 /**
 * Clears the internal buffer.
 */ 1 4 this 3 2188  
570 0 0 6 686 1982 0 0 0 1 4 this 3 2188  
571 0 0 6 688 1975 0 0 0 1 4 this 3 2188  
572 0 0 7 700 2189 0 0 10 /**
 *
 */ 0 
573 0 0 6 701 1950 0 0 99 /**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2189  4 file 1 2190  
574 0 0 6 701 1950 0 0 99 /**
 * Opens the indicated filename for reading.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2189  8 filename 1 2117  
575 0 0 6 701 1950 0 0 230 /**
 * Starts reading from the indicated stream.  Returns true on success, false
 * on failure.  The DatagramInputFile does not take ownership of the stream;
 * you are responsible for closing or deleting it when you are done.
 */ 3 4 this 3 2189  2 in 1 2193  8 filename 1 2117  
576 0 0 6 702 2193 0 0 61 /**
 * Returns the istream represented by the input file.
 */ 1 4 this 3 2189  
577 0 0 4 703 2083 0 0 98 /**
 * Closes the file.  This is also implicitly done when the DatagramInputFile
 * destructs.
 */ 1 4 this 3 2189  
578 0 0 7 706 2195 0 0 10 /**
 *
 */ 0 
579 0 0 6 707 1950 0 0 102 /**
 * Opens the indicated filename for writing.  Returns true if successful,
 * false on failure.
 */ 2 4 this 3 2195  4 file 1 2190  
580 0 0 6 707 1950 0 0 99 /**
 * Opens the indicated filename for writing.  Returns true on success, false
 * on failure.
 */ 2 4 this 3 2195  8 filename 1 2117  
581 0 0 6 707 1950 0 0 229 /**
 * Starts writing to the indicated stream.  Returns true on success, false on
 * failure.  The DatagramOutputFile does not take ownership of the stream; you
 * are responsible for closing or deleting it when you are done.
 */ 3 4 this 3 2195  3 out 1 2094  8 filename 1 2117  
582 0 0 4 708 2083 0 0 99 /**
 * Closes the file.  This is also implicitly done when the DatagramOutputFile
 * destructs.
 */ 1 4 this 3 2195  
583 0 0 6 709 1950 0 0 256 /**
 * Writes a sequence of bytes to the beginning of the datagram file.  This may
 * be called any number of times after the file has been opened and before the
 * first datagram is written.  It may not be called once the first datagram is
 * written.
 */ 2 4 this 3 2195  6 header 1 2098  
584 0 0 7 714 2196 1607 0 0 0 
585 0 0 7 714 2196 1607 0 0 1 6 param0 0 2197  
586 0 0 7 714 2196 1607 0 0 1 10 init_value 1 1978  
587 0 0 7 715 2196 1607 0 0 0 
588 0 0 7 716 2196 1607 0 0 0 
589 0 0 7 717 2196 1607 0 0 1 7 on_bits 1 1949  
590 0 0 7 718 2196 1607 0 0 1 5 index 1 1949  
591 0 0 7 719 2196 1607 0 0 2 7 low_bit 1 1949  4 size 1 1949  
592 0 0 6 720 1950 0 0 0 0 
593 0 0 6 721 1949 0 0 0 0 
594 0 0 6 722 1949 0 0 0 1 4 this 3 2197  
595 0 0 6 723 1950 0 0 0 2 4 this 3 2197  5 index 1 1949  
596 0 0 4 724 2083 0 0 0 2 4 this 3 2196  5 index 1 1949  
597 0 0 4 725 2083 0 0 0 2 4 this 3 2196  5 index 1 1949  
598 0 0 4 726 2083 0 0 0 3 4 this 3 2196  5 index 1 1949  5 value 1 1950  
599 0 0 6 727 1950 0 0 0 1 4 this 3 2197  
600 0 0 6 728 1950 0 0 0 1 4 this 3 2197  
601 0 0 6 729 2148 0 0 0 3 4 this 3 2197  7 low_bit 1 1949  4 size 1 1949  
602 0 0 4 730 2083 0 0 0 4 4 this 3 2196  5 value 1 2148  7 low_bit 1 1949  4 size 1 1949  
603 0 0 6 731 1950 0 0 0 3 4 this 3 2197  7 low_bit 1 1949  4 size 1 1949  
604 0 0 6 732 1950 0 0 0 3 4 this 3 2197  7 low_bit 1 1949  4 size 1 1949  
605 0 0 4 733 2083 0 0 0 3 4 this 3 2196  7 low_bit 1 1949  4 size 1 1949  
606 0 0 4 734 2083 0 0 0 3 4 this 3 2196  7 low_bit 1 1949  4 size 1 1949  
607 0 0 4 735 2083 0 0 0 4 4 this 3 2196  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
608 0 0 6 736 1949 0 0 0 1 4 this 3 2197  
609 0 0 6 737 1949 0 0 0 1 4 this 3 2197  
610 0 0 6 738 1949 0 0 0 1 4 this 3 2197  
611 0 0 6 739 1949 0 0 0 1 4 this 3 2197  
612 0 0 6 740 1949 0 0 0 1 4 this 3 2197  
613 0 0 6 741 1949 0 0 0 1 4 this 3 2197  
614 0 0 6 742 1949 0 0 0 2 4 this 3 2197  7 low_bit 1 1949  
615 0 0 4 743 2083 0 0 0 1 4 this 3 2196  
616 0 0 6 744 1950 0 0 0 2 4 this 3 2197  5 other 1 2197  
617 0 0 4 745 2083 0 0 0 1 4 this 3 2196  
618 0 0 4 746 2083 0 0 0 2 4 this 3 2197  3 out 1 2094  
619 0 0 4 747 2083 0 0 0 3 4 this 3 2197  3 out 1 2094  12 spaces_every 1 1949  
620 0 0 4 748 2083 0 0 0 3 4 this 3 2197  3 out 1 2094  12 spaces_every 1 1949  
621 0 0 4 749 2083 0 0 0 3 4 this 3 2197  3 out 1 2094  12 indent_level 1 1949  
622 0 0 6 750 1950 0 0 0 2 4 this 3 2197  5 other 1 2197  
623 0 0 6 751 1950 0 0 0 2 4 this 3 2197  5 other 1 2197  
624 0 0 6 752 1950 0 0 0 2 4 this 3 2197  5 other 1 2197  
625 0 0 6 753 1949 0 0 0 2 4 this 3 2197  5 other 1 2197  
626 0 0 7 754 2196 1607 0 0 2 4 this 3 2197  5 other 1 2197  
627 0 0 7 755 2196 1607 0 0 2 4 this 3 2197  5 other 1 2197  
628 0 0 7 756 2196 1607 0 0 2 4 this 3 2197  5 other 1 2197  
629 0 0 7 757 2196 1607 0 0 1 4 this 3 2197  
630 0 0 7 758 2196 1607 0 0 2 4 this 3 2197  5 shift 1 1949  
631 0 0 7 759 2196 1607 0 0 2 4 this 3 2197  5 shift 1 1949  
632 0 0 6 760 2196 0 0 0 2 4 this 3 2196  5 other 1 2197  
633 0 0 6 761 2196 0 0 0 2 4 this 3 2196  5 other 1 2197  
634 0 0 6 762 2196 0 0 0 2 4 this 3 2196  5 other 1 2197  
635 0 0 6 763 2196 0 0 0 2 4 this 3 2196  5 shift 1 1949  
636 0 0 6 764 2196 0 0 0 2 4 this 3 2196  5 shift 1 1949  
637 0 0 6 765 1950 0 0 0 1 4 this 3 2197  
638 0 0 6 766 1978 0 0 0 1 4 this 3 2197  
639 0 0 6 767 1978 0 0 0 1 4 this 3 2197  
640 0 0 7 768 2096 0 0 0 0 
641 0 0 7 772 2199 1663 0 0 0 
642 0 0 7 772 2199 1663 0 0 1 6 param0 0 2200  
643 0 0 7 772 2199 1663 0 0 1 10 init_value 1 1978  
644 0 0 7 773 2199 1663 0 0 0 
645 0 0 7 774 2199 1663 0 0 0 
646 0 0 7 775 2199 1663 0 0 1 7 on_bits 1 1949  
647 0 0 7 776 2199 1663 0 0 1 5 index 1 1949  
648 0 0 7 777 2199 1663 0 0 2 7 low_bit 1 1949  4 size 1 1949  
649 0 0 6 778 1950 0 0 0 0 
650 0 0 6 779 1949 0 0 0 0 
651 0 0 6 780 1949 0 0 0 1 4 this 3 2200  
652 0 0 6 781 1950 0 0 0 2 4 this 3 2200  5 index 1 1949  
653 0 0 4 782 2083 0 0 0 2 4 this 3 2199  5 index 1 1949  
654 0 0 4 783 2083 0 0 0 2 4 this 3 2199  5 index 1 1949  
655 0 0 4 784 2083 0 0 0 3 4 this 3 2199  5 index 1 1949  5 value 1 1950  
656 0 0 6 785 1950 0 0 0 1 4 this 3 2200  
657 0 0 6 786 1950 0 0 0 1 4 this 3 2200  
658 0 0 6 787 2148 0 0 0 3 4 this 3 2200  7 low_bit 1 1949  4 size 1 1949  
659 0 0 4 788 2083 0 0 0 4 4 this 3 2199  5 value 1 2148  7 low_bit 1 1949  4 size 1 1949  
660 0 0 6 789 1950 0 0 0 3 4 this 3 2200  7 low_bit 1 1949  4 size 1 1949  
661 0 0 6 790 1950 0 0 0 3 4 this 3 2200  7 low_bit 1 1949  4 size 1 1949  
662 0 0 4 791 2083 0 0 0 3 4 this 3 2199  7 low_bit 1 1949  4 size 1 1949  
663 0 0 4 792 2083 0 0 0 3 4 this 3 2199  7 low_bit 1 1949  4 size 1 1949  
664 0 0 4 793 2083 0 0 0 4 4 this 3 2199  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
665 0 0 6 794 1949 0 0 0 1 4 this 3 2200  
666 0 0 6 795 1949 0 0 0 1 4 this 3 2200  
667 0 0 6 796 1949 0 0 0 1 4 this 3 2200  
668 0 0 6 797 1949 0 0 0 1 4 this 3 2200  
669 0 0 6 798 1949 0 0 0 1 4 this 3 2200  
670 0 0 6 799 1949 0 0 0 1 4 this 3 2200  
671 0 0 6 800 1949 0 0 0 2 4 this 3 2200  7 low_bit 1 1949  
672 0 0 4 801 2083 0 0 0 1 4 this 3 2199  
673 0 0 6 802 1950 0 0 0 2 4 this 3 2200  5 other 1 2200  
674 0 0 4 803 2083 0 0 0 1 4 this 3 2199  
675 0 0 4 804 2083 0 0 0 2 4 this 3 2200  3 out 1 2094  
676 0 0 4 805 2083 0 0 0 3 4 this 3 2200  3 out 1 2094  12 spaces_every 1 1949  
677 0 0 4 806 2083 0 0 0 3 4 this 3 2200  3 out 1 2094  12 spaces_every 1 1949  
678 0 0 4 807 2083 0 0 0 3 4 this 3 2200  3 out 1 2094  12 indent_level 1 1949  
679 0 0 6 808 1950 0 0 0 2 4 this 3 2200  5 other 1 2200  
680 0 0 6 809 1950 0 0 0 2 4 this 3 2200  5 other 1 2200  
681 0 0 6 810 1950 0 0 0 2 4 this 3 2200  5 other 1 2200  
682 0 0 6 811 1949 0 0 0 2 4 this 3 2200  5 other 1 2200  
683 0 0 7 812 2199 1663 0 0 2 4 this 3 2200  5 other 1 2200  
684 0 0 7 813 2199 1663 0 0 2 4 this 3 2200  5 other 1 2200  
685 0 0 7 814 2199 1663 0 0 2 4 this 3 2200  5 other 1 2200  
686 0 0 7 815 2199 1663 0 0 1 4 this 3 2200  
687 0 0 7 816 2199 1663 0 0 2 4 this 3 2200  5 shift 1 1949  
688 0 0 7 817 2199 1663 0 0 2 4 this 3 2200  5 shift 1 1949  
689 0 0 6 818 2199 0 0 0 2 4 this 3 2199  5 other 1 2200  
690 0 0 6 819 2199 0 0 0 2 4 this 3 2199  5 other 1 2200  
691 0 0 6 820 2199 0 0 0 2 4 this 3 2199  5 other 1 2200  
692 0 0 6 821 2199 0 0 0 2 4 this 3 2199  5 shift 1 1949  
693 0 0 6 822 2199 0 0 0 2 4 this 3 2199  5 shift 1 1949  
694 0 0 6 823 1950 0 0 0 1 4 this 3 2200  
695 0 0 6 824 1978 0 0 0 1 4 this 3 2200  
696 0 0 6 825 1978 0 0 0 1 4 this 3 2200  
697 0 0 7 826 2096 0 0 0 0 
698 0 0 7 862 2202 1696 0 0 0 
699 0 0 7 862 2202 1696 0 0 1 6 param0 0 2203  
700 0 0 7 831 2158 1451 0 0 0 
701 0 0 7 832 2158 1451 0 0 0 
702 0 0 7 833 2158 1451 0 0 0 
703 0 0 7 834 2158 1451 0 0 0 
704 0 0 7 835 2158 1451 0 0 0 
705 0 0 7 836 2158 1451 0 0 0 
706 0 0 7 837 2158 1451 0 0 0 
707 0 0 7 838 2158 1451 0 0 0 
708 0 0 7 839 2158 1451 0 0 0 
709 0 0 7 840 2158 1451 0 0 0 
710 0 0 7 841 2158 1451 0 0 0 
711 0 0 7 842 2158 1451 0 0 0 
712 0 0 7 843 2158 1451 0 0 0 
713 0 0 7 844 2158 1451 0 0 0 
714 0 0 7 845 2158 1451 0 0 0 
715 0 0 7 846 2158 1451 0 0 0 
716 0 0 7 847 2158 1451 0 0 0 
717 0 0 7 848 2158 1451 0 0 0 
718 0 0 7 849 2158 1451 0 0 0 
719 0 0 7 850 2158 1451 0 0 0 
720 0 0 7 851 2158 1451 0 0 0 
721 0 0 7 852 2158 1451 0 0 0 
722 0 0 7 853 2158 1451 0 0 0 
723 0 0 7 854 2158 1451 0 0 0 
724 0 0 7 855 2158 1451 0 0 0 
725 0 0 7 856 2158 1451 0 74 // Flight stick buttons, takes zero-based index.  First is always trigger. 0 
726 0 0 7 857 2158 1451 0 169 /**
 * Returns the ButtonHandle associated with the particular numbered joystick
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */ 1 13 button_number 1 1949  
727 0 0 7 858 2158 1451 0 0 0 
728 0 0 7 859 2158 1451 0 0 0 
729 0 0 7 860 2158 1451 0 0 0 
730 0 0 7 861 2158 1451 0 0 0 
731 0 0 7 919 2205 1750 0 0 0 
732 0 0 7 919 2205 1750 0 0 1 6 param0 0 2206  
733 0 0 7 867 2158 1451 0 144 /**
 * Returns the ButtonHandle associated with the particular ASCII character, if
 * there is one, or ButtonHandle::none() if there is not.
 */ 1 16 ascii_equivalent 1 1996  
734 0 0 7 868 2158 1451 0 0 0 
735 0 0 7 869 2158 1451 0 0 0 
736 0 0 7 870 2158 1451 0 0 0 
737 0 0 7 871 2158 1451 0 0 0 
738 0 0 7 872 2158 1451 0 0 0 
739 0 0 7 873 2158 1451 0 0 0 
740 0 0 7 874 2158 1451 0 0 0 
741 0 0 7 875 2158 1451 0 0 0 
742 0 0 7 876 2158 1451 0 0 0 
743 0 0 7 877 2158 1451 0 0 0 
744 0 0 7 878 2158 1451 0 0 0 
745 0 0 7 879 2158 1451 0 0 0 
746 0 0 7 880 2158 1451 0 0 0 
747 0 0 7 881 2158 1451 0 0 0 
748 0 0 7 882 2158 1451 0 0 0 
749 0 0 7 883 2158 1451 0 0 0 
750 0 0 7 884 2158 1451 0 0 0 
751 0 0 7 885 2158 1451 0 59 // PC keyboards don't have these four buttons, but Macs do. 0 
752 0 0 7 886 2158 1451 0 0 0 
753 0 0 7 887 2158 1451 0 0 0 
754 0 0 7 888 2158 1451 0 0 0 
755 0 0 7 889 2158 1451 0 0 0 
756 0 0 7 890 2158 1451 0 0 0 
757 0 0 7 891 2158 1451 0 0 0 
758 0 0 7 892 2158 1451 0 0 0 
759 0 0 7 893 2158 1451 0 0 0 
760 0 0 7 894 2158 1451 0 0 0 
761 0 0 7 895 2158 1451 0 0 0 
762 0 0 7 896 2158 1451 0 0 0 
763 0 0 7 897 2158 1451 0 0 0 
764 0 0 7 898 2158 1451 0 27 // delete is a C++ keyword. 0 
765 0 0 7 899 2158 1451 0 27 // delete is a C++ keyword. 0 
766 0 0 7 900 2158 1451 0 0 0 
767 0 0 7 901 2158 1451 0 0 0 
768 0 0 7 902 2158 1451 0 0 0 
769 0 0 7 903 2158 1451 0 0 0 
770 0 0 7 904 2158 1451 0 0 0 
771 0 0 7 905 2158 1451 0 0 0 
772 0 0 7 906 2158 1451 0 0 0 
773 0 0 7 907 2158 1451 0 0 0 
774 0 0 7 908 2158 1451 0 0 0 
775 0 0 7 909 2158 1451 0 0 0 
776 0 0 7 910 2158 1451 0 0 0 
777 0 0 7 911 2158 1451 0 0 0 
778 0 0 7 912 2158 1451 0 0 0 
779 0 0 7 913 2158 1451 0 0 0 
780 0 0 7 914 2158 1451 0 0 0 
781 0 0 7 915 2158 1451 0 0 0 
782 0 0 7 916 2158 1451 0 0 0 
783 0 0 7 917 2158 1451 0 0 0 
784 0 0 7 918 2158 1451 0 0 0 
785 0 0 7 926 2208 1756 0 10 /**
 *
 */ 0 
786 0 0 7 926 2208 1756 0 10 /**
 *
 */ 1 4 copy 1 2209  
787 0 0 6 928 2208 0 0 0 2 4 this 3 2208  4 copy 1 2209  
788 0 0 6 929 1950 0 0 0 2 4 this 3 2209  5 other 1 2209  
789 0 0 6 930 1950 0 0 0 2 4 this 3 2209  5 other 1 2209  
790 0 0 6 931 1950 0 0 0 2 4 this 3 2209  5 other 1 2209  
791 0 0 7 932 2208 1756 0 0 2 4 this 3 2209  5 other 1 2209  
792 0 0 7 933 2208 1756 0 0 2 4 this 3 2209  5 other 1 2209  
793 0 0 6 934 2208 0 0 0 2 4 this 3 2208  5 other 1 2209  
794 0 0 6 935 2208 0 0 0 2 4 this 3 2208  5 other 1 2209  
795 0 0 4 936 2083 0 0 374 /**
 * Sets the list of buttons to watch to be the same as that of the other
 * ModifierButtons object.  This makes the lists pointer equivalent (until one
 * or the other is later modified).
 *
 * This will preserve the state of any button that was on the original list
 * and is also on the new lists.  Any other buttons will get reset to the
 * default state of "up".
 */ 2 4 this 3 2208  5 other 1 2209  
796 0 0 6 937 1950 0 0 232 /**
 * Returns true if the set of buttons indicated as down by this
 * ModifierButtons object is the same set of buttons indicated as down by the
 * other ModifierButtons object.  The buttons indicated as up are not
 * relevant.
 */ 2 4 this 3 2209  5 other 1 2209  
797 0 0 6 938 1950 0 0 248 /**
 * Adds the indicated button to the set of buttons that will be monitored for
 * upness and downness.  Returns true if the button was added, false if it was
 * already being monitored or if too many buttons are currently being
 * monitored.
 */ 2 4 this 3 2208  6 button 1 2158  
798 0 0 6 939 1950 0 0 109 /**
 * Returns true if the indicated button is in the set of buttons being
 * monitored, false otherwise.
 */ 2 4 this 3 2209  6 button 1 2158  
799 0 0 6 940 1950 0 0 313 /**
 * Removes the indicated button from the set of buttons being monitored.
 * Returns true if the button was removed, false if it was not being monitored
 * in the first place.
 *
 * Unlike the other methods, you cannot remove a button by removing its alias;
 * you have to remove exactly the button itself.
 */ 2 4 this 3 2208  6 button 1 2158  
800 0 0 6 941 1949 0 0 143 /**
 * Returns the number of buttons that the ModifierButtons object is monitoring
 * (e.g.  the number of buttons passed to add_button()).
 */ 1 4 this 3 2209  
801 0 0 7 942 2158 1451 0 185 /**
 * Returns the nth button that the ModifierButtons object is monitoring (the
 * nth button passed to add_button()).  This must be in the range 0 <= index <
 * get_num_buttons().
 */ 2 4 this 3 2209  5 index 1 1949  
802 0 0 6 945 1950 0 0 305 /**
 * Records that a particular button has been pressed.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */ 2 4 this 3 2208  6 button 1 2158  
803 0 0 6 946 1950 0 0 306 /**
 * Records that a particular button has been released.  If the given button is
 * one of the buttons that is currently being monitored, this will update the
 * internal state appropriately; otherwise, it will do nothing.  Returns true
 * if the button is one that was monitored, or false otherwise.
 */ 2 4 this 3 2208  6 button 1 2158  
804 0 0 4 947 2083 0 0 66 /**
 * Marks all monitored buttons as being in the "up" state.
 */ 1 4 this 3 2208  
805 0 0 6 948 1950 0 0 157 /**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up or if it is not in the set of buttons being tracked.
 */ 2 4 this 3 2209  6 button 1 2158  
806 0 0 6 948 1950 0 0 105 /**
 * Returns true if the indicated button is known to be down, or false if it is
 * known to be up.
 */ 2 4 this 3 2209  5 index 1 1949  
807 0 0 6 949 1950 0 0 109 /**
 * Returns true if any of the tracked button are known to be down, or false if
 * all of them are up.
 */ 1 4 this 3 2209  
808 0 0 6 950 2098 0 0 150 /**
 * Returns a string which can be used to prefix any button name or event name
 * with the unique set of modifier buttons currently being held.
 */ 1 4 this 3 2209  
809 0 0 4 951 2083 0 0 69 /**
 * Writes a one-line summary of the buttons known to be down.
 */ 2 4 this 3 2209  3 out 1 2094  
810 0 0 4 952 2083 0 0 123 /**
 * Writes a multi-line summary including all of the buttons being monitored
 * and which ones are known to be down.
 */ 2 4 this 3 2209  3 out 1 2094  
811 0 0 7 965 2211 1792 0 0 0 
812 0 0 7 965 2211 1792 0 0 1 6 param0 0 2212  
813 0 0 7 954 2158 1451 0 166 /**
 * Returns the ButtonHandle associated with the particular numbered mouse
 * button (zero-based), if there is one, or ButtonHandle::none() if there is
 * not.
 */ 1 13 button_number 1 1949  
814 0 0 7 955 2158 1451 0 75 /**
 * Returns the ButtonHandle associated with the first mouse button.
 */ 0 
815 0 0 7 956 2158 1451 0 76 /**
 * Returns the ButtonHandle associated with the second mouse button.
 */ 0 
816 0 0 7 957 2158 1451 0 75 /**
 * Returns the ButtonHandle associated with the third mouse button.
 */ 0 
817 0 0 7 958 2158 1451 0 76 /**
 * Returns the ButtonHandle associated with the fourth mouse button.
 */ 0 
818 0 0 7 959 2158 1451 0 75 /**
 * Returns the ButtonHandle associated with the fifth mouse button.
 */ 0 
819 0 0 7 960 2158 1451 0 98 /**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * upwards.
 */ 0 
820 0 0 7 961 2158 1451 0 100 /**
 * Returns the ButtonHandle generated when the mouse wheel is rolled one notch
 * downwards.
 */ 0 
821 0 0 7 962 2158 1451 0 148 /**
 * Returns the ButtonHandle generated when the mouse is scrolled to the left.
 * Usually, you'll only find the horizontal scroll on laptops.
 */ 0 
822 0 0 7 963 2158 1451 0 149 /**
 * Returns the ButtonHandle generated when the mouse is scrolled to the right.
 * Usually, you'll only find the horizontal scroll on laptops.
 */ 0 
823 0 0 6 964 1950 0 0 117 /**
 * Returns true if the indicated ButtonHandle is a mouse button, false if it
 * is some other kind of button.
 */ 1 6 button 1 2158  
824 0 0 7 981 2214 1800 0 0 0 
825 0 0 7 981 2214 1800 0 0 1 6 param0 0 2215  
826 0 0 6 969 1948 0 0 10 /**
 *
 */ 1 4 this 3 2215  
827 0 0 6 970 1948 0 0 10 /**
 *
 */ 1 4 this 3 2215  
828 0 0 6 971 1950 0 0 157 /**
 * If this returns false, the pointer is not currently present in the window
 * and the values returned by get_x() and get_y() may not be meaningful.
 */ 1 4 this 3 2215  
829 0 0 6 985 1949 0 0 47 /**
 * Returns the current reference count.
 */ 1 4 this 3 2217  
830 0 0 4 986 2083 0 0 349 /**
 * Explicitly increments the reference count.
 *
 * This function is const, even though it changes the object, because
 * generally fiddling with an object's reference count isn't considered part
 * of fiddling with the object.  An object might be const in other ways, but
 * we still need to accurately count the number of references to it.
 */ 1 4 this 3 2217  
831 0 0 6 987 1950 0 0 201 /**
 * Explicitly decrements the node reference count and the normal reference
 * count simultaneously.
 *
 * The return value is true if the new reference count is nonzero, false if it
 * is zero.
 */ 1 4 this 3 2217  
832 0 0 6 988 1950 0 0 97 /**
 * Does some easy checks to make sure that the reference count isn't
 * completely bogus.
 */ 1 4 this 3 2217  
833 0 0 6 990 1949 0 0 293 /**
 * Returns the union of the values defined in the Referenced enum that
 * represents the various things that appear to be holding a pointer to this
 * object.
 *
 * If R_node is included, at least one node is holding a pointer; if R_cache
 * is included, at least one cache element is.
 */ 1 4 this 3 2217  
834 0 0 7 991 2096 0 0 0 0 
835 0 0 7 993 2219 1862 0 10 /**
 *
 */ 0 
836 0 0 7 993 2219 1862 0 10 /**
 *
 */ 1 4 from 1 2150  
837 0 0 7 993 2219 1862 0 0 1 6 param0 0 2152  
838 0 0 7 994 2219 1862 0 72 /**
 * Returns a SparseArray with an infinite array of bits, all on.
 */ 0 
839 0 0 7 995 2219 1862 0 56 /**
 * Returns a SparseArray whose bits are all off.
 */ 0 
840 0 0 7 996 2219 1862 0 65 /**
 * Returns a SparseArray whose lower on_bits bits are on.
 */ 1 7 on_bits 1 1949  
841 0 0 7 997 2219 1862 0 64 /**
 * Returns a SparseArray with only the indicated bit on.
 */ 1 5 index 1 1949  
842 0 0 7 998 2219 1862 0 79 /**
 * Returns a SparseArray whose size bits, beginning at low_bit, are on.
 */ 2 7 low_bit 1 1949  4 size 1 1949  
843 0 0 6 999 1950 0 0 393 /**
 * Returns true if there is a maximum number of bits that may be stored in
 * this structure, false otherwise.  If this returns true, the number may be
 * queried in get_max_num_bits().
 *
 * This method always returns false.  The SparseArray has no maximum number of
 * bits.  This method is defined so generic programming algorithms can use
 * BitMask or SparseArray interchangeably.
 */ 0 
844 0 0 6 1000 1949 0 0 428 /**
 * If get_max_num_bits() returned true, this method may be called to return
 * the maximum number of bits that may be stored in this structure.  It is an
 * error to call this if get_max_num_bits() return false.
 *
 * It is always an error to call this method.  The SparseArray has no maximum
 * number of bits.  This method is defined so generic programming algorithms
 * can use BitMask or SparseArray interchangeably.
 */ 0 
845 0 0 6 1001 1949 0 0 300 /**
 * Returns the current number of possibly different bits in this array.  There
 * are actually an infinite number of bits, but every bit higher than this bit
 * will have the same value, either 0 or 1 (see get_highest_bits()).
 *
 * This number may grow and/or shrink automatically as needed.
 */ 1 4 this 3 2152  
846 0 0 6 1002 1950 0 0 191 /**
 * Returns true if the nth bit is set, false if it is cleared.  It is valid
 * for n to increase beyond get_num_bits(), but the return value
 * get_num_bits() will always be the same.
 */ 2 4 this 3 2152  5 index 1 1949  
847 0 0 4 1003 2083 0 0 97 /**
 * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2219  5 index 1 1949  
848 0 0 4 1004 2083 0 0 98 /**
 * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends
 * the array.
 */ 2 4 this 3 2219  5 index 1 1949  
849 0 0 4 1005 2083 0 0 84 /**
 * Sets the nth bit either on or off, according to the indicated bool value.
 */ 3 4 this 3 2219  5 index 1 1949  5 value 1 1950  
850 0 0 6 1006 1950 0 0 118 /**
 * Returns true if the infinite set of bits beyond get_num_bits() are all on,
 * or false of they are all off.
 */ 1 4 this 3 2152  
851 0 0 6 1007 1950 0 0 71 /**
 * Returns true if the entire bitmask is zero, false otherwise.
 */ 1 4 this 3 2152  
852 0 0 6 1008 1950 0 0 70 /**
 * Returns true if the entire bitmask is one, false otherwise.
 */ 1 4 this 3 2152  
853 0 0 6 1009 1950 0 0 82 /**
 * Returns true if any bit in the indicated range is set, false otherwise.
 */ 3 4 this 3 2152  7 low_bit 1 1949  4 size 1 1949  
854 0 0 6 1010 1950 0 0 84 /**
 * Returns true if all bits in the indicated range are set, false otherwise.
 */ 3 4 this 3 2152  7 low_bit 1 1949  4 size 1 1949  
855 0 0 4 1011 2083 0 0 47 /**
 * Sets the indicated range of bits on.
 */ 3 4 this 3 2219  7 low_bit 1 1949  4 size 1 1949  
856 0 0 4 1012 2083 0 0 48 /**
 * Sets the indicated range of bits off.
 */ 3 4 this 3 2219  7 low_bit 1 1949  4 size 1 1949  
857 0 0 4 1013 2083 0 0 64 /**
 * Sets the indicated range of bits to either on or off.
 */ 4 4 this 3 2219  5 value 1 1950  7 low_bit 1 1949  4 size 1 1949  
858 0 0 6 1014 1949 0 0 127 /**
 * Returns the number of bits that are set to 1 in the array.  Returns -1 if
 * there are an infinite number of 1 bits.
 */ 1 4 this 3 2152  
859 0 0 6 1015 1949 0 0 127 /**
 * Returns the number of bits that are set to 0 in the array.  Returns -1 if
 * there are an infinite number of 0 bits.
 */ 1 4 this 3 2152  
860 0 0 6 1016 1949 0 0 146 /**
 * Returns the index of the lowest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there are an infinite number of 1 bits.
 */ 1 4 this 3 2152  
861 0 0 6 1017 1949 0 0 146 /**
 * Returns the index of the lowest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there are an infinite number of 1 bits.
 */ 1 4 this 3 2152  
862 0 0 6 1018 1949 0 0 143 /**
 * Returns the index of the highest 1 bit in the array.  Returns -1 if there
 * are no 1 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2152  
863 0 0 6 1019 1949 0 0 143 /**
 * Returns the index of the highest 0 bit in the array.  Returns -1 if there
 * are no 0 bits or if there an infinite number of 1 bits.
 */ 1 4 this 3 2152  
864 0 0 6 1020 1949 0 0 287 /**
 * Returns the index of the next bit in the array, above low_bit, whose value
 * is different that the value of low_bit.  Returns low_bit again if all bits
 * higher than low_bit have the same value.
 *
 * This can be used to quickly iterate through all of the bits in the array.
 */ 2 4 this 3 2152  7 low_bit 1 1949  
865 0 0 4 1021 2083 0 0 93 /**
 * Inverts all the bits in the SparseArray.  This is equivalent to array =
 * ~array.
 */ 1 4 this 3 2219  
866 0 0 6 1022 1950 0 0 181 /**
 * Returns true if this SparseArray has any "one" bits in common with the
 * other one, false otherwise.
 *
 * This is equivalent to (array & other) != 0, but may be faster.
 */ 2 4 this 3 2152  5 other 1 2152  
867 0 0 4 1023 2083 0 0 52 /**
 * Sets all the bits in the SparseArray off.
 */ 1 4 this 3 2219  
868 0 0 4 1024 2083 0 0 10 /**
 *
 */ 2 4 this 3 2152  3 out 1 2094  
869 0 0 6 1025 1950 0 0 0 2 4 this 3 2152  5 other 1 2152  
870 0 0 6 1026 1950 0 0 0 2 4 this 3 2152  5 other 1 2152  
871 0 0 6 1027 1950 0 0 0 2 4 this 3 2152  5 other 1 2152  
872 0 0 6 1028 1949 0 0 242 /**
 * Returns a number less than zero if this SparseArray sorts before the
 * indicated other SparseArray, greater than zero if it sorts after, or 0 if
 * they are equivalent.  This is based on the same ordering defined by
 * operator <.
 */ 2 4 this 3 2152  5 other 1 2152  
873 0 0 7 1029 2219 1862 0 0 2 4 this 3 2152  5 other 1 2152  
874 0 0 7 1030 2219 1862 0 0 2 4 this 3 2152  5 other 1 2152  
875 0 0 7 1031 2219 1862 0 0 2 4 this 3 2152  5 other 1 2152  
876 0 0 7 1032 2219 1862 0 0 1 4 this 3 2152  
877 0 0 7 1033 2219 1862 0 0 2 4 this 3 2152  5 shift 1 1949  
878 0 0 7 1034 2219 1862 0 0 2 4 this 3 2152  5 shift 1 1949  
879 0 0 6 1035 2219 0 0 0 2 4 this 3 2219  5 other 1 2152  
880 0 0 6 1036 2219 0 0 0 2 4 this 3 2219  5 other 1 2152  
881 0 0 6 1037 2219 0 0 0 2 4 this 3 2219  5 other 1 2152  
882 0 0 6 1038 2219 0 0 0 2 4 this 3 2219  5 shift 1 1949  
883 0 0 6 1039 2219 0 0 0 2 4 this 3 2219  5 shift 1 1949  
884 0 0 6 1040 1950 0 0 330 /**
 * If this is true, the SparseArray is actually defined as a list of subranges
 * of integers that are *not* in the set.  If this is false (the default),
 * then the subranges define the integers that *are* in the set.  This affects
 * the interpretation of the values returned by iterating through
 * get_num_subranges().
 */ 1 4 this 3 2152  
885 0 0 6 1041 2154 0 0 237 /**
 * Returns the number of separate subranges stored in the SparseArray.  You
 * can use this limit to iterate through the subranges, calling
 * get_subrange_begin() and get_subrange_end() for each one.
 *
 * Also see is_inverse().
 */ 1 4 this 3 2152  
886 0 0 6 1042 1949 0 0 94 /**
 * Returns the first numeric element in the nth subrange.
 *
 * Also see is_inverse().
 */ 2 4 this 3 2152  1 n 1 2154  
887 0 0 6 1043 1949 0 0 104 /**
 * Returns the last numeric element, plus one, in the nth subrange.
 *
 * Also see is_inverse().
 */ 2 4 this 3 2152  1 n 1 2154  
888 0 0 6 1044 1950 0 0 0 1 4 this 3 2152  
889 0 0 6 1045 1978 0 0 0 1 4 this 3 2152  
890 0 0 4 1046 2083 0 0 0 2 4 this 3 2219  5 state 1 1978  
891 0 0 7 1047 2096 0 0 0 0 
892 0 0 7 1050 2096 0 0 52 /**
 * Returns the type of the underlying value.
 */ 1 4 this 3 2220  
893 0 0 4 1051 2083 0 0 0 2 4 this 3 2220  3 out 1 2094  
894 0 0 7 1052 2096 0 0 0 0 
895 0 0 7 1054 2224 1070 0 10 /**
 *
 */ 1 5 value 1 2222  
896 0 0 7 1055 2038 0 0 55 /**
 * Retrieves the value stored in the parameter.
 */ 1 4 this 3 2225  
897 0 0 7 1058 2096 0 0 0 0 
898 0 0 7 1060 2227 1070 0 0 1 5 value 1 2098  
899 0 0 4 1061 2083 0 0 0 2 4 this 3 2227  5 value 1 2098  
900 0 0 6 1062 2098 0 0 0 1 4 this 3 2228  
901 0 0 7 1066 2096 0 0 0 0 
902 0 0 7 1069 2230 1070 0 0 1 5 value 1 2098  
903 0 0 4 1070 2083 0 0 0 2 4 this 3 2230  5 value 1 2098  
904 0 0 6 1071 2098 0 0 0 1 4 this 3 2231  
905 0 0 7 1073 2096 0 0 0 0 
906 0 0 7 1076 2236 1070 0 0 1 5 value 1 2233  
907 0 0 4 1077 2083 0 0 0 2 4 this 3 2236  5 value 1 2233  
908 0 0 6 1078 2233 0 0 0 1 4 this 3 2237  
909 0 0 7 1080 2096 0 0 0 0 
910 0 0 7 1083 2242 1070 0 0 1 5 value 1 2239  
911 0 0 4 1084 2083 0 0 0 2 4 this 3 2242  5 value 1 2239  
912 0 0 6 1085 2239 0 0 0 1 4 this 3 2243  
913 0 0 7 1087 2096 0 0 0 0 
914 0 0 7 1090 2248 1070 0 0 1 5 value 1 2245  
915 0 0 4 1091 2083 0 0 0 2 4 this 3 2248  5 value 1 2245  
916 0 0 6 1092 2245 0 0 0 1 4 this 3 2249  
917 0 0 7 1094 2096 0 0 0 0 
918 0 0 7 1097 2254 1070 0 0 1 5 value 1 2251  
919 0 0 4 1098 2083 0 0 0 2 4 this 3 2254  5 value 1 2251  
920 0 0 6 1099 2251 0 0 0 1 4 this 3 2255  
921 0 0 7 1101 2096 0 0 0 0 
922 0 0 7 1104 2260 1070 0 0 1 5 value 1 2257  
923 0 0 4 1105 2083 0 0 0 2 4 this 3 2260  5 value 1 2257  
924 0 0 6 1106 2257 0 0 0 1 4 this 3 2261  
925 0 0 7 1108 2096 0 0 0 0 
926 0 0 7 1111 2266 1070 0 0 1 5 value 1 2263  
927 0 0 4 1112 2083 0 0 0 2 4 this 3 2266  5 value 1 2263  
928 0 0 6 1113 2263 0 0 0 1 4 this 3 2267  
929 0 0 7 1115 2096 0 0 0 0 
930 0 0 7 1118 2272 1070 0 0 1 5 value 1 2269  
931 0 0 4 1119 2083 0 0 0 2 4 this 3 2272  5 value 1 2269  
932 0 0 6 1120 2269 0 0 0 1 4 this 3 2273  
933 0 0 7 1122 2096 0 0 0 0 
934 0 0 7 1125 2278 1070 0 0 1 5 value 1 2275  
935 0 0 4 1126 2083 0 0 0 2 4 this 3 2278  5 value 1 2275  
936 0 0 6 1127 2275 0 0 0 1 4 this 3 2279  
937 0 0 7 1129 2096 0 0 0 0 
938 0 0 7 1132 2284 1070 0 0 1 5 value 1 2281  
939 0 0 4 1133 2083 0 0 0 2 4 this 3 2284  5 value 1 2281  
940 0 0 6 1134 2281 0 0 0 1 4 this 3 2285  
941 0 0 7 1136 2096 0 0 0 0 
942 0 0 7 1139 2290 1070 0 0 1 5 value 1 2287  
943 0 0 4 1140 2083 0 0 0 2 4 this 3 2290  5 value 1 2287  
944 0 0 6 1141 2287 0 0 0 1 4 this 3 2291  
945 0 0 7 1143 2096 0 0 0 0 
946 0 0 7 1146 2296 1070 0 0 1 5 value 1 2293  
947 0 0 4 1147 2083 0 0 0 2 4 this 3 2296  5 value 1 2293  
948 0 0 6 1148 2293 0 0 0 1 4 this 3 2297  
949 0 0 7 1150 2096 0 0 0 0 
950 0 0 7 1153 2302 1070 0 0 1 5 value 1 2299  
951 0 0 4 1154 2083 0 0 0 2 4 this 3 2302  5 value 1 2299  
952 0 0 6 1155 2299 0 0 0 1 4 this 3 2303  
953 0 0 7 1157 2096 0 0 0 0 
954 0 0 7 1160 2308 1070 0 0 1 5 value 1 2305  
955 0 0 4 1161 2083 0 0 0 2 4 this 3 2308  5 value 1 2305  
956 0 0 6 1162 2305 0 0 0 1 4 this 3 2309  
957 0 0 7 1164 2096 0 0 0 0 
958 0 0 7 1172 2096 0 0 0 0 
959 0 0 7 1175 2311 1932 0 56 /**
 * Create a free id pool in the range [min:max].
 */ 2 3 min 1 2143  3 max 1 2143  
960 0 0 6 1177 2143 0 0 134 /**
 * Returns an id between _min and _max (that were passed to the constructor).
 * IndexEnd is returned if no ids are available.
 */ 1 4 this 3 2311  
961 0 0 4 1178 2083 0 0 518 /**
 * This may be called to mark a particular id as having already been allocated
 * (for instance, by a prior pass).  The specified id is removed from the
 * available pool.
 *
 * Because of the limitations of this algorithm, this is most efficient when
 * it is called before the first call to allocate(), and when all the calls to
 * initial_reserve_id() are made in descending order by id.  However, this is
 * a performance warning only; if performance is not an issue, any id may be
 * reserved at any time.
 */ 2 4 this 3 2311  2 id 1 2143  
962 0 0 6 1179 1950 0 0 119 /**
 * Checks the allocated state of an index. Returns true for
 * indices that are currently allocated and in use.
 */ 2 4 this 3 2311  5 index 1 2143  
963 0 0 6 1180 1950 0 0 278 /**
 * Free an allocated index (index must be between _min and _max that were
 * passed to the constructor).
 *
 * Since 1.11.0, returns true if the index has been freed successfully
 * or false if the index has not been allocated yet, instead of
 * triggering an assertion.
 */ 2 4 this 3 2311  5 index 1 2143  
964 0 0 6 1181 2314 0 0 117 /**
 * return the decimal fraction of the pool that is used.  The range is 0 to
 * 1.0 (e.g.  75% would be 0.75).
 */ 1 4 this 3 2312  
965 0 0 4 1182 2083 0 0 42 /**
 * ...intended for debugging only.
 */ 2 4 this 3 2312  3 out 1 2094  
966 0 0 4 1183 2083 0 0 42 /**
 * ...intended for debugging only.
 */ 2 4 this 3 2312  3 out 1 2094  
967 0 0 6 676 2010 0 0 0 1 3 str 1 2098  
968 0 0 6 677 2098 0 0 0 1 2 cs 1 2010  
969 0 0 6 678 2316 0 0 0 0 
970 0 0 6 679 2316 0 0 0 0 
971 0 0 6 921 2318 0 0 602 /**
 * A convenience function for loading explicit prc files from a disk file or
 * from within a multifile (via the virtual file system).  Save the return
 * value and pass it to unload_prc_file() if you ever want to unload this file
 * later.
 *
 * The filename is first searched along the default prc search path, and then
 * also along the model path, for convenience.
 *
 * This function is defined in putil instead of in dtool with the read of the
 * prc stuff, so that it can take advantage of the virtual file system (which
 * is defined in express), and the model path (which is in putil).
 */ 1 8 filename 1 2117  
972 0 0 6 922 2318 0 0 396 /**
 * Another convenience function to load a prc file from an explicit string,
 * which represents the contents of the prc file.
 *
 * The first parameter is an arbitrary name to assign to this in-memory prc
 * file.  Supply a filename if the data was read from a file, or use any other
 * name that is meaningful to you.  The name is only used when the set of
 * loaded prc files is listed.
 */ 2 4 name 1 2098  4 data 1 2098  
973 0 0 6 923 1950 0 0 0 1 4 page 1 2318  
974 0 0 4 924 2083 0 0 0 1 4 hash 1 2320  
975 0 0 6 1184 1978 0 0 203 /**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This hooks into the native pickle and cPickle modules, but it cannot
 * properly handle self-referential BAM objects.
 */ 2 10 this_class 1 1978  4 data 1 2014  
976 0 0 6 1185 1978 0 0 398 /**
 * This wrapper is defined as a global function to suit pickle's needs.
 *
 * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides
 * additional support for the missing persistent-state object needed to
 * properly support self-referential BAM objects written to the pickle stream.
 * This hooks into the pickle and cPickle modules implemented in
 * direct/src/stdpy.
 */ 3 9 unpickler 1 1978  10 this_class 1 1978  4 data 1 2014  
380
1942 41 ConstPointerToArray< unsigned short int > 0 141313 41 ConstPointerToArray< unsigned short int > 41 ConstPointerToArray< unsigned short int > 0 0 0 1 982 995 0 12 983 984 985 986 987 988 989 990 991 992 993 994 0 0 1 0 1943 0 0 0 0 0

1943 40 PointerToArrayBase< unsigned short int > 0 26625 40 PointerToArrayBase< unsigned short int > 40 PointerToArrayBase< unsigned short int > 0 0 0 0 979 0 2 980 981 0 0 1 0 1944 0 0 0 0 0

1944 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 0 43009 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 61 PointerToBase< ReferenceCountedVector< unsigned short int > > 0 0 0 0 0 0 2 977 978 0 0 1 0 1945 0 0 0 0 0

1945 13 PointerToVoid 0 2048 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 373
/**
 * This is the non-template part of the base class for PointerTo and
 * ConstPointerTo.  It is necessary so we can keep a pointer to a non-template
 * class within the ReferenceCount object, to implement weak reference
 * pointers--we need to have something to clean up when the ReferenceCount
 * object destructs.
 *
 * This is the base class for PointerToBase<T>.
 */

1946 36 PointerToArray< unsigned short int > 0 141313 36 PointerToArray< unsigned short int > 36 PointerToArray< unsigned short int > 0 0 0 1 996 1016 0 19 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 0 0 1 0 1943 0 0 0 0 0

1947 13 AnimInterface 0 26625 13 AnimInterface 13 AnimInterface 0 0 0 0 1017 9 2322 2323 2324 2325 2326 2327 2328 2329 2330 17 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

1948 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

1949 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

1950 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

1951 16 AutoTextureScale 0 532481 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0
0 8 ATS_down 8 ATS_down 0
1 6 ATS_up 6 ATS_up 0
2 7 ATS_pad 7 ATS_pad 0
3 15 ATS_unspecified 15 ATS_unspecified 0
4 0 0

1952 9 UpdateSeq 0 141313 9 UpdateSeq 9 UpdateSeq 0 0 0 1 1035 1055 1 2331 19 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 0 0 0 0 0 761
/**
 * This is a sequence number that increments monotonically.  It can be used to
 * track cache updates, or serve as a kind of timestamp for any changing
 * properties.
 *
 * A special class is used instead of simply an int, so we can elegantly
 * handle such things as wraparound and special cases.  There are two special
 * cases.  Firstly, a sequence number is 'initial' when it is first created.
 * This sequence is older than any other sequence number.  Secondly, a
 * sequence number may be explicitly set to 'old'.  This is older than any
 * other sequence number except 'initial'.  Finally, we have the explicit
 * number 'fresh', which is newer than any other sequence number.  All other
 * sequences are numeric and are monotonically increasing.
 */

1953 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 1954 0 1955 0 0 0 0 0 0 0 0 0 0

1954 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

1955 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1956 13 TypedWritable 0 75777 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 8 1056 1057 1058 1059 1060 1061 1062 1063 0 0 1 0 1957 0 0 0 0 135
/**
 * Base class for objects that can be written to and read from Bam files.
 *
 * See also TypedObject for detailed instructions.
 */

1957 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

1958 27 TypedWritableReferenceCount 0 141313 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 1070 0 2 1068 1069 0 0 2 3 1956 1064 1065 3 1959 1066 1067 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

1959 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

1960 14 BamCacheRecord 0 26625 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 1075 5 2332 2333 2334 2335 2336 19 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 0 0 2 3 1958 1071 1072 3 1961 1073 1074 0 0 231
/**
 * An instance of this class is written to the front of a Bam or Txo file to
 * make the file a cached instance of some other loadable resource.  This
 * record contains information needed to test the validity of the cache.
 */

1961 14 LinkedListNode 0 1050624 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 468
/**
 * This just stores the pointers to implement a doubly-linked list of some
 * kind of object.  There are occasions when a hand-rolled linked list is more
 * appropriate than an STL container.
 *
 * Typically, each node of the linked list, as well as the root of the list,
 * will inherit from this class.
 *
 * Note that this class is not inherently thread-safe; derived classes are
 * responsible for protecting any calls into it within mutexes, if necessary.
 */

1962 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1963 0 0 0 0 0 0 0 0 0 0

1963 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

1964 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1955 0 0 0 0 0 0 0 0 0 0

1965 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 1956 0 0 0 0 0 0 0 0 0 0

1966 8 BamCache 0 26625 8 BamCache 8 BamCache 0 0 0 1 1095 1096 9 2337 2338 2339 2340 2341 2342 2343 2344 2345 26 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 0 0 0 0 0 615
/**
 * This class maintains a cache of Bam and/or Txo objects generated from model
 * files and texture images (as well as possibly other kinds of loadable
 * objects that can be stored in bam file format).
 *
 * This class also maintains a persistent index that lists all of the cached
 * objects (see BamCacheIndex). We go through some considerable effort to make
 * sure this index gets saved correctly to disk, even in the presence of
 * multiple different processes writing to the same index, and without relying
 * too heavily on low-level os-provided file locks (which work poorly with C++
 * iostreams).
 */

1967 8 BamEnums 0 141313 8 BamEnums 8 BamEnums 0 0 0 1 1123 1124 0 0 0 0 0 0 3 1968 1969 1970 104
/**
 * This class exists just to provide scoping for the enums shared by BamReader
 * and BamWriter.
 */

1968 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 1967 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0
0 15 BE_littleendian 25 BamEnums::BE_littleendian 0
1 9 BE_native 19 BamEnums::BE_native 0
1 0 365
/**
   * This defines an enumerated type used to represent the endianness of
   * certain numeric values stored in a Bam file.  It really has only two
   * possible values, either BE_bigendian or BE_littleendian; but through a
   * preprocessor trick we also add BE_native, which is the same numerically
   * as whichever value the hardware supports natively.
   */

1969 13 BamObjectCode 0 794624 23 BamEnums::BamObjectCode 23 BamEnums::BamObjectCode 1967 0 0 0 0 0 0 0 0 0 5 8 BOC_push 18 BamEnums::BOC_push 107
// Indicates an object definition, and will always be eventually paired
// with a BOC_pop (which does not).
0 7 BOC_pop 17 BamEnums::BOC_pop 0
1 11 BOC_adjunct 21 BamEnums::BOC_adjunct 105
// Includes an object definition but does not push the level; it is
// associated with the current level.
2 10 BOC_remove 20 BamEnums::BOC_remove 65
// Lists object IDs that have been deallocated on the sender end.
3 13 BOC_file_data 23 BamEnums::BOC_file_data 137
// May appear at any level and indicates the following datagram contains
// auxiliary file data that may be referenced by a later object.
4 0 107
/**
   * This is the code written along with each object.  It is used to control
   * object scoping.
   */

1970 14 BamTextureMode 0 794624 24 BamEnums::BamTextureMode 24 BamEnums::BamTextureMode 1967 0 0 0 0 0 0 0 0 0 5 13 BTM_unchanged 23 BamEnums::BTM_unchanged 0
0 12 BTM_fullpath 22 BamEnums::BTM_fullpath 0
1 12 BTM_relative 22 BamEnums::BTM_relative 0
2 12 BTM_basename 22 BamEnums::BTM_basename 0
3 11 BTM_rawdata 21 BamEnums::BTM_rawdata 0
4 0 73
// This enum is used to control how textures are written to a bam stream.

1971 13 LoaderOptions 0 141313 13 LoaderOptions 13 LoaderOptions 0 0 0 1 1125 1135 4 2346 2347 2348 2349 9 1126 1127 1128 1129 1130 1131 1132 1133 1134 0 0 0 0 2 1972 1973 65
/**
 * Specifies parameters that may be passed to the loader.
 */

1972 11 LoaderFlags 0 794624 26 LoaderOptions::LoaderFlags 26 LoaderOptions::LoaderFlags 1971 0 0 0 0 0 0 0 0 0 10 9 LF_search 24 LoaderOptions::LF_search 0
1 16 LF_report_errors 31 LoaderOptions::LF_report_errors 0
2 19 LF_convert_skeleton 34 LoaderOptions::LF_convert_skeleton 0
4 19 LF_convert_channels 34 LoaderOptions::LF_convert_channels 0
8 15 LF_convert_anim 30 LoaderOptions::LF_convert_anim 22
// skeleton + channels
12 16 LF_no_disk_cache 31 LoaderOptions::LF_no_disk_cache 20
// disallow BamCache
16 15 LF_no_ram_cache 30 LoaderOptions::LF_no_ram_cache 21
// disallow ModelPool
32 11 LF_no_cache 26 LoaderOptions::LF_no_cache 19
// no_disk + no_ram
48 13 LF_cache_only 28 LoaderOptions::LF_cache_only 23
// fail if not in cache
64 17 LF_allow_instance 32 LoaderOptions::LF_allow_instance 35
// returned pointer might be shared
128 0 33
// Flags for loading model files.

1973 12 TextureFlags 0 794624 27 LoaderOptions::TextureFlags 27 LoaderOptions::TextureFlags 1971 0 0 0 0 0 0 0 0 0 9 10 TF_preload 25 LoaderOptions::TF_preload 30
// Texture will have RAM image
4 17 TF_preload_simple 32 LoaderOptions::TF_preload_simple 37
// Texture will have simple RAM image
8 11 TF_allow_1d 26 LoaderOptions::TF_allow_1d 40
// If texture is Nx1, make a 1-d texture
16 19 TF_generate_mipmaps 34 LoaderOptions::TF_generate_mipmaps 30
// Consider generating mipmaps
32 12 TF_multiview 27 LoaderOptions::TF_multiview 36
// Load a multiview texture in pages
64 10 TF_integer 25 LoaderOptions::TF_integer 35
// Load as an integer (RGB) texture
128 8 TF_float 23 LoaderOptions::TF_float 43
// Load as a floating-point (depth) texture
256 20 TF_allow_compression 35 LoaderOptions::TF_allow_compression 33
// Consider compressing RAM image
512 13 TF_no_filters 28 LoaderOptions::TF_no_filters 38
// disallow using texture pool filters
1024 0 35
// Flags for loading texture files.

1974 9 BamReader 0 26625 9 BamReader 9 BamReader 0 0 0 1 1136 1137 6 2350 2351 2352 2353 2354 2355 20 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 0 0 1 0 1967 0 0 0 0 1311
/**
 * This is the fundamental interface for extracting binary objects from a Bam
 * file, as generated by a BamWriter.
 *
 * A Bam file can be thought of as a linear collection of objects.  Each
 * object is an instance of a class that inherits, directly or indirectly,
 * from TypedWritable.  The objects may include pointers to other objects
 * within the Bam file; the BamReader automatically manages these (with help
 * from code within each class) and restores the pointers correctly.
 *
 * This is the abstract interface and does not specifically deal with disk
 * files, but rather with a DatagramGenerator of some kind, which is simply a
 * linear source of Datagrams.  It is probably from a disk file, but it might
 * conceivably be streamed directly from a network or some such nonsense.
 *
 * Bam files are most often used to store scene graphs or subgraphs, and by
 * convention they are given filenames ending in the extension ".bam" when
 * they are used for this purpose.  However, a Bam file may store any
 * arbitrary list of TypedWritable objects; in this more general usage, they
 * are given filenames ending in ".boo" to differentiate them from the more
 * common scene graph files.
 *
 * See also BamFile, which defines a higher-level interface to read and write
 * Bam files on disk.
 */

1975 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1976 0 0 0 0 0 0 0 0 0 0

1976 17 DatagramGenerator 0 2048 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This class defines the abstract interace to any source of datagrams,
 * whether it be from a file or from the net.
 */

1977 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 1971 0 0 0 0 0 0 0 0 0 0

1978 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 1979 0 0 0 0 0 0 0 0 0 0

1979 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 1980 0 0 0 0 0 0 0 0 0 0

1980 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

1981 9 BamWriter 0 26625 9 BamWriter 9 BamWriter 0 0 0 1 1158 1159 6 2356 2357 2358 2359 2360 2361 16 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 0 0 1 0 1967 0 0 0 0 1376
/**
 * This is the fundamental interface for writing binary objects to a Bam file,
 * to be extracted later by a BamReader.
 *
 * A Bam file can be thought of as a linear collection of objects.  Each
 * object is an instance of a class that inherits, directly or indirectly,
 * from TypedWritable.  The objects may include pointers to other objects; the
 * BamWriter automatically manages these (with help from code within each
 * class) and writes all referenced objects to the file in such a way that the
 * pointers may be correctly restored later.
 *
 * This is the abstract interface and does not specifically deal with disk
 * files, but rather with a DatagramSink of some kind, which simply accepts a
 * linear stream of Datagrams.  It is probably written to a disk file, but it
 * might conceivably be streamed directly to a network or some such nonsense.
 *
 * Bam files are most often used to store scene graphs or subgraphs, and by
 * convention they are given filenames ending in the extension ".bam" when
 * they are used for this purpose.  However, a Bam file may store any
 * arbitrary list of TypedWritable objects; in this more general usage, they
 * are given filenames ending in ".boo" to differentiate them from the more
 * common scene graph files.
 *
 * See also BamFile, which defines a higher-level interface to read and write
 * Bam files on disk.
 */

1982 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 1983 0 0 0 0 0 0 0 0 0 0

1983 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 135
/**
 * This class defines the abstract interface to sending datagrams to any
 * target, whether it be into a file or across the net
 */

1984 23 BitMask< uint16_t, 16 > 0 141313 23 BitMask< uint16_t, 16 > 23 BitMask< uint16_t, 16 > 0 0 0 1 1176 1240 0 63 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 0 0 0 0 0 0

1985 9 BitMask16 0 2105345 9 BitMask16 9 BitMask16 0 0 1984 0 0 0 0 0 0 0 0 0 0

1986 23 BitMask< uint32_t, 32 > 0 141313 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 1 1241 1305 0 63 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 0 0 0 0 0 0

1987 9 BitMask32 0 2105345 9 BitMask32 9 BitMask32 0 0 1986 0 0 0 0 0 0 0 0 0 0

1988 23 BitMask< uint64_t, 64 > 0 141313 23 BitMask< uint64_t, 64 > 23 BitMask< uint64_t, 64 > 0 0 0 1 1306 1370 0 63 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 0 0 0 0 0 0

1989 9 BitMask64 0 2105345 9 BitMask64 9 BitMask64 0 0 1988 0 0 0 0 0 0 0 0 0 0

1990 13 BitMaskNative 0 1 13 BitMaskNative 13 BitMaskNative 0 0 0 0 0 0 0 0 0 0 0 0 0

1991 8 BitArray 0 141313 8 BitArray 8 BitArray 0 0 0 1 1371 1431 0 59 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 0 0 0 0 1 1992 210
/**
 * A dynamic array with an unlimited number of bits.
 *
 * This is similar to a BitMask, except it appears to contain an infinite
 * number of bits.  You can use it very much as you would use a BitMask.
 */

1992 0 0 794624 10 BitArray:: 0 1991 0 0 0 0 0 0 0 0 0 1 17 num_bits_per_word 27 BitArray::num_bits_per_word 0
64 0 0

1993 12 ButtonHandle 0 16918529 12 ButtonHandle 12 ButtonHandle 0 0 0 1 1432 1451 4 2362 2363 2364 2365 17 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1450 0 1 1449 0 0 0 162
/**
 * A ButtonHandle represents a single button from any device, including
 * keyboard buttons and mouse buttons (but see KeyboardButton and
 * MouseButton).
 */

1994 6 string 0 2105344 11 std::string 11 std::string 0 0 1995 0 0 0 0 0 0 0 0 0 0

1995 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

1996 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

1997 14 ButtonRegistry 0 141313 14 ButtonRegistry 14 ButtonRegistry 0 0 0 1 1457 1458 0 5 1452 1453 1454 1455 1456 0 0 0 0 0 188
/**
 * The ButtonRegistry class maintains all the assigned ButtonHandles in a
 * given system.  There should be only one ButtonRegistry class during the
 * lifetime of the application.
 */

1998 9 ButtonMap 0 141313 9 ButtonMap 9 ButtonMap 0 0 0 1 1466 1467 0 7 1459 1460 1461 1462 1463 1464 1465 0 0 1 0 1999 0 0 0 0 328
/**
 * This class represents a map containing all of the buttons of a (keyboard)
 * device, though it can also be used as a generic mapping between
 * ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,
 * which may optionally be associated with an appropriate platform-specific
 * name for the button.
 */

1999 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

2000 14 CallbackObject 0 141313 14 CallbackObject 14 CallbackObject 0 0 0 1 1471 1472 0 3 1468 1469 1470 0 0 1 0 1999 0 0 0 0 276
/**
 * This is a generic object that can be assigned to a callback at various
 * points in the rendering process.  This is actually a base class for a
 * handful of specialized callback object types.  You can also subclass it
 * yourself to make your own callback handler.
 */

2001 33 CachedTypedWritableReferenceCount 0 43009 33 CachedTypedWritableReferenceCount 33 CachedTypedWritableReferenceCount 0 0 0 0 0 1 2366 5 1473 1474 1475 1476 1477 0 0 1 0 1958 0 0 0 0 722
/**
 * This is a special extension to ReferenceCount that includes dual reference
 * counts: the standard reference count number, which includes all references
 * to the object, and a separate number (the cache reference count) that
 * counts the number of references to the object just within its cache alone.
 * When get_ref_count() == get_cache_ref_count(), the object is not referenced
 * outside the cache.
 *
 * The cache refs must be explicitly maintained; there is no PointerTo<> class
 * to maintain the cache reference counts automatically.  The cache reference
 * count is automatically included in the overall reference count: calling
 * cache_ref() and cache_unref() automatically calls ref() and unref().
 */

2002 12 CallbackData 0 141313 12 CallbackData 12 CallbackData 0 0 0 0 1481 0 3 1478 1479 1480 0 0 1 0 1957 0 0 0 0 348
/**
 * This is a generic data block that is passed along to a CallbackObject when
 * a callback is made.  It contains data specific to the particular callback
 * type in question.
 *
 * This is actually an abstract base class and contains no data.
 * Specializations of this class will contain the actual data relevant to each
 * callback type.
 */

2003 20 PythonCallbackObject 0 75777 20 PythonCallbackObject 20 PythonCallbackObject 0 0 0 1 1482 1472 1 2367 7 1483 1484 1485 1486 1487 1488 1489 0 0 1 0 2000 0 0 0 0 157
/**
 * This is a specialization on CallbackObject to allow a callback to directly
 * call an arbitrary Python function.  Powerful!  But use with caution.
 */

2004 7 TimeVal 0 141313 7 TimeVal 7 TimeVal 0 0 0 1 1490 1495 1 2368 2 1491 1492 0 0 0 0 0 0

2005 21 unsigned long int [2] 0 4202496 21 unsigned long int [2] 21 unsigned long int [2] 0 0 2006 2 0 0 0 0 0 0 0 0 0 0

2006 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

2007 11 ClockObject 0 75777 11 ClockObject 11 ClockObject 0 0 0 1 1496 0 11 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 28 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 0 0 1 0 1959 0 0 0 1 2008 1000
/**
 * A ClockObject keeps track of elapsed real time and discrete time.  In
 * normal mode, get_frame_time() returns the time as of the last time tick()
 * was called.  This is the "discrete" time, and is usually used to get the
 * time as of, for instance, the beginning of the current frame.
 *
 * In other modes, as set by set_mode() or the clock-mode config variable,
 * get_frame_time() may return other values to simulate different timing
 * effects, for instance to perform non-real-time animation.  See set_mode().
 *
 * In all modes, get_real_time() always returns the elapsed real time in
 * seconds since the ClockObject was constructed, or since it was last reset.
 *
 * You can create your own ClockObject whenever you want to have your own
 * local timer.  There is also a default, global ClockObject intended to
 * represent global time for the application; this is normally set up to tick
 * every frame so that its get_frame_time() will return the time for the
 * current frame.
 */

2008 4 Mode 0 794624 17 ClockObject::Mode 17 ClockObject::Mode 2007 0 0 0 0 0 0 0 0 0 8 8 M_normal 21 ClockObject::M_normal 0
0 15 M_non_real_time 28 ClockObject::M_non_real_time 0
1 8 M_forced 21 ClockObject::M_forced 0
2 9 M_degrade 22 ClockObject::M_degrade 0
3 7 M_slave 20 ClockObject::M_slave 0
4 9 M_limited 22 ClockObject::M_limited 0
5 9 M_integer 22 ClockObject::M_integer 0
6 17 M_integer_limited 30 ClockObject::M_integer_limited 0
7 0 0

2009 11 CollideMask 0 2105345 11 CollideMask 11 CollideMask 0 0 1987 0 0 0 0 0 0 0 0 0 0

2010 10 ColorSpace 0 532481 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105
// This value is not a color space, but is used to indicate that a color
// space has not been specified.
0 9 CS_linear 9 CS_linear 389
// CS_linear is not a color space per se, but represents the working color
// space of graphics APIs, which is linearized.  Since the conversion from
// sRGB to linear is defined, one could posit that it has the ITU-R BT.709
// primaries, but this isn't meaningful as modern graphics APIs do not
// perform color management.  All colors in Panda3D are linear unless
// otherwise specified.
1 7 CS_sRGB 7 CS_sRGB 107
// This is the standard, gamma-2.2-corrected sRGB color space, as used by
// the majority of image formats.
2 8 CS_scRGB 8 CS_scRGB 110
// This is a 16-bit encoded linear color space capable of encoding color
// values in the -0.5...7.4999 range.
3 0 0

2011 17 CopyOnWriteObject 0 141313 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 1532 0 3 1529 1530 1531 0 0 1 0 2001 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

2012 14 DatagramBuffer 0 141313 14 DatagramBuffer 14 DatagramBuffer 0 0 0 1 1537 1541 1 2380 1 1538 0 0 2 3 1983 1533 1534 3 1976 1535 1536 0 0 355
/**
 * This class can be used to write a series of datagrams into a memory buffer.
 * It acts as both a datagram sink and generator; you can fill it up with
 * datagrams and then read as many datagrams from it.
 *
 * This uses the same format as DatagramInputFile and DatagramOutputFile,
 * meaning that Datagram sizes are always stored little-endian.
 */

2013 18 vector_uchar const 0 8832 18 vector_uchar const 18 vector_uchar const 0 0 2014 0 0 0 0 0 0 0 0 0 0

2014 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 2015 0 0 0 0 0 0 0 0 0 0

2015 24 pvector< unsigned char > 0 2048 24 pvector< unsigned char > 24 pvector< unsigned char > 0 0 0 0 0 0 0 0 0 0 0 0 0

2016 17 DatagramInputFile 0 75777 17 DatagramInputFile 17 DatagramInputFile 0 0 0 1 1542 0 0 4 1543 1544 1545 1546 0 0 1 0 1976 0 0 0 0 130
/**
 * This class can be used to read a binary file that consists of an arbitrary
 * header followed by a number of datagrams.
 */

2017 18 DatagramOutputFile 0 75777 18 DatagramOutputFile 18 DatagramOutputFile 0 0 0 1 1547 0 1 2381 3 1548 1549 1550 0 0 1 0 1983 0 0 0 0 131
/**
 * This class can be used to write a binary file that consists of an arbitrary
 * header followed by a number of datagrams.
 */

2018 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

2019 30 DoubleBitMask< BitMaskNative > 0 141313 30 DoubleBitMask< BitMaskNative > 30 DoubleBitMask< BitMaskNative > 0 0 0 1 1552 1607 0 54 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 0 0 0 0 0 0

2020 19 DoubleBitMaskNative 0 2105345 19 DoubleBitMaskNative 19 DoubleBitMaskNative 0 0 2019 0 0 0 0 0 0 0 0 0 0

2021 36 DoubleBitMask< DoubleBitMaskNative > 0 141313 36 DoubleBitMask< DoubleBitMaskNative > 36 DoubleBitMask< DoubleBitMaskNative > 0 0 0 1 1608 1663 0 54 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 0 0 0 0 0 0

2022 17 QuadBitMaskNative 0 2105345 17 QuadBitMaskNative 17 QuadBitMaskNative 0 0 2021 0 0 0 0 0 0 0 0 0 0

2023 8 DrawMask 0 2105345 8 DrawMask 8 DrawMask 0 0 1987 0 0 0 0 0 0 0 0 0 0

2024 13 GamepadButton 0 141313 13 GamepadButton 13 GamepadButton 0 0 0 1 1695 1696 0 31 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 0 0 0 0 0 155
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to gamepad buttons.
 */

2025 10 PTA_ushort 0 2105345 10 PTA_ushort 10 PTA_ushort 0 0 1946 0 0 0 0 0 0 0 0 0 0

2026 11 CPTA_ushort 0 2105345 11 CPTA_ushort 11 CPTA_ushort 0 0 1942 0 0 0 0 0 0 0 0 0 0

2027 14 KeyboardButton 0 141313 14 KeyboardButton 14 KeyboardButton 0 0 0 1 1749 1750 0 52 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 0 0 0 0 0 162
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to standard keyboard keys.
 */

2028 15 ModifierButtons 0 26625 15 ModifierButtons 15 ModifierButtons 0 0 0 1 1755 1756 1 2382 23 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1 2405 0 0 0 0 135
/**
 * This class monitors the state of a number of individual buttons and tracks
 * whether each button is known to be down or up.
 */

2029 11 MouseButton 0 141313 11 MouseButton 11 MouseButton 0 0 0 1 1791 1792 0 11 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 0 0 0 0 0 162
/**
 * This class is just used as a convenient namespace for grouping all of these
 * handy functions that return buttons which map to standard mouse buttons.
 */

2030 11 PointerType 0 8921089 11 PointerType 11 PointerType 0 0 0 0 0 0 0 0 0 0 5 7 unknown 7 unknown 0
0 5 mouse 5 mouse 0
1 6 finger 6 finger 0
2 6 stylus 6 stylus 0
3 6 eraser 6 eraser 0
4 0 48
/**
 * Contains the types of pointer device.
 */

2031 11 PointerData 0 141313 11 PointerData 11 PointerData 0 0 0 1 1799 1800 6 2383 2384 2385 2386 2387 2388 3 1793 1794 1795 0 0 0 0 0 124
/**
 * Holds the data that might be generated by a 2-d pointer input device, such
 * as the mouse in the GraphicsWindow.
 */

2032 9 MouseData 0 2105345 9 MouseData 9 MouseData 0 0 2031 0 0 0 0 0 0 0 0 0 0

2033 24 NodeCachedReferenceCount 0 43009 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 6 1801 1802 1803 1804 1805 1806 0 0 1 0 2001 0 0 0 1 2034 1495
/**
 * This class further specializes CachedTypedWritableReferenceCount to also
 * add a node_ref_count, for the purposes of counting the number of times the
 * object is referenced by a "node", presumably a PandaNode.
 *
 * This essentially combines the functionality of NodeReferenceCount and
 * CachedTypedWritableReferenceCount, so that a derivative of this object
 * actually has three counters: the standard reference count, the "cache"
 * reference count, and the "node" reference count.  Rather than multiply
 * inheriting from the two reference count classes, we inherit only from
 * CachedTypedWritableReferenceCount and simply duplicate the functionality of
 * NodeReferenceCount, to avoid all of the problems associated with multiple
 * inheritance.
 *
 * The intended design is to use this as a base class for RenderState and
 * TransformState, both of which are held by PandaNodes, and also have caches
 * which are independently maintained.  By keeping track of how many nodes
 * hold a pointer to a particular object, we can classify each object into
 * node-referenced, cache-referenced, or other, which is primarily useful for
 * PStats reporting.
 *
 * As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),
 * the new methods node_ref() and node_unref() automatically increment and
 * decrement the primary reference count as well.  In this case, however,
 * there does exist a NodePointerTo<> class to maintain the node_ref counters
 * automatically.
 */

2034 10 Referenced 0 794624 36 NodeCachedReferenceCount::Referenced 36 NodeCachedReferenceCount::Referenced 2033 0 0 0 0 0 0 0 0 0 2 6 R_node 32 NodeCachedReferenceCount::R_node 0
1 7 R_cache 33 NodeCachedReferenceCount::R_cache 0
2 0 0

2035 11 SparseArray 0 141313 11 SparseArray 11 SparseArray 0 0 0 1 1807 1862 0 54 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 0 0 0 0 0 736
/**
 * This class records a set of integers, where each integer is either present
 * or not present in the set.
 *
 * It is similar in principle and in interface to a BitArray (which can be
 * thought of as a set of integers, one integer corresponding to each
 * different bit position), but the SparseArray is implemented as a list of
 * min/max subrange lists, rather than as a bitmask.
 *
 * This makes it particularly efficient for storing sets which consist of
 * large sections of consecutively included or consecutively excluded
 * elements, with arbitrarily large integers, but particularly inefficient for
 * doing boolean operations such as & or |.
 *
 * Also, unlike BitArray, the SparseArray can store negative integers.
 */

2036 14 ParamValueBase 0 75777 14 ParamValueBase 14 ParamValueBase 0 0 0 0 1070 0 3 1863 1864 1865 0 0 1 0 1958 0 0 0 0 141
/**
 * A non-template base class of ParamValue (below), which serves mainly to
 * define the placeholder for the virtual output function.
 */

2037 18 ParamTypedRefCount 0 75777 18 ParamTypedRefCount 18 ParamTypedRefCount 0 0 0 1 1866 1070 1 2389 2 1867 1868 0 0 1 0 2036 0 0 0 0 143
/**
 * A class object for storing specifically objects of type
 * TypedReferenceCount, which is different than TypedWritableReferenceCount.
 */

2038 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 1999 0 0 0 0 0 0 0 0 0 0

2039 20 ParamValue< string > 0 75777 25 ParamValue< std::string > 25 ParamValue< std::string > 0 0 0 1 1869 1070 1 2390 3 1870 1871 1872 0 0 1 0 2036 0 0 0 0 0

2040 10 Type const 0 8832 10 Type const 10 Type const 0 0 0 0 0 0 0 0 0 0 0 0 0

2041 11 ParamString 0 2105345 11 ParamString 11 ParamString 0 0 2039 0 0 0 0 0 0 0 0 0 0

2042 21 ParamValue< wstring > 0 75777 26 ParamValue< std::wstring > 26 ParamValue< std::wstring > 0 0 0 1 1873 1070 1 2391 3 1874 1875 1876 0 0 1 0 2036 0 0 0 0 0

2043 12 ParamWstring 0 2105345 12 ParamWstring 12 ParamWstring 0 0 2042 0 0 0 0 0 0 0 0 0 0

2044 24 ParamValue< LVecBase2d > 0 75777 24 ParamValue< LVecBase2d > 24 ParamValue< LVecBase2d > 0 0 0 1 1877 1070 1 2392 3 1878 1879 1880 0 0 1 0 2036 0 0 0 0 0

2045 14 ParamVecBase2d 0 2105345 14 ParamVecBase2d 14 ParamVecBase2d 0 0 2044 0 0 0 0 0 0 0 0 0 0

2046 24 ParamValue< LVecBase2f > 0 75777 24 ParamValue< LVecBase2f > 24 ParamValue< LVecBase2f > 0 0 0 1 1881 1070 1 2393 3 1882 1883 1884 0 0 1 0 2036 0 0 0 0 0

2047 14 ParamVecBase2f 0 2105345 14 ParamVecBase2f 14 ParamVecBase2f 0 0 2046 0 0 0 0 0 0 0 0 0 0

2048 24 ParamValue< LVecBase2i > 0 75777 24 ParamValue< LVecBase2i > 24 ParamValue< LVecBase2i > 0 0 0 1 1885 1070 1 2394 3 1886 1887 1888 0 0 1 0 2036 0 0 0 0 0

2049 14 ParamVecBase2i 0 2105345 14 ParamVecBase2i 14 ParamVecBase2i 0 0 2048 0 0 0 0 0 0 0 0 0 0

2050 24 ParamValue< LVecBase3d > 0 75777 24 ParamValue< LVecBase3d > 24 ParamValue< LVecBase3d > 0 0 0 1 1889 1070 1 2395 3 1890 1891 1892 0 0 1 0 2036 0 0 0 0 0

2051 14 ParamVecBase3d 0 2105345 14 ParamVecBase3d 14 ParamVecBase3d 0 0 2050 0 0 0 0 0 0 0 0 0 0

2052 24 ParamValue< LVecBase3f > 0 75777 24 ParamValue< LVecBase3f > 24 ParamValue< LVecBase3f > 0 0 0 1 1893 1070 1 2396 3 1894 1895 1896 0 0 1 0 2036 0 0 0 0 0

2053 14 ParamVecBase3f 0 2105345 14 ParamVecBase3f 14 ParamVecBase3f 0 0 2052 0 0 0 0 0 0 0 0 0 0

2054 24 ParamValue< LVecBase3i > 0 75777 24 ParamValue< LVecBase3i > 24 ParamValue< LVecBase3i > 0 0 0 1 1897 1070 1 2397 3 1898 1899 1900 0 0 1 0 2036 0 0 0 0 0

2055 14 ParamVecBase3i 0 2105345 14 ParamVecBase3i 14 ParamVecBase3i 0 0 2054 0 0 0 0 0 0 0 0 0 0

2056 24 ParamValue< LVecBase4d > 0 75777 24 ParamValue< LVecBase4d > 24 ParamValue< LVecBase4d > 0 0 0 1 1901 1070 1 2398 3 1902 1903 1904 0 0 1 0 2036 0 0 0 0 0

2057 14 ParamVecBase4d 0 2105345 14 ParamVecBase4d 14 ParamVecBase4d 0 0 2056 0 0 0 0 0 0 0 0 0 0

2058 24 ParamValue< LVecBase4f > 0 75777 24 ParamValue< LVecBase4f > 24 ParamValue< LVecBase4f > 0 0 0 1 1905 1070 1 2399 3 1906 1907 1908 0 0 1 0 2036 0 0 0 0 0

2059 14 ParamVecBase4f 0 2105345 14 ParamVecBase4f 14 ParamVecBase4f 0 0 2058 0 0 0 0 0 0 0 0 0 0

2060 24 ParamValue< LVecBase4i > 0 75777 24 ParamValue< LVecBase4i > 24 ParamValue< LVecBase4i > 0 0 0 1 1909 1070 1 2400 3 1910 1911 1912 0 0 1 0 2036 0 0 0 0 0

2061 14 ParamVecBase4i 0 2105345 14 ParamVecBase4i 14 ParamVecBase4i 0 0 2060 0 0 0 0 0 0 0 0 0 0

2062 23 ParamValue< LMatrix3d > 0 75777 23 ParamValue< LMatrix3d > 23 ParamValue< LMatrix3d > 0 0 0 1 1913 1070 1 2401 3 1914 1915 1916 0 0 1 0 2036 0 0 0 0 0

2063 13 ParamMatrix3d 0 2105345 13 ParamMatrix3d 13 ParamMatrix3d 0 0 2062 0 0 0 0 0 0 0 0 0 0

2064 23 ParamValue< LMatrix3f > 0 75777 23 ParamValue< LMatrix3f > 23 ParamValue< LMatrix3f > 0 0 0 1 1917 1070 1 2402 3 1918 1919 1920 0 0 1 0 2036 0 0 0 0 0

2065 13 ParamMatrix3f 0 2105345 13 ParamMatrix3f 13 ParamMatrix3f 0 0 2064 0 0 0 0 0 0 0 0 0 0

2066 23 ParamValue< LMatrix4d > 0 75777 23 ParamValue< LMatrix4d > 23 ParamValue< LMatrix4d > 0 0 0 1 1921 1070 1 2403 3 1922 1923 1924 0 0 1 0 2036 0 0 0 0 0

2067 13 ParamMatrix4d 0 2105345 13 ParamMatrix4d 13 ParamMatrix4d 0 0 2066 0 0 0 0 0 0 0 0 0 0

2068 23 ParamValue< LMatrix4f > 0 75777 23 ParamValue< LMatrix4f > 23 ParamValue< LMatrix4f > 0 0 0 1 1925 1070 1 2404 3 1926 1927 1928 0 0 1 0 2036 0 0 0 0 0

2069 13 ParamMatrix4f 0 2105345 13 ParamMatrix4f 13 ParamMatrix4f 0 0 2068 0 0 0 0 0 0 0 0 0 0

2070 13 ParamVecBase2 0 2105345 13 ParamVecBase2 13 ParamVecBase2 0 0 2047 0 0 0 0 0 0 0 0 0 0

2071 13 ParamVecBase3 0 2105345 13 ParamVecBase3 13 ParamVecBase3 0 0 2053 0 0 0 0 0 0 0 0 0 0

2072 13 ParamVecBase4 0 2105345 13 ParamVecBase4 13 ParamVecBase4 0 0 2059 0 0 0 0 0 0 0 0 0 0

2073 12 ParamMatrix3 0 2105345 12 ParamMatrix3 12 ParamMatrix3 0 0 2065 0 0 0 0 0 0 0 0 0 0

2074 12 ParamMatrix4 0 2105345 12 ParamMatrix4 12 ParamMatrix4 0 0 2069 0 0 0 0 0 0 0 0 0 0

2075 20 WritableConfigurable 0 141313 20 WritableConfigurable 20 WritableConfigurable 0 0 0 0 1930 0 1 1929 0 0 1 0 1956 0 0 0 0 379
/**
 * Defined as a fix to allow creating Configurable and Writable objects.
 * Otherwise the compiler gets confused since both TypedWritable and
 * Configurable inherit from TypedObject.
 *
 * An object that has data or parameters that are set less frequently (at
 * least occasionally) than every frame.  We can cache the configuration info
 * by by using the "dirty" flag.
 */

2076 17 UniqueIdAllocator 0 26625 17 UniqueIdAllocator 17 UniqueIdAllocator 0 0 0 1 1931 1932 0 7 1933 1934 1935 1936 1937 1938 1939 0 0 0 0 0 812
/**
 * Manage a set of ID values from min to max inclusive.  The ID numbers that
 * are freed will be allocated (reused) in the same order.  I.e.  the oldest
 * ID numbers will be allocated.
 *
 * This implementation will use 4 bytes per id number, plus a few bytes of
 * management data.  e.g.  10,000 ID numbers will use 40KB.
 *
 * Also be advised that ID -1 and -2 are used internally by the allocator.  If
 * allocate returns IndexEnd (-1) then the allocator is out of free ID
 * numbers.
 *
 * There are other implementations that can better leverage runs of used or
 * unused IDs or use bit arrays for the IDs.  But, it takes extra work to
 * track the age of freed IDs, which is required for what we wanted.  If you
 * would like to kick around other implementation ideas, please contact
 * Schuyler.
 */

2077 10 PortalMask 0 2105345 10 PortalMask 10 PortalMask 0 0 1987 0 0 0 0 0 0 0 0 0 0

2078 49 ConstPointerToArray< unsigned short int > const * 0 8576 49 ConstPointerToArray< unsigned short int > const * 49 ConstPointerToArray< unsigned short int > const * 0 0 2079 0 0 0 0 0 0 0 0 0 0

2079 47 ConstPointerToArray< unsigned short int > const 0 8832 47 ConstPointerToArray< unsigned short int > const 47 ConstPointerToArray< unsigned short int > const 0 0 1942 0 0 0 0 0 0 0 0 0 0

2080 43 ConstPointerToArray< unsigned short int > * 0 8576 43 ConstPointerToArray< unsigned short int > * 43 ConstPointerToArray< unsigned short int > * 0 0 1942 0 0 0 0 0 0 0 0 0 0

2081 44 PointerToArray< unsigned short int > const * 0 8576 44 PointerToArray< unsigned short int > const * 44 PointerToArray< unsigned short int > const * 0 0 2082 0 0 0 0 0 0 0 0 0 0

2082 42 PointerToArray< unsigned short int > const 0 8832 42 PointerToArray< unsigned short int > const 42 PointerToArray< unsigned short int > const 0 0 1946 0 0 0 0 0 0 0 0 0 0

2083 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

2084 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

2085 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

2086 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 2087 0 0 0 0 0 0 0 0 0 0

2087 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 2088 0 0 0 0 0 0 0 0 0 0

2088 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0

2089 48 PointerToArrayBase< unsigned short int > const * 0 8576 48 PointerToArrayBase< unsigned short int > const * 48 PointerToArrayBase< unsigned short int > const * 0 0 2090 0 0 0 0 0 0 0 0 0 0

2090 46 PointerToArrayBase< unsigned short int > const 0 8832 46 PointerToArrayBase< unsigned short int > const 46 PointerToArrayBase< unsigned short int > const 0 0 1943 0 0 0 0 0 0 0 0 0 0

2091 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 0 8576 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 63 PointerToBase< ReferenceCountedVector< unsigned short int > > * 0 0 1944 0 0 0 0 0 0 0 0 0 0

2092 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 0 8576 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 69 PointerToBase< ReferenceCountedVector< unsigned short int > > const * 0 0 2093 0 0 0 0 0 0 0 0 0 0

2093 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 0 8832 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 67 PointerToBase< ReferenceCountedVector< unsigned short int > > const 0 0 1944 0 0 0 0 0 0 0 0 0 0

2094 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 2018 0 0 0 0 0 0 0 0 0 0

2095 38 PointerToArray< unsigned short int > * 0 8576 38 PointerToArray< unsigned short int > * 38 PointerToArray< unsigned short int > * 0 0 1946 0 0 0 0 0 0 0 0 0 0

2096 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 2097 0 0 0 0 0 0 0 0 0 0

2097 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

2098 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

2099 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 1947 0 0 0 0 0 0 0 0 0 0

2100 21 AnimInterface const * 0 8576 21 AnimInterface const * 21 AnimInterface const * 0 0 2101 0 0 0 0 0 0 0 0 0 0

2101 19 AnimInterface const 0 8832 19 AnimInterface const 19 AnimInterface const 0 0 1947 0 0 0 0 0 0 0 0 0 0

2102 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 1952 0 0 0 0 0 0 0 0 0 0

2103 17 UpdateSeq const * 0 8576 17 UpdateSeq const * 17 UpdateSeq const * 0 0 2104 0 0 0 0 0 0 0 0 0 0

2104 15 UpdateSeq const 0 8832 15 UpdateSeq const 15 UpdateSeq const 0 0 1952 0 0 0 0 0 0 0 0 0 0

2105 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 2106 0 0 0 0 0 0 0 0 0 0

2106 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 0

2107 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 1974 0 0 0 0 0 0 0 0 0 0

2108 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 2109 0 0 0 0 0 0 0 0 0 0

2109 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 1956 0 0 0 0 0 0 0 0 0 0

2110 14 vector_uchar * 0 8576 14 vector_uchar * 14 vector_uchar * 0 0 2014 0 0 0 0 0 0 0 0 0 0

2111 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 1981 0 0 0 0 0 0 0 0 0 0

2112 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 1958 0 0 0 0 0 0 0 0 0 0

2113 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1959 0 0 0 0 0 0 0 0 0 0

2114 22 BamCacheRecord const * 0 8576 22 BamCacheRecord const * 22 BamCacheRecord const * 0 0 2115 0 0 0 0 0 0 0 0 0 0

2115 20 BamCacheRecord const 0 8832 20 BamCacheRecord const 20 BamCacheRecord const 0 0 1960 0 0 0 0 0 0 0 0 0 0

2116 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 1960 0 0 0 0 0 0 0 0 0 0

2117 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1962 0 0 0 0 0 0 0 0 0 0

2118 19 VirtualFile const * 0 8576 19 VirtualFile const * 19 VirtualFile const * 0 0 2119 0 0 0 0 0 0 0 0 0 0

2119 17 VirtualFile const 0 8832 17 VirtualFile const 17 VirtualFile const 0 0 2120 0 0 0 0 0 0 0 0 0 0

2120 11 VirtualFile 0 2048 11 VirtualFile 11 VirtualFile 0 0 0 0 0 0 0 0 0 0 0 0 0

2121 10 BamCache * 0 8576 10 BamCache * 10 BamCache * 0 0 1966 0 0 0 0 0 0 0 0 0 0

2122 16 BamCache const * 0 8576 16 BamCache const * 16 BamCache const * 0 0 2123 0 0 0 0 0 0 0 0 0 0

2123 14 BamCache const 0 8832 14 BamCache const 14 BamCache const 0 0 1966 0 0 0 0 0 0 0 0 0 0

2124 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1963 0 0 0 0 0 0 0 0 0 0

2125 10 BamEnums * 0 8576 10 BamEnums * 10 BamEnums * 0 0 1967 0 0 0 0 0 0 0 0 0 0

2126 16 BamEnums const * 0 8576 16 BamEnums const * 16 BamEnums const * 0 0 2127 0 0 0 0 0 0 0 0 0 0

2127 14 BamEnums const 0 8832 14 BamEnums const 14 BamEnums const 0 0 1967 0 0 0 0 0 0 0 0 0 0

2128 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 1977 0 0 0 0 0 0 0 0 0 0

2129 15 LoaderOptions * 0 8576 15 LoaderOptions * 15 LoaderOptions * 0 0 1971 0 0 0 0 0 0 0 0 0 0

2130 9 AuxData * 0 8576 20 BamReader::AuxData * 20 BamReader::AuxData * 0 0 2131 0 0 0 0 0 0 0 0 0 0

2131 7 AuxData 0 1312768 18 BamReader::AuxData 18 BamReader::AuxData 1974 0 0 0 0 0 0 0 0 0 0 0 187
// Inherit from this class to piggyback additional temporary data on the
// bamReader (via set_aux_data() and get_aux_data()) for any particular
// objects during the bam reading process.

2132 17 BamReader const * 0 8576 17 BamReader const * 17 BamReader const * 0 0 2133 0 0 0 0 0 0 0 0 0 0

2133 15 BamReader const 0 8832 15 BamReader const 15 BamReader const 0 0 1974 0 0 0 0 0 0 0 0 0 0

2134 17 BamWriter const * 0 8576 17 BamWriter const * 17 BamWriter const * 0 0 2135 0 0 0 0 0 0 0 0 0 0

2135 15 BamWriter const 0 8832 15 BamWriter const 15 BamWriter const 0 0 1981 0 0 0 0 0 0 0 0 0 0

2136 25 BitMask< uint16_t, 16 > * 0 8576 25 BitMask< uint16_t, 16 > * 25 BitMask< uint16_t, 16 > * 0 0 1984 0 0 0 0 0 0 0 0 0 0

2137 31 BitMask< uint16_t, 16 > const * 0 8576 31 BitMask< uint16_t, 16 > const * 31 BitMask< uint16_t, 16 > const * 0 0 2138 0 0 0 0 0 0 0 0 0 0

2138 29 BitMask< uint16_t, 16 > const 0 8832 29 BitMask< uint16_t, 16 > const 29 BitMask< uint16_t, 16 > const 0 0 1984 0 0 0 0 0 0 0 0 0 0

2139 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 2085 0 0 0 0 0 0 0 0 0 0

2140 25 BitMask< uint32_t, 32 > * 0 8576 25 BitMask< uint32_t, 32 > * 25 BitMask< uint32_t, 32 > * 0 0 1986 0 0 0 0 0 0 0 0 0 0

2141 31 BitMask< uint32_t, 32 > const * 0 8576 31 BitMask< uint32_t, 32 > const * 31 BitMask< uint32_t, 32 > const * 0 0 2142 0 0 0 0 0 0 0 0 0 0

2142 29 BitMask< uint32_t, 32 > const 0 8832 29 BitMask< uint32_t, 32 > const 29 BitMask< uint32_t, 32 > const 0 0 1986 0 0 0 0 0 0 0 0 0 0

2143 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 2144 0 0 0 0 0 0 0 0 0 0

2144 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

2145 25 BitMask< uint64_t, 64 > * 0 8576 25 BitMask< uint64_t, 64 > * 25 BitMask< uint64_t, 64 > * 0 0 1988 0 0 0 0 0 0 0 0 0 0

2146 31 BitMask< uint64_t, 64 > const * 0 8576 31 BitMask< uint64_t, 64 > const * 31 BitMask< uint64_t, 64 > const * 0 0 2147 0 0 0 0 0 0 0 0 0 0

2147 29 BitMask< uint64_t, 64 > const 0 8832 29 BitMask< uint64_t, 64 > const 29 BitMask< uint64_t, 64 > const 0 0 1988 0 0 0 0 0 0 0 0 0 0

2148 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 2084 0 0 0 0 0 0 0 0 0 0

2149 10 BitArray * 0 8576 10 BitArray * 10 BitArray * 0 0 1991 0 0 0 0 0 0 0 0 0 0

2150 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 2151 0 0 0 0 0 0 0 0 0 0

2151 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 1991 0 0 0 0 0 0 0 0 0 0

2152 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 2153 0 0 0 0 0 0 0 0 0 0

2153 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 2035 0 0 0 0 0 0 0 0 0 0

2154 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 2084 0 0 0 0 0 0 0 0 0 0

2155 8 WordType 0 2367488 18 BitArray::WordType 18 BitArray::WordType 1991 0 2148 0 0 0 0 0 0 0 0 0 0

2156 8 MaskType 0 2367488 18 BitArray::MaskType 18 BitArray::MaskType 1991 0 1990 0 0 0 0 0 0 0 0 0 0

2157 10 MaskType * 0 8576 20 BitArray::MaskType * 20 BitArray::MaskType * 0 0 2156 0 0 0 0 0 0 0 0 0 0

2158 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 1993 0 0 0 0 0 0 0 0 0 0

2159 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 2160 0 0 0 0 0 0 0 0 0 0

2160 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 1993 0 0 0 0 0 0 0 0 0 0

2161 22 ButtonRegistry const * 0 8576 22 ButtonRegistry const * 22 ButtonRegistry const * 0 0 2162 0 0 0 0 0 0 0 0 0 0

2162 20 ButtonRegistry const 0 8832 20 ButtonRegistry const 20 ButtonRegistry const 0 0 1997 0 0 0 0 0 0 0 0 0 0

2163 16 ButtonRegistry * 0 8576 16 ButtonRegistry * 16 ButtonRegistry * 0 0 1997 0 0 0 0 0 0 0 0 0 0

2164 11 ButtonMap * 0 8576 11 ButtonMap * 11 ButtonMap * 0 0 1998 0 0 0 0 0 0 0 0 0 0

2165 17 ButtonMap const * 0 8576 17 ButtonMap const * 17 ButtonMap const * 0 0 2166 0 0 0 0 0 0 0 0 0 0

2166 15 ButtonMap const 0 8832 15 ButtonMap const 15 ButtonMap const 0 0 1998 0 0 0 0 0 0 0 0 0 0

2167 22 CallbackObject const * 0 8576 22 CallbackObject const * 22 CallbackObject const * 0 0 2168 0 0 0 0 0 0 0 0 0 0

2168 20 CallbackObject const 0 8832 20 CallbackObject const 20 CallbackObject const 0 0 2000 0 0 0 0 0 0 0 0 0 0

2169 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 2000 0 0 0 0 0 0 0 0 0 0

2170 41 CachedTypedWritableReferenceCount const * 0 8576 41 CachedTypedWritableReferenceCount const * 41 CachedTypedWritableReferenceCount const * 0 0 2171 0 0 0 0 0 0 0 0 0 0

2171 39 CachedTypedWritableReferenceCount const 0 8832 39 CachedTypedWritableReferenceCount const 39 CachedTypedWritableReferenceCount const 0 0 2001 0 0 0 0 0 0 0 0 0 0

2172 20 CallbackData const * 0 8576 20 CallbackData const * 20 CallbackData const * 0 0 2173 0 0 0 0 0 0 0 0 0 0

2173 18 CallbackData const 0 8832 18 CallbackData const 18 CallbackData const 0 0 2002 0 0 0 0 0 0 0 0 0 0

2174 14 CallbackData * 0 8576 14 CallbackData * 14 CallbackData * 0 0 2002 0 0 0 0 0 0 0 0 0 0

2175 22 PythonCallbackObject * 0 8576 22 PythonCallbackObject * 22 PythonCallbackObject * 0 0 2003 0 0 0 0 0 0 0 0 0 0

2176 28 PythonCallbackObject const * 0 8576 28 PythonCallbackObject const * 28 PythonCallbackObject const * 0 0 2177 0 0 0 0 0 0 0 0 0 0

2177 26 PythonCallbackObject const 0 8832 26 PythonCallbackObject const 26 PythonCallbackObject const 0 0 2003 0 0 0 0 0 0 0 0 0 0

2178 9 TimeVal * 0 8576 9 TimeVal * 9 TimeVal * 0 0 2004 0 0 0 0 0 0 0 0 0 0

2179 15 TimeVal const * 0 8576 15 TimeVal const * 15 TimeVal const * 0 0 2180 0 0 0 0 0 0 0 0 0 0

2180 13 TimeVal const 0 8832 13 TimeVal const 13 TimeVal const 0 0 2004 0 0 0 0 0 0 0 0 0 0

2181 19 ClockObject const * 0 8576 19 ClockObject const * 19 ClockObject const * 0 0 2182 0 0 0 0 0 0 0 0 0 0

2182 17 ClockObject const 0 8832 17 ClockObject const 17 ClockObject const 0 0 2007 0 0 0 0 0 0 0 0 0 0

2183 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 2007 0 0 0 0 0 0 0 0 0 0

2184 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 2185 0 0 0 0 0 0 0 0 0 0

2185 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396
/**
 * A thread; that is, a lightweight process.  This is an abstract base class;
 * to use it, you must subclass from it and redefine thread_main().
 *
 * The thread itself will keep a reference count on the Thread object while it
 * is running; when the thread returns from its root function, the Thread
 * object will automatically be destructed if no other pointers are
 * referencing it.
 */

2186 25 CopyOnWriteObject const * 0 8576 25 CopyOnWriteObject const * 25 CopyOnWriteObject const * 0 0 2187 0 0 0 0 0 0 0 0 0 0

2187 23 CopyOnWriteObject const 0 8832 23 CopyOnWriteObject const 23 CopyOnWriteObject const 0 0 2011 0 0 0 0 0 0 0 0 0 0

2188 16 DatagramBuffer * 0 8576 16 DatagramBuffer * 16 DatagramBuffer * 0 0 2012 0 0 0 0 0 0 0 0 0 0

2189 19 DatagramInputFile * 0 8576 19 DatagramInputFile * 19 DatagramInputFile * 0 0 2016 0 0 0 0 0 0 0 0 0 0

2190 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 2191 0 0 0 0 0 0 0 0 0 0

2191 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 2192 0 0 0 0 0 0 0 0 0 0

2192 13 FileReference 0 2048 13 FileReference 13 FileReference 0 0 0 0 0 0 0 0 0 0 0 0 149
/**
 * Keeps a reference-counted pointer to a file on disk.  As long as the
 * FileReference is held, someone presumably has a use for this file.
 */

2193 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 2194 0 0 0 0 0 0 0 0 0 0

2194 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0

2195 20 DatagramOutputFile * 0 8576 20 DatagramOutputFile * 20 DatagramOutputFile * 0 0 2017 0 0 0 0 0 0 0 0 0 0

2196 32 DoubleBitMask< BitMaskNative > * 0 8576 32 DoubleBitMask< BitMaskNative > * 32 DoubleBitMask< BitMaskNative > * 0 0 2019 0 0 0 0 0 0 0 0 0 0

2197 38 DoubleBitMask< BitMaskNative > const * 0 8576 38 DoubleBitMask< BitMaskNative > const * 38 DoubleBitMask< BitMaskNative > const * 0 0 2198 0 0 0 0 0 0 0 0 0 0

2198 36 DoubleBitMask< BitMaskNative > const 0 8832 36 DoubleBitMask< BitMaskNative > const 36 DoubleBitMask< BitMaskNative > const 0 0 2019 0 0 0 0 0 0 0 0 0 0

2199 38 DoubleBitMask< DoubleBitMaskNative > * 0 8576 38 DoubleBitMask< DoubleBitMaskNative > * 38 DoubleBitMask< DoubleBitMaskNative > * 0 0 2021 0 0 0 0 0 0 0 0 0 0

2200 44 DoubleBitMask< DoubleBitMaskNative > const * 0 8576 44 DoubleBitMask< DoubleBitMaskNative > const * 44 DoubleBitMask< DoubleBitMaskNative > const * 0 0 2201 0 0 0 0 0 0 0 0 0 0

2201 42 DoubleBitMask< DoubleBitMaskNative > const 0 8832 42 DoubleBitMask< DoubleBitMaskNative > const 42 DoubleBitMask< DoubleBitMaskNative > const 0 0 2021 0 0 0 0 0 0 0 0 0 0

2202 15 GamepadButton * 0 8576 15 GamepadButton * 15 GamepadButton * 0 0 2024 0 0 0 0 0 0 0 0 0 0

2203 21 GamepadButton const * 0 8576 21 GamepadButton const * 21 GamepadButton const * 0 0 2204 0 0 0 0 0 0 0 0 0 0

2204 19 GamepadButton const 0 8832 19 GamepadButton const 19 GamepadButton const 0 0 2024 0 0 0 0 0 0 0 0 0 0

2205 16 KeyboardButton * 0 8576 16 KeyboardButton * 16 KeyboardButton * 0 0 2027 0 0 0 0 0 0 0 0 0 0

2206 22 KeyboardButton const * 0 8576 22 KeyboardButton const * 22 KeyboardButton const * 0 0 2207 0 0 0 0 0 0 0 0 0 0

2207 20 KeyboardButton const 0 8832 20 KeyboardButton const 20 KeyboardButton const 0 0 2027 0 0 0 0 0 0 0 0 0 0

2208 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 2028 0 0 0 0 0 0 0 0 0 0

2209 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 2210 0 0 0 0 0 0 0 0 0 0

2210 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 2028 0 0 0 0 0 0 0 0 0 0

2211 13 MouseButton * 0 8576 13 MouseButton * 13 MouseButton * 0 0 2029 0 0 0 0 0 0 0 0 0 0

2212 19 MouseButton const * 0 8576 19 MouseButton const * 19 MouseButton const * 0 0 2213 0 0 0 0 0 0 0 0 0 0

2213 17 MouseButton const 0 8832 17 MouseButton const 17 MouseButton const 0 0 2029 0 0 0 0 0 0 0 0 0 0

2214 13 PointerData * 0 8576 13 PointerData * 13 PointerData * 0 0 2031 0 0 0 0 0 0 0 0 0 0

2215 19 PointerData const * 0 8576 19 PointerData const * 19 PointerData const * 0 0 2216 0 0 0 0 0 0 0 0 0 0

2216 17 PointerData const 0 8832 17 PointerData const 17 PointerData const 0 0 2031 0 0 0 0 0 0 0 0 0 0

2217 32 NodeCachedReferenceCount const * 0 8576 32 NodeCachedReferenceCount const * 32 NodeCachedReferenceCount const * 0 0 2218 0 0 0 0 0 0 0 0 0 0

2218 30 NodeCachedReferenceCount const 0 8832 30 NodeCachedReferenceCount const 30 NodeCachedReferenceCount const 0 0 2033 0 0 0 0 0 0 0 0 0 0

2219 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 2035 0 0 0 0 0 0 0 0 0 0

2220 22 ParamValueBase const * 0 8576 22 ParamValueBase const * 22 ParamValueBase const * 0 0 2221 0 0 0 0 0 0 0 0 0 0

2221 20 ParamValueBase const 0 8832 20 ParamValueBase const 20 ParamValueBase const 0 0 2036 0 0 0 0 0 0 0 0 0 0

2222 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 2223 0 0 0 0 0 0 0 0 0 0

2223 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 1999 0 0 0 0 0 0 0 0 0 0

2224 20 ParamTypedRefCount * 0 8576 20 ParamTypedRefCount * 20 ParamTypedRefCount * 0 0 2037 0 0 0 0 0 0 0 0 0 0

2225 26 ParamTypedRefCount const * 0 8576 26 ParamTypedRefCount const * 26 ParamTypedRefCount const * 0 0 2226 0 0 0 0 0 0 0 0 0 0

2226 24 ParamTypedRefCount const 0 8832 24 ParamTypedRefCount const 24 ParamTypedRefCount const 0 0 2037 0 0 0 0 0 0 0 0 0 0

2227 22 ParamValue< string > * 0 8576 27 ParamValue< std::string > * 27 ParamValue< std::string > * 0 0 2039 0 0 0 0 0 0 0 0 0 0

2228 28 ParamValue< string > const * 0 8576 33 ParamValue< std::string > const * 33 ParamValue< std::string > const * 0 0 2229 0 0 0 0 0 0 0 0 0 0

2229 26 ParamValue< string > const 0 8832 31 ParamValue< std::string > const 31 ParamValue< std::string > const 0 0 2039 0 0 0 0 0 0 0 0 0 0

2230 23 ParamValue< wstring > * 0 8576 28 ParamValue< std::wstring > * 28 ParamValue< std::wstring > * 0 0 2042 0 0 0 0 0 0 0 0 0 0

2231 29 ParamValue< wstring > const * 0 8576 34 ParamValue< std::wstring > const * 34 ParamValue< std::wstring > const * 0 0 2232 0 0 0 0 0 0 0 0 0 0

2232 27 ParamValue< wstring > const 0 8832 32 ParamValue< std::wstring > const 32 ParamValue< std::wstring > const 0 0 2042 0 0 0 0 0 0 0 0 0 0

2233 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2234 0 0 0 0 0 0 0 0 0 0

2234 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2235 0 0 0 0 0 0 0 0 0 0

2235 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2236 26 ParamValue< LVecBase2d > * 0 8576 26 ParamValue< LVecBase2d > * 26 ParamValue< LVecBase2d > * 0 0 2044 0 0 0 0 0 0 0 0 0 0

2237 32 ParamValue< LVecBase2d > const * 0 8576 32 ParamValue< LVecBase2d > const * 32 ParamValue< LVecBase2d > const * 0 0 2238 0 0 0 0 0 0 0 0 0 0

2238 30 ParamValue< LVecBase2d > const 0 8832 30 ParamValue< LVecBase2d > const 30 ParamValue< LVecBase2d > const 0 0 2044 0 0 0 0 0 0 0 0 0 0

2239 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 2240 0 0 0 0 0 0 0 0 0 0

2240 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 2241 0 0 0 0 0 0 0 0 0 0

2241 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2242 26 ParamValue< LVecBase2f > * 0 8576 26 ParamValue< LVecBase2f > * 26 ParamValue< LVecBase2f > * 0 0 2046 0 0 0 0 0 0 0 0 0 0

2243 32 ParamValue< LVecBase2f > const * 0 8576 32 ParamValue< LVecBase2f > const * 32 ParamValue< LVecBase2f > const * 0 0 2244 0 0 0 0 0 0 0 0 0 0

2244 30 ParamValue< LVecBase2f > const 0 8832 30 ParamValue< LVecBase2f > const 30 ParamValue< LVecBase2f > const 0 0 2046 0 0 0 0 0 0 0 0 0 0

2245 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 2246 0 0 0 0 0 0 0 0 0 0

2246 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 2247 0 0 0 0 0 0 0 0 0 0

2247 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

2248 26 ParamValue< LVecBase2i > * 0 8576 26 ParamValue< LVecBase2i > * 26 ParamValue< LVecBase2i > * 0 0 2048 0 0 0 0 0 0 0 0 0 0

2249 32 ParamValue< LVecBase2i > const * 0 8576 32 ParamValue< LVecBase2i > const * 32 ParamValue< LVecBase2i > const * 0 0 2250 0 0 0 0 0 0 0 0 0 0

2250 30 ParamValue< LVecBase2i > const 0 8832 30 ParamValue< LVecBase2i > const 30 ParamValue< LVecBase2i > const 0 0 2048 0 0 0 0 0 0 0 0 0 0

2251 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2252 0 0 0 0 0 0 0 0 0 0

2252 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2253 0 0 0 0 0 0 0 0 0 0

2253 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2254 26 ParamValue< LVecBase3d > * 0 8576 26 ParamValue< LVecBase3d > * 26 ParamValue< LVecBase3d > * 0 0 2050 0 0 0 0 0 0 0 0 0 0

2255 32 ParamValue< LVecBase3d > const * 0 8576 32 ParamValue< LVecBase3d > const * 32 ParamValue< LVecBase3d > const * 0 0 2256 0 0 0 0 0 0 0 0 0 0

2256 30 ParamValue< LVecBase3d > const 0 8832 30 ParamValue< LVecBase3d > const 30 ParamValue< LVecBase3d > const 0 0 2050 0 0 0 0 0 0 0 0 0 0

2257 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 2258 0 0 0 0 0 0 0 0 0 0

2258 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 2259 0 0 0 0 0 0 0 0 0 0

2259 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2260 26 ParamValue< LVecBase3f > * 0 8576 26 ParamValue< LVecBase3f > * 26 ParamValue< LVecBase3f > * 0 0 2052 0 0 0 0 0 0 0 0 0 0

2261 32 ParamValue< LVecBase3f > const * 0 8576 32 ParamValue< LVecBase3f > const * 32 ParamValue< LVecBase3f > const * 0 0 2262 0 0 0 0 0 0 0 0 0 0

2262 30 ParamValue< LVecBase3f > const 0 8832 30 ParamValue< LVecBase3f > const 30 ParamValue< LVecBase3f > const 0 0 2052 0 0 0 0 0 0 0 0 0 0

2263 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 2264 0 0 0 0 0 0 0 0 0 0

2264 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 2265 0 0 0 0 0 0 0 0 0 0

2265 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2266 26 ParamValue< LVecBase3i > * 0 8576 26 ParamValue< LVecBase3i > * 26 ParamValue< LVecBase3i > * 0 0 2054 0 0 0 0 0 0 0 0 0 0

2267 32 ParamValue< LVecBase3i > const * 0 8576 32 ParamValue< LVecBase3i > const * 32 ParamValue< LVecBase3i > const * 0 0 2268 0 0 0 0 0 0 0 0 0 0

2268 30 ParamValue< LVecBase3i > const 0 8832 30 ParamValue< LVecBase3i > const 30 ParamValue< LVecBase3i > const 0 0 2054 0 0 0 0 0 0 0 0 0 0

2269 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2270 0 0 0 0 0 0 0 0 0 0

2270 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2271 0 0 0 0 0 0 0 0 0 0

2271 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2272 26 ParamValue< LVecBase4d > * 0 8576 26 ParamValue< LVecBase4d > * 26 ParamValue< LVecBase4d > * 0 0 2056 0 0 0 0 0 0 0 0 0 0

2273 32 ParamValue< LVecBase4d > const * 0 8576 32 ParamValue< LVecBase4d > const * 32 ParamValue< LVecBase4d > const * 0 0 2274 0 0 0 0 0 0 0 0 0 0

2274 30 ParamValue< LVecBase4d > const 0 8832 30 ParamValue< LVecBase4d > const 30 ParamValue< LVecBase4d > const 0 0 2056 0 0 0 0 0 0 0 0 0 0

2275 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 2276 0 0 0 0 0 0 0 0 0 0

2276 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 2277 0 0 0 0 0 0 0 0 0 0

2277 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2278 26 ParamValue< LVecBase4f > * 0 8576 26 ParamValue< LVecBase4f > * 26 ParamValue< LVecBase4f > * 0 0 2058 0 0 0 0 0 0 0 0 0 0

2279 32 ParamValue< LVecBase4f > const * 0 8576 32 ParamValue< LVecBase4f > const * 32 ParamValue< LVecBase4f > const * 0 0 2280 0 0 0 0 0 0 0 0 0 0

2280 30 ParamValue< LVecBase4f > const 0 8832 30 ParamValue< LVecBase4f > const 30 ParamValue< LVecBase4f > const 0 0 2058 0 0 0 0 0 0 0 0 0 0

2281 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 2282 0 0 0 0 0 0 0 0 0 0

2282 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 2283 0 0 0 0 0 0 0 0 0 0

2283 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

2284 26 ParamValue< LVecBase4i > * 0 8576 26 ParamValue< LVecBase4i > * 26 ParamValue< LVecBase4i > * 0 0 2060 0 0 0 0 0 0 0 0 0 0

2285 32 ParamValue< LVecBase4i > const * 0 8576 32 ParamValue< LVecBase4i > const * 32 ParamValue< LVecBase4i > const * 0 0 2286 0 0 0 0 0 0 0 0 0 0

2286 30 ParamValue< LVecBase4i > const 0 8832 30 ParamValue< LVecBase4i > const 30 ParamValue< LVecBase4i > const 0 0 2060 0 0 0 0 0 0 0 0 0 0

2287 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2288 0 0 0 0 0 0 0 0 0 0

2288 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2289 0 0 0 0 0 0 0 0 0 0

2289 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2290 25 ParamValue< LMatrix3d > * 0 8576 25 ParamValue< LMatrix3d > * 25 ParamValue< LMatrix3d > * 0 0 2062 0 0 0 0 0 0 0 0 0 0

2291 31 ParamValue< LMatrix3d > const * 0 8576 31 ParamValue< LMatrix3d > const * 31 ParamValue< LMatrix3d > const * 0 0 2292 0 0 0 0 0 0 0 0 0 0

2292 29 ParamValue< LMatrix3d > const 0 8832 29 ParamValue< LMatrix3d > const 29 ParamValue< LMatrix3d > const 0 0 2062 0 0 0 0 0 0 0 0 0 0

2293 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 2294 0 0 0 0 0 0 0 0 0 0

2294 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 2295 0 0 0 0 0 0 0 0 0 0

2295 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

2296 25 ParamValue< LMatrix3f > * 0 8576 25 ParamValue< LMatrix3f > * 25 ParamValue< LMatrix3f > * 0 0 2064 0 0 0 0 0 0 0 0 0 0

2297 31 ParamValue< LMatrix3f > const * 0 8576 31 ParamValue< LMatrix3f > const * 31 ParamValue< LMatrix3f > const * 0 0 2298 0 0 0 0 0 0 0 0 0 0

2298 29 ParamValue< LMatrix3f > const 0 8832 29 ParamValue< LMatrix3f > const 29 ParamValue< LMatrix3f > const 0 0 2064 0 0 0 0 0 0 0 0 0 0

2299 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2300 0 0 0 0 0 0 0 0 0 0

2300 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2301 0 0 0 0 0 0 0 0 0 0

2301 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2302 25 ParamValue< LMatrix4d > * 0 8576 25 ParamValue< LMatrix4d > * 25 ParamValue< LMatrix4d > * 0 0 2066 0 0 0 0 0 0 0 0 0 0

2303 31 ParamValue< LMatrix4d > const * 0 8576 31 ParamValue< LMatrix4d > const * 31 ParamValue< LMatrix4d > const * 0 0 2304 0 0 0 0 0 0 0 0 0 0

2304 29 ParamValue< LMatrix4d > const 0 8832 29 ParamValue< LMatrix4d > const 29 ParamValue< LMatrix4d > const 0 0 2066 0 0 0 0 0 0 0 0 0 0

2305 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 2306 0 0 0 0 0 0 0 0 0 0

2306 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 2307 0 0 0 0 0 0 0 0 0 0

2307 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

2308 25 ParamValue< LMatrix4f > * 0 8576 25 ParamValue< LMatrix4f > * 25 ParamValue< LMatrix4f > * 0 0 2068 0 0 0 0 0 0 0 0 0 0

2309 31 ParamValue< LMatrix4f > const * 0 8576 31 ParamValue< LMatrix4f > const * 31 ParamValue< LMatrix4f > const * 0 0 2310 0 0 0 0 0 0 0 0 0 0

2310 29 ParamValue< LMatrix4f > const 0 8832 29 ParamValue< LMatrix4f > const 29 ParamValue< LMatrix4f > const 0 0 2068 0 0 0 0 0 0 0 0 0 0

2311 19 UniqueIdAllocator * 0 8576 19 UniqueIdAllocator * 19 UniqueIdAllocator * 0 0 2076 0 0 0 0 0 0 0 0 0 0

2312 25 UniqueIdAllocator const * 0 8576 25 UniqueIdAllocator const * 25 UniqueIdAllocator const * 0 0 2313 0 0 0 0 0 0 0 0 0 0

2313 23 UniqueIdAllocator const 0 8832 23 UniqueIdAllocator const 23 UniqueIdAllocator const 0 0 2076 0 0 0 0 0 0 0 0 0 0

2314 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 2315 0 0 0 0 0 0 0 0 0 0

2315 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

2316 26 ConfigVariableSearchPath * 0 8576 26 ConfigVariableSearchPath * 26 ConfigVariableSearchPath * 0 0 2317 0 0 0 0 0 0 0 0 0 0

2317 24 ConfigVariableSearchPath 0 2048 24 ConfigVariableSearchPath 24 ConfigVariableSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 731
/**
 * This is similar to a ConfigVariableList, but it returns its list as a
 * DSearchPath, as a list of directories.
 *
 * You may locally append directories to the end of the search path with the
 * methods here, or prepend them to the beginning.  Use these methods to make
 * adjustments to the path; do not attempt to directly modify the const
 * DSearchPath object returned by get_value().
 *
 * Unlike other ConfigVariable types, local changes (made by calling
 * append_directory() and prepend_directory()) are specific to this particular
 * instance of the ConfigVariableSearchPath.  A separate instance of the same
 * variable, created by using the same name to the constructor, will not
 * reflect the local changes.
 */

2318 12 ConfigPage * 0 8576 12 ConfigPage * 12 ConfigPage * 0 0 2319 0 0 0 0 0 0 0 0 0 0

2319 10 ConfigPage 0 2048 10 ConfigPage 10 ConfigPage 0 0 0 0 0 0 0 0 0 0 0 0 262
/**
 * A page of ConfigDeclarations that may be loaded or unloaded.  Typically
 * this represents a single .prc file that is read from disk at runtime, but
 * it may also represent a list of declarations built up by application code
 * and explicitly loaded.
 */

2320 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 2321 0 0 0 0 0 0 0 0 0 0

2321 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 0

0
83
2322 9 play_rate 0 6 1948 1024 1023 0 0 0 0 0 0 24 AnimInterface::play_rate 0

2323 10 frame_rate 0 2 1948 1025 0 0 0 0 0 0 0 25 AnimInterface::frame_rate 0

2324 10 num_frames 0 2 1949 1026 0 0 0 0 0 0 0 25 AnimInterface::num_frames 0

2325 5 frame 0 2 1949 1027 0 0 0 0 0 0 0 20 AnimInterface::frame 0

2326 10 next_frame 0 2 1949 1028 0 0 0 0 0 0 0 25 AnimInterface::next_frame 0

2327 4 frac 0 2 1948 1029 0 0 0 0 0 0 0 19 AnimInterface::frac 0

2328 10 full_frame 0 2 1949 1030 0 0 0 0 0 0 0 25 AnimInterface::full_frame 0

2329 11 full_fframe 0 2 1948 1031 0 0 0 0 0 0 0 26 AnimInterface::full_fframe 0

2330 7 playing 0 2 1950 1032 0 0 0 0 0 0 0 22 AnimInterface::playing 0

2331 3 seq 0 2 1953 1053 0 0 0 0 0 0 0 14 UpdateSeq::seq 0

2332 15 source_pathname 0 2 1962 1078 0 0 0 0 0 0 0 31 BamCacheRecord::source_pathname 0

2333 14 cache_filename 0 2 1962 1079 0 0 0 0 0 0 0 30 BamCacheRecord::cache_filename 0

2334 16 source_timestamp 0 2 1964 1080 0 0 0 0 0 0 0 32 BamCacheRecord::source_timestamp 0

2335 13 recorded_time 0 2 1964 1081 0 0 0 0 0 0 0 29 BamCacheRecord::recorded_time 0

2336 4 data 0 30 1965 1089 1091 1087 1088 0 0 0 0 20 BamCacheRecord::data 0

2337 6 active 0 6 1950 1098 1097 0 0 0 0 0 0 16 BamCache::active 0

2338 12 cache_models 0 6 1950 1100 1099 0 0 0 0 0 0 22 BamCache::cache_models 0

2339 14 cache_textures 0 6 1950 1102 1101 0 0 0 0 0 0 24 BamCache::cache_textures 0

2340 25 cache_compressed_textures 0 6 1950 1104 1103 0 0 0 0 0 0 35 BamCache::cache_compressed_textures 0

2341 22 cache_compiled_shaders 0 6 1950 1106 1105 0 0 0 0 0 0 32 BamCache::cache_compiled_shaders 0

2342 4 root 0 6 1963 1108 1107 0 0 0 0 0 0 14 BamCache::root 0

2343 10 flush_time 0 6 1949 1110 1109 0 0 0 0 0 0 20 BamCache::flush_time 0

2344 16 cache_max_kbytes 0 6 1949 1112 1111 0 0 0 0 0 0 26 BamCache::cache_max_kbytes 0

2345 9 read_only 0 6 1950 1114 1113 0 0 0 0 0 0 19 BamCache::read_only 0

2346 5 flags 0 6 1949 1127 1126 0 0 0 0 0 0 20 LoaderOptions::flags 0

2347 13 texture_flags 0 6 1949 1129 1128 0 0 0 0 0 0 28 LoaderOptions::texture_flags 0

2348 17 texture_num_views 0 6 1949 1131 1130 0 0 0 0 0 0 32 LoaderOptions::texture_num_views 0

2349 18 auto_texture_scale 0 6 1951 1133 1132 0 0 0 0 0 0 33 LoaderOptions::auto_texture_scale 0

2350 6 source 0 6 1975 1139 1138 0 0 0 0 0 0 17 BamReader::source 0

2351 8 filename 0 2 1962 1143 0 0 0 0 0 0 0 19 BamReader::filename 0

2352 14 loader_options 0 6 1977 1144 1145 0 0 0 0 0 0 25 BamReader::loader_options 0

2353 12 file_version 0 2 1978 1156 0 0 0 0 0 0 0 23 BamReader::file_version 0

2354 11 file_endian 0 2 1968 1152 0 0 0 0 0 0 0 22 BamReader::file_endian 0

2355 20 file_stdfloat_double 0 2 1950 1153 0 0 0 0 0 0 0 31 BamReader::file_stdfloat_double 0

2356 6 target 0 6 1982 1161 1160 0 0 0 0 0 0 17 BamWriter::target 0

2357 8 filename 0 2 1962 1163 0 0 0 0 0 0 0 19 BamWriter::filename 0

2358 11 file_endian 0 2 1968 1170 0 0 0 0 0 0 0 22 BamWriter::file_endian 0

2359 20 file_stdfloat_double 0 2 1950 1171 0 0 0 0 0 0 0 31 BamWriter::file_stdfloat_double 0

2360 17 file_texture_mode 0 2 1970 1172 0 0 0 0 0 0 0 28 BamWriter::file_texture_mode 0

2361 9 root_node 0 6 1965 1174 1175 0 0 0 0 0 0 20 BamWriter::root_node 0

2362 5 index 0 2 1949 1446 0 0 0 0 0 0 0 19 ButtonHandle::index 0

2363 4 name 0 2 1994 1441 0 0 0 0 0 0 0 18 ButtonHandle::name 0

2364 16 ascii_equivalent 0 10 1996 1443 0 1442 0 0 0 0 0 30 ButtonHandle::ascii_equivalent 0

2365 5 alias 0 2 1993 1444 0 0 0 0 0 0 0 19 ButtonHandle::alias 0

2366 15 cache_ref_count 0 2 1949 1473 0 0 0 0 0 0 0 50 CachedTypedWritableReferenceCount::cache_ref_count 0

2367 8 function 0 6 1978 1487 1486 0 0 0 0 0 0 30 PythonCallbackObject::function 0

2368 2 tv 0 6 2005 1493 1494 0 0 0 0 0 0 11 TimeVal::tv 0

2369 4 mode 0 6 2008 1498 1497 0 0 0 0 0 0 17 ClockObject::mode 0

2370 10 frame_time 0 6 1948 1499 1504 0 0 0 0 0 0 23 ClockObject::frame_time 0

2371 9 real_time 0 6 1948 1500 1503 0 0 0 0 0 0 22 ClockObject::real_time 0

2372 9 long_time 0 2 1948 1501 0 0 0 0 0 0 0 22 ClockObject::long_time 0

2373 11 frame_count 0 6 1949 1506 1505 0 0 0 0 0 0 24 ClockObject::frame_count 0

2374 2 dt 0 6 1948 1508 1509 0 0 0 0 0 0 15 ClockObject::dt 0

2375 6 max_dt 0 6 1948 1511 1512 0 0 0 0 0 0 19 ClockObject::max_dt 0

2376 14 degrade_factor 0 6 1948 1513 1514 0 0 0 0 0 0 27 ClockObject::degrade_factor 0

2377 27 average_frame_rate_interval 0 6 1948 1516 1515 0 0 0 0 0 0 40 ClockObject::average_frame_rate_interval 0

2378 18 average_frame_rate 0 2 1948 1517 0 0 0 0 0 0 0 31 ClockObject::average_frame_rate 0

2379 18 max_frame_duration 0 2 1948 1518 0 0 0 0 0 0 0 31 ClockObject::max_frame_duration 0

2380 4 data 0 6 2013 1539 1540 0 0 0 0 0 0 20 DatagramBuffer::data 0

2381 6 stream 0 2 2018 1551 0 0 0 0 0 0 0 26 DatagramOutputFile::stream 0

2382 7 buttons 0 66 1993 1771 0 0 0 0 1770 0 0 24 ModifierButtons::buttons 0

2383 1 x 0 2 1948 1793 0 0 0 0 0 0 0 14 PointerData::x 0

2384 1 y 0 2 1948 1794 0 0 0 0 0 0 0 14 PointerData::y 0

2385 4 type 0 2 2030 1796 0 0 0 0 0 0 0 17 PointerData::type 0

2386 2 id 0 2 1949 1797 0 0 0 0 0 0 0 15 PointerData::id 0

2387 9 in_window 0 2 1950 1795 0 0 0 0 0 0 0 22 PointerData::in_window 0

2388 8 pressure 0 2 1948 1798 0 0 0 0 0 0 0 21 PointerData::pressure 0

2389 5 value 0 2 2038 1867 0 0 0 0 0 0 0 25 ParamTypedRefCount::value 0

2390 5 value 0 6 2040 1871 1870 0 0 0 0 0 0 27 ParamValue< string >::value 0

2391 5 value 0 6 2040 1875 1874 0 0 0 0 0 0 28 ParamValue< wstring >::value 0

2392 5 value 0 6 2040 1879 1878 0 0 0 0 0 0 31 ParamValue< LVecBase2d >::value 0

2393 5 value 0 6 2040 1883 1882 0 0 0 0 0 0 31 ParamValue< LVecBase2f >::value 0

2394 5 value 0 6 2040 1887 1886 0 0 0 0 0 0 31 ParamValue< LVecBase2i >::value 0

2395 5 value 0 6 2040 1891 1890 0 0 0 0 0 0 31 ParamValue< LVecBase3d >::value 0

2396 5 value 0 6 2040 1895 1894 0 0 0 0 0 0 31 ParamValue< LVecBase3f >::value 0

2397 5 value 0 6 2040 1899 1898 0 0 0 0 0 0 31 ParamValue< LVecBase3i >::value 0

2398 5 value 0 6 2040 1903 1902 0 0 0 0 0 0 31 ParamValue< LVecBase4d >::value 0

2399 5 value 0 6 2040 1907 1906 0 0 0 0 0 0 31 ParamValue< LVecBase4f >::value 0

2400 5 value 0 6 2040 1911 1910 0 0 0 0 0 0 31 ParamValue< LVecBase4i >::value 0

2401 5 value 0 6 2040 1915 1914 0 0 0 0 0 0 30 ParamValue< LMatrix3d >::value 0

2402 5 value 0 6 2040 1919 1918 0 0 0 0 0 0 30 ParamValue< LMatrix3f >::value 0

2403 5 value 0 6 2040 1923 1922 0 0 0 0 0 0 30 ParamValue< LMatrix4d >::value 0

2404 5 value 0 6 2040 1927 1926 0 0 0 0 0 0 30 ParamValue< LMatrix4f >::value 0

1
2405 11 get_buttons 0 1770 1771 28 ModifierButtons::get_buttons 0

